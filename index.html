<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—è—Ç–Ω–∞—à–∫–∏–Ω—ÅüéÄ</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Pacifico&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --primary-color: #6c5ce7;
            --secondary-color: #a29bfe;
            --accent-color: #fd79a8;
            --dark-color: #2d3436;
            --light-color: #f5f6fa;
            --success-color: #00b894;
            --warning-color: #fdcb6e;
            --danger-color: #e17055;
            --tile-color: #ffeaa7;
            --highlight-color: #74b9ff;
            --correct-color: #55efc4;
            --info-color: #0984e3;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--light-color);
            color: var(--dark-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 20px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 10;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .logo {
            font-family: 'Pacifico', cursive;
            font-size: 2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo i {
            color: var(--accent-color);
        }
        
        .header-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .score-display {
            background-color: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
        }

        .score-display i {
            color: var(--warning-color);
        }
        
        /* Main content */
        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 30px 0;
        }

        /* Game area */
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
            width: 100%;
            overflow: auto;
            position: relative;
        }

        .game-field {
            display: grid;
            gap: 8px;
            margin: 20px auto;
            border: 3px solid var(--primary-color);
            touch-action: none;
            border-radius: 15px;
            background-color: white;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .tile {
            background-color: var(--tile-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            border-radius: 10px;
            transition: transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            position: absolute;
            width: 60px;
            height: 60px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            color: var(--dark-color);
            border: 2px solid transparent;
            user-select: none;
            overflow: hidden;
            opacity: 0;
        }

        .tile.show {
            opacity: 1;
        }

        .tile.correct {
            border-color: var(--correct-color);
            box-shadow: 0 0 15px rgba(85, 239, 196, 0.5);
        }

        .tile.highlight {
            z-index: 10;
            background-color: var(--highlight-color);
            color: white;
            box-shadow: 0 0 20px rgba(116, 185, 255, 0.7);
        }

        .tile-inner {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            transition: opacity 0.3s ease;
        }

        .tile.highlight .tile-inner {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .tile.correct-position {
            animation: correctGlow 1s ease;
        }

        @keyframes correctGlow {
            0% { box-shadow: 0 0 10px rgba(85, 239, 196, 0.5); }
            50% { box-shadow: 0 0 20px rgba(85, 239, 196, 0.8); }
            100% { box-shadow: 0 0 10px rgba(85, 239, 196, 0.5); }
        }

        .empty-tile {
            background-color: transparent;
            color: transparent;
            border: none;
            box-shadow: none;
            opacity: 1 !important;
        }

        .tile.obstacle-tile {
            background-color: #b2bec3;
            cursor: not-allowed;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        
        .tile.hidden-number .tile-inner {
            opacity: 0;
        }

        .tile.hidden-number.revealed .tile-inner {
            opacity: 1;
        }

        .tile.hidden-path-hidden .tile-inner {
            opacity: 0;
        }

        .hint-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.1rem;
            text-align: center;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .hint-message.active {
            opacity: 1;
            visibility: visible;
        }

        /* Tabs */
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            position: relative;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tab-button {
            padding: 12px 25px;
            background: white;
            border: none;
            border-radius: 30px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--dark-color);
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(108, 92, 231, 0.4);
        }

        .tab-button i {
            font-size: 1.1rem;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
        
        /* ‚ú® –ò–ó–ú–ï–ù–ï–ù–ò–ï: –°—Ç–∏–ª–∏ –¥–ª—è —Å–µ—Ç–æ–∫ –∏ –∫–∞—Ä—Ç–æ—á–µ–∫ –≤–æ –≤—Å–µ—Ö –≤–∫–ª–∞–¥–∫–∞—Ö, –≤–∫–ª—é—á–∞—è –∞–Ω–∏–º–∞—Ü–∏—é */
        .settings-grid, .achievements-grid, .modes-grid, .stats-grid, .archive-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            /* –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ */
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.4s ease-out, transform 0.4s ease-out, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px); /* –ü–æ–¥—ä–µ–º –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ –æ—Å—Ç–∞–µ—Ç—Å—è, –Ω–æ —Ç–µ–ø–µ—Ä—å –æ–Ω –±—É–¥–µ—Ç —Å–æ–≤–º–µ—â–∞—Ç—å—Å—è —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π –ø–æ—è–≤–ª–µ–Ω–∏—è */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        /* –ö–ª–∞—Å—Å –¥–ª—è –≤–∏–¥–∏–º—ã—Ö –∫–∞—Ä—Ç–æ—á–µ–∫ */
        .card.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .settings-card h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.2rem;
        }

        .settings-card h3 i {
            color: var(--accent-color);
        }
        
        .stats-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .stats-icon {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .stats-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--dark-color);
            line-height: 1;
        }

        .stats-label {
            font-size: 1rem;
            color: #636e72;
            margin-top: 5px;
        }
        
        .stats-list-card {
            grid-column: 1 / -1;
        }
        
        .stats-list-card h3 {
             color: var(--primary-color);
             margin-bottom: 15px;
        }

        .stats-list {
            list-style: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dfe6e9;
            border-radius: 10px;
            padding: 10px;
        }
        
        .stats-list li {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 8px;
            transition: background-color 0.2s;
            flex-wrap: wrap;
        }

        .stats-list li:nth-child(odd) {
            background-color: rgba(108, 92, 231, 0.05);
        }
        
        .stats-list li:hover {
            background-color: rgba(108, 92, 231, 0.1);
        }

        .stats-list-label {
            font-weight: 600;
            flex-basis: 60%;
        }

        .stats-list-value {
            font-weight: 700;
            color: var(--primary-color);
            flex-basis: 35%;
            text-align: right;
        }
        
        .stats-sub-list {
            list-style: none;
            padding-left: 20px;
            margin-top: 5px;
            font-size: 0.9em;
            color: #636e72;
        }

        .stats-sub-list li {
            padding: 3px 0;
            display: flex;
            justify-content: space-between;
        }

        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .control-label {
            min-width: 120px;
            font-size: 14px;
            margin-right: 10px;
            color: var(--dark-color);
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            border: 3px solid white;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        input[type="range"] {
            flex-grow: 1;
            height: 8px;
            border-radius: 4px;
            background: var(--secondary-color);
            -webkit-appearance: none;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .range-value {
            min-width: 40px;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            color: var(--primary-color);
            margin-left: 10px;
        }

        .btn {
            padding: 12px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(108, 92, 231, 0.3);
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(108, 92, 231, 0.4);
        }
        
        .btn:disabled {
            background-color: #b2bec3;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn i {
            font-size: 1rem;
        }

        .btn-block {
            display: block;
            width: 100%;
        }

        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label.btn {
            margin-bottom: 0;
        }

        .input-group input[type="number"],
        .input-group input[type="file"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #dfe6e9;
            border-radius: 30px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .input-group input[type="number"]:focus,
        .input-group input[type="file"]:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.2);
        }
        
        .input-group input[type="file"] {
            display: none;
        }

        .achievements-intro {
            text-align: center;
            font-size: 1rem;
            color: #636e72;
            margin: 0 auto 20px;
            max-width: 600px;
            padding: 15px;
            border-radius: 12px;
        }
        
        .achievement-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .achievement-card.locked {
            opacity: 0.7;
            filter: grayscale(70%);
        }

        .achievement-icon {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            color: white;
            font-size: 1.8rem;
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.3);
        }

        .achievement-card.locked .achievement-icon {
            background: linear-gradient(135deg, #b2bec3, #dfe6e9);
        }

        .achievement-title {
            font-weight: 700;
            margin-bottom: 5px;
            color: var(--dark-color);
        }

        .achievement-desc {
            font-size: 0.9rem;
            color: #636e72;
            margin-bottom: 10px;
        }

        .achievement-progress {
            width: 100%;
            height: 6px;
            background: #dfe6e9;
            border-radius: 3px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--danger-color));
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .achievement-points {
            font-weight: 700;
            color: var(--primary-color);
            font-size: 0.9rem;
        }

        .ribbon {
            position: absolute;
            top: 10px;
            right: -30px;
            background: var(--accent-color);
            color: white;
            padding: 3px 30px;
            font-size: 0.7rem;
            font-weight: 600;
            transform: rotate(45deg);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .mode-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .mode-card.active {
            border-color: var(--primary-color);
            background: rgba(108, 92, 231, 0.05);
        }

        .mode-icon {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            color: white;
            font-size: 1.8rem;
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.3);
        }

        .mode-title {
            font-weight: 700;
            margin-bottom: 5px;
            color: var(--dark-color);
        }

        .mode-desc {
            font-size: 0.9rem;
            color: #636e72;
        }
        
        /* ‚ú® –ò–ó–ú–ï–ù–ï–ù–ò–ï: –°—Ç–∏–ª–∏ –¥–ª—è –∫–∞—Ä—Ç–æ—á–µ–∫ –∞—Ä—Ö–∏–≤–∞ */
        .archive-card {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            text-decoration: none;
            color: var(--dark-color);
        }
        
        .archive-card.current-version {
            background-color: rgba(108, 92, 231, 0.1);
            border: 2px solid var(--primary-color);
            cursor: default;
        }
        
        .archive-card .version-date {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 5px;
        }
        
        .archive-card .version-label {
            font-size: 0.9rem;
            color: #636e72;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-50px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-content h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .modal-content p {
            color: var(--dark-color);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .modal-content .btn {
            margin: 0 5px;
        }

        @keyframes confetti {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: var(--accent-color);
            opacity: 0;
            z-index: 1000;
            animation: confetti 3s ease-out forwards;
        }
        
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        .fa-spinner {
            animation: spin 1s linear infinite;
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 15px;
            }
            
            .tabs {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .tab-button {
                margin: 5px;
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .settings-grid, .achievements-grid, .modes-grid, .stats-grid, .archive-grid {
                grid-template-columns: 1fr;
            }
            
            .tile {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        @media (max-width: 480px) {
            .logo {
                font-size: 1.5rem;
            }
            
            .score-display {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .tile {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            .control-row {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .control-label {
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container header-content">
            <div class="logo">
                <i class="fas fa-gamepad"></i>
                <span>–ü—è—Ç–Ω–∞—à–∫–∏–Ω—ÅüéÄ</span>
            </div>
            <div class="header-info">
                <div class="score-display" id="scoreDisplay">
                    <i class="fas fa-star"></i>
                    <span>–û—á–∫–∏: 0</span>
                </div>
                <div class="score-display" id="gameStatusDisplay"></div>
            </div>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <div class="game-area">
                <div class="game-field" id="gameField"></div>
                <div class="hint-message" id="hintMessage">
                    –°–º–∞—Ö–Ω–∏—Ç–µ –ø–ª–∏—Ç–∫—É, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!
                </div>
            </div>

            <!-- ‚ú® –ò–ó–ú–ï–ù–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω–∞ –≤–∫–ª–∞–¥–∫–∞ "–ê—Ä—Ö–∏–≤" -->
            <div class="tabs">
                <button class="tab-button active" data-tab="settings">
                    <i class="fas fa-cog"></i> –ù–∞—Å—Ç—Ä–æ–π–∫–∏
                </button>
                <button class="tab-button" data-tab="modes">
                    <i class="fas fa-chess-board"></i> –†–µ–∂–∏–º—ã
                </button>
                <button class="tab-button" data-tab="achievements">
                    <i class="fas fa-trophy"></i> –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è
                </button>
                <button class="tab-button" data-tab="stats">
                    <i class="fas fa-chart-bar"></i> –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
                </button>
                <button class="tab-button" data-tab="archive">
                    <i class="fas fa-archive"></i> –ê—Ä—Ö–∏–≤
                </button>
            </div>

            <div class="tab-content active" id="settings-tab">
                <div class="settings-grid">
                    <!-- –ö–∞—Ä—Ç–æ—á–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
                </div>
            </div>

            <div class="tab-content" id="modes-tab">
                <div class="modes-grid">
                    <!-- –ö–∞—Ä—Ç–æ—á–∫–∏ —Ä–µ–∂–∏–º–æ–≤ –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
                </div>
            </div>

            <div class="tab-content" id="achievements-tab">
                 <div class="achievements-intro card">
                    ‚ú® –î–æ–∫–∞–∂–∏—Ç–µ —Å–≤–æ—ë –º–∞—Å—Ç–µ—Ä—Å—Ç–≤–æ, –æ—Ç–∫—Ä—ã–≤ –≤—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è! ‚ú®
                </div>
                <div class="achievements-grid">
                    <!-- –ö–∞—Ä—Ç–æ—á–∫–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
                </div>
            </div>
            
            <div class="tab-content" id="stats-tab">
                <div class="stats-grid">
                     <!-- –ö–∞—Ä—Ç–æ—á–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
                </div>
            </div>
            
            <!-- ‚ú® –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ù–æ–≤–∞—è –≤–∫–ª–∞–¥–∫–∞ –¥–ª—è –∞—Ä—Ö–∏–≤–∞ -->
            <div class="tab-content" id="archive-tab">
                <div class="archive-grid">
                    <!-- –ö–∞—Ä—Ç–æ—á–∫–∏ –∞—Ä—Ö–∏–≤–∞ –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
                </div>
            </div>
        </div>
    </main>

    <div class="modal-overlay" id="messageModal">
        <div class="modal-content">
            <h3 id="modalTitle"></h3>
            <p id="modalMessage"></p>
            <button class="btn" id="modalCloseBtn">–û–ö</button>
        </div>
    </div>

    <script>
        // DOM elements
        const gameField = document.getElementById('gameField');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const gameStatusDisplay = document.getElementById('gameStatusDisplay');
        const messageModal = document.getElementById('messageModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const hintMessage = document.getElementById('hintMessage');
        
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // Game variables
        let tiles = [];
        let emptyTileIndex = 0;
        let currentSize = 4;
        let highlightedTile = null;
        let autoHighlightInterval = null;
        let isAutoHighlighting = false;
        let currentTargetNumber = 1;
        let tileSize = 60;
        let tileGap = 8;
        let tileRadius = 10;
        let fontSize = 24;
        let currentScore = 0;
        let completedAchievements = [];
        let gameMode = 'classic';
        let timerInterval = null;
        let timeLeft = 0;
        let movesLeft = 0;
        let targetOrder = [];
        let obstacleTiles = new Set();
        let imageModeData = { imageUrl: '', image: null, canvas: null, ctx: null };
        let memoryRevealTimeout = null;
        let isTimeModeGameStarted = false;
        let teleportMoveCounter = 0;

        const achievementsData = [
             {
                id: 'legend',
                title: '–õ–µ–≥–µ–Ω–¥–∞ –ü—è—Ç–Ω–∞—à–µ–∫',
                description: '–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –≤ –∏–≥—Ä–µ. –í—ã - –Ω–∞—Å—Ç–æ—è—â–∏–π –º–∞—Å—Ç–µ—Ä!',
                icon: 'fa-crown',
                points: 1000,
                condition: (stats) => completedAchievements.length >= (achievementsData.length - 1),
                progress: (stats) => Math.min(completedAchievements.length / (achievementsData.length - 1), 1)
            },
            {
                id: 'first_move',
                title: '–ü–µ—Ä–≤—ã–π —à–∞–≥',
                description: '–°–¥–µ–ª–∞–π—Ç–µ –ø–µ—Ä–≤—ã–π —Ö–æ–¥ –≤ –∏–≥—Ä–µ.',
                icon: 'fa-hand-point-right',
                points: 10,
                condition: (stats) => stats.totalMoves > 0,
                progress: (stats) => stats.totalMoves > 0 ? 1 : 0
            },
            {
                id: 'first_win',
                title: '–ù–∞—á–∞–ª–æ –ø–æ–ª–æ–∂–µ–Ω–æ',
                description: '–ó–∞–≤–µ—Ä—à–∏—Ç–µ —Å–≤–æ—é –ø–µ—Ä–≤—É—é –∏–≥—Ä—É.',
                icon: 'fa-flag-checkered',
                points: 50,
                condition: (stats) => stats.totalGamesWon > 0,
                progress: (stats) => stats.totalGamesWon > 0 ? 1 : 0
            },
            {
                id: 'shuffler_10',
                title: '–ü–µ—Ä–µ–º–µ—à–∏–≤–∞—Ç–µ–ª—å',
                description: '–ü–µ—Ä–µ–º–µ—à–∞–π—Ç–µ –ø–ª–∏—Ç–∫–∏ 10 —Ä–∞–∑.',
                icon: 'fa-random',
                points: 25,
                condition: (stats) => stats.shuffles >= 10,
                progress: (stats) => Math.min(stats.shuffles / 10, 1)
            },
            {
                id: 'explorer_10',
                title: '–õ—é–±–æ–ø—ã—Ç–Ω—ã–π',
                description: '–ù–∞–π–¥–∏—Ç–µ 10 —á–∏—Å–µ–ª —Å –ø–æ–º–æ—â—å—é –ø–æ–∏—Å–∫–∞.',
                icon: 'fa-search',
                points: 30,
                condition: (stats) => stats.numbersFound >= 10,
                progress: (stats) => Math.min(stats.numbersFound / 10, 1)
            },
             {
                id: 'color_changer',
                title: '–•—É–¥–æ–∂–Ω–∏–∫',
                description: '–ò–∑–º–µ–Ω–∏—Ç–µ –≤—Å–µ 5 —Ç–∏–ø–æ–≤ —Ü–≤–µ—Ç–æ–≤ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.',
                icon: 'fa-paint-brush',
                points: 20,
                condition: (stats) => stats.colorsChanged.size >= 5,
                progress: (stats) => Math.min(stats.colorsChanged.size / 5, 1)
            },
            {
                id: 'size_master_small',
                title: '–ú–∏–Ω–∏–∞—Ç—é—Ä–∏—Å—Ç',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –Ω–∞ –ø–æ–ª–µ 2x2.',
                icon: 'fa-compress-arrows-alt',
                points: 50,
                condition: (stats) => stats.gamesWonBySize[2] > 0,
                progress: (stats) => stats.gamesWonBySize[2] > 0 ? 1 : 0
            },
             {
                id: 'size_master_big',
                title: '–ì—Ä–æ—Å—Å–º–µ–π—Å—Ç–µ—Ä',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –Ω–∞ –ø–æ–ª–µ 8x8.',
                icon: 'fa-expand-arrows-alt',
                points: 150,
                condition: (stats) => stats.gamesWonBySize[8] > 0,
                progress: (stats) => stats.gamesWonBySize[8] > 0 ? 1: 0
            },
            {
                id: 'size_master_titanic',
                title: '–¢–∏—Ç–∞–Ω–∏—á–µ—Å–∫–∏–π –¢—Ä—É–¥',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –Ω–∞ –ø–æ–ª–µ 20x20.',
                icon: 'fa-globe-americas',
                points: 500,
                condition: (stats) => stats.gamesWonBySize[20] > 0,
                progress: (stats) => stats.gamesWonBySize[20] > 0 ? 1 : 0
            },
            {
                id: 'size_master_all',
                title: '–ú–∞—Å—Ç–µ—Ä –†–∞–∑–º–µ—Ä–æ–≤',
                description: '–°—ã–≥—Ä–∞–π—Ç–µ –Ω–∞ 5 —Ä–∞–∑–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–∞—Ö –ø–æ–ª—è.',
                icon: 'fa-ruler-combined',
                points: 100,
                condition: (stats) => stats.playedSizes.size >= 5,
                progress: (stats) => Math.min(stats.playedSizes.size / 5, 1)
            },
            {
                id: 'mode_explorer',
                title: '–†–µ–∂–∏–º–Ω—ã–π –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å',
                description: '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ 5 —Ä–∞–∑–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤ –∏–≥—Ä—ã.',
                icon: 'fa-route',
                points: 100,
                condition: (stats) => stats.modesTried.size >= 5,
                progress: (stats) => Math.min(stats.modesTried.size / 5, 1)
            },
            {
                id: 'mode_master',
                title: '–ü–æ–≤–µ–ª–∏—Ç–µ–ª—å –†–µ–∂–∏–º–æ–≤',
                description: '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–µ–∂–∏–º—ã –∏–≥—Ä—ã.',
                icon: 'fa-dungeon',
                points: 250,
                condition: (stats) => stats.modesTried.size >= gameModes.length, 
                progress: (stats) => Math.min(stats.modesTried.size / gameModes.length, 1)
            },
            {
                id: 'win_classic',
                title: '–ö–ª–∞—Å—Å–∏–∫',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π".',
                icon: 'fa-th',
                points: 20,
                condition: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[currentSize] && stats.gameRecords.classic[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[currentSize] && stats.gameRecords.classic[currentSize].gamesPlayed > 0 ? 1 : 0
            },
            {
                id: 'win_time',
                title: '–°–ø—Ä–∏–Ω—Ç–µ—Ä',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–ù–∞ –≤—Ä–µ–º—è".',
                icon: 'fa-stopwatch',
                points: 30,
                condition: (stats) => stats.gameRecords.time && stats.gameRecords.time[currentSize] && stats.gameRecords.time[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.time && stats.gameRecords.time[currentSize] && stats.gameRecords.time[currentSize].gamesPlayed > 0 ? 1 : 0
            },
            {
                id: 'win_moves',
                title: '–¢–∞–∫—Ç–∏–∫',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Ö–æ–¥–æ–≤".',
                icon: 'fa-shoe-prints',
                points: 30,
                condition: (stats) => stats.gameRecords.moves && stats.gameRecords.moves[currentSize] && stats.gameRecords.moves[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.moves && stats.gameRecords.moves[currentSize] && stats.gameRecords.moves[currentSize].gamesPlayed > 0 ? 1 : 0
            },
            {
                id: 'win_reverse',
                title: '–†–µ–≤–µ—Ä—Å–µ—Ä',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–û–±—Ä–∞—Ç–Ω—ã–π".',
                icon: 'fa-exchange-alt',
                points: 40,
                condition: (stats) => stats.gameRecords.reverse && stats.gameRecords.reverse[currentSize] && stats.gameRecords.reverse[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.reverse && stats.gameRecords.reverse[currentSize] && stats.gameRecords.reverse[currentSize].gamesPlayed > 0 ? 1 : 0
            },
            {
                id: 'collector_10',
                title: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 10 –∏–≥—Ä.',
                icon: 'fa-medal',
                points: 100,
                condition: (stats) => stats.totalGamesWon >= 10,
                progress: (stats) => Math.min(stats.totalGamesWon / 10, 1)
            },
            {
                id: 'collector_50',
                title: '–≠–Ω—Ç—É–∑–∏–∞—Å—Ç',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 50 –∏–≥—Ä.',
                icon: 'fa-award',
                points: 250,
                condition: (stats) => stats.totalGamesWon >= 50,
                progress: (stats) => Math.min(stats.totalGamesWon / 50, 1)
            },
            {
                id: 'mover_1k',
                title: '–ù–µ–ø–æ—Å–µ–¥–∞',
                description: '–°–¥–µ–ª–∞–π—Ç–µ 1000 —Ö–æ–¥–æ–≤.',
                icon: 'fa-walking',
                points: 50,
                condition: (stats) => stats.totalMoves >= 1000,
                progress: (stats) => Math.min(stats.totalMoves / 1000, 1)
            },
            {
                id: 'mover_10k',
                title: '–ú–∞—Ä–∞—Ñ–æ–Ω–µ—Ü',
                description: '–°–¥–µ–ª–∞–π—Ç–µ 10 000 —Ö–æ–¥–æ–≤.',
                icon: 'fa-running',
                points: 150,
                condition: (stats) => stats.totalMoves >= 10000,
                progress: (stats) => Math.min(stats.totalMoves / 10000, 1)
            },
            {
                id: 'score_1k',
                title: '–ù–∞–∫–æ–ø–∏—Ç–µ–ª—å',
                description: '–ù–∞–±–µ—Ä–∏—Ç–µ 1000 –æ—á–∫–æ–≤ (–±–µ–∑ —É—á–µ—Ç–∞ –æ—á–∫–æ–≤ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è).',
                icon: 'fa-coins',
                points: 50,
                condition: (stats) => stats.totalScore >= 1000,
                progress: (stats) => Math.min(stats.totalScore / 1000, 1)
            },
            {
                id: 'score_10k',
                title: '–ë–æ–≥–∞—á',
                description: '–ù–∞–±–µ—Ä–∏—Ç–µ 10 000 –æ—á–∫–æ–≤ (–±–µ–∑ —É—á–µ—Ç–∞ –æ—á–∫–æ–≤ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è).',
                icon: 'fa-gem',
                points: 150,
                condition: (stats) => stats.totalScore >= 10000,
                progress: (stats) => Math.min(stats.totalScore / 10000, 1)
            },
            {
                id: 'fast_solver_100',
                title: '–ë—ã—Å—Ç—Ä—ã–π —Ä–µ—à–∞—Ç–µ–ª—å',
                description: '–†–µ—à–∏—Ç–µ –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É 4x4 –º–µ–Ω–µ–µ —á–µ–º –∑–∞ 100 —Ö–æ–¥–æ–≤.',
                icon: 'fa-bolt',
                points: 75,
                condition: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[4] && stats.gameRecords.classic[4].bestMoves < 100,
                progress: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[4] ? Math.max(0, 1 - (stats.gameRecords.classic[4].bestMoves - 50) / 50) : 0
            },
            {
                id: 'shuffler_50',
                title: '–•–∞–æ—Å-–º–µ–Ω–µ–¥–∂–µ—Ä',
                description: '–ü–µ—Ä–µ–º–µ—à–∞–π—Ç–µ –ø–ª–∏—Ç–∫–∏ 50 —Ä–∞–∑.',
                icon: 'fa-sync-alt',
                points: 50,
                condition: (stats) => stats.shuffles >= 50,
                progress: (stats) => Math.min(stats.shuffles / 50, 1)
            },
            {
                id: 'explorer_50',
                title: '–î–µ—Ç–µ–∫—Ç–∏–≤',
                description: '–ù–∞–π–¥–∏—Ç–µ 50 —á–∏—Å–µ–ª —Å –ø–æ–º–æ—â—å—é –ø–æ–∏—Å–∫–∞.',
                icon: 'fa-search-plus',
                points: 60,
                condition: (stats) => stats.numbersFound >= 50,
                progress: (stats) => Math.min(stats.numbersFound / 50, 1)
            },
            {
                id: 'autohighlight_user',
                title: '–ê–≤—Ç–æ–ø–∏–ª–æ—Ç',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É, –∏—Å–ø–æ–ª—å–∑—É—è –∞–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫—É.',
                icon: 'fa-robot',
                points: 30,
                condition: (stats) => stats.winsWithAutohighlight > 0,
                progress: (stats) => stats.winsWithAutohighlight > 0 ? 1 : 0
            },
            {
                id: 'styler',
                title: '–°—Ç–∏–ª–∏—Å—Ç',
                description: '–ò–∑–º–µ–Ω–∏—Ç–µ —Ä–∞–∑–º–µ—Ä –ø–ª–∏—Ç–æ–∫, –∏—Ö –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∏ —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞.',
                icon: 'fa-magic',
                points: 25,
                condition: (stats) => stats.styleChanges.size >= 3,
                progress: (stats) => Math.min(stats.styleChanges.size / 3, 1)
            },
            {
                id: 'win_obstacle',
                title: '–ü—Ä–µ–æ–¥–æ–ª–µ–Ω–∏–µ',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏".',
                icon: 'fa-ban',
                points: 50,
                condition: (stats) => stats.gameRecords.obstacle && stats.gameRecords.obstacle[currentSize] && stats.gameRecords.obstacle[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.obstacle && stats.gameRecords.obstacle[currentSize] && stats.gameRecords.obstacle[currentSize].gamesPlayed > 0 ? 1 : 0
            },
            {
                id: 'win_memory',
                title: '–§–µ–Ω–æ–º–µ–Ω–∞–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –ø–∞–º—è—Ç—å—é".',
                icon: 'fa-brain',
                points: 60,
                condition: (stats) => stats.gameRecords.memory && stats.gameRecords.memory[currentSize] && stats.gameRecords.memory[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.memory && stats.gameRecords.memory[currentSize] && stats.gameRecords.memory[currentSize].gamesPlayed > 0 ? 1 : 0
            },
            {
                id: 'win_image',
                title: '–•—É–¥–æ–∂–Ω–∏–∫-–≥–æ–ª–æ–≤–æ–ª–æ–º—â–∏–∫',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –∫–∞—Ä—Ç–∏–Ω–∫–æ–π".',
                icon: 'fa-image',
                points: 80,
                condition: (stats) => stats.gameRecords.image && stats.gameRecords.image[currentSize] && stats.gameRecords.image[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.image && stats.gameRecords.image[currentSize] && stats.gameRecords.image[currentSize].gamesPlayed > 0 ? 1 : 0
            },
            {
                id: 'win_teleport',
                title: '–ú–∞—Å—Ç–µ—Ä —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–¢–µ–ª–µ–ø–æ—Ä—Ç".',
                icon: 'fa-random',
                points: 75,
                condition: (stats) => stats.gameRecords.teleport && stats.gameRecords.teleport[currentSize] && stats.gameRecords.teleport[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.teleport && stats.gameRecords.teleport[currentSize] && stats.gameRecords.teleport[currentSize].gamesPlayed > 0 ? 1 : 0
            },
            {
                id: 'win_vortex',
                title: '–ú–∞—Å—Ç–µ—Ä –≤–∏—Ö—Ä—è',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–í–∏—Ö—Ä—å".',
                icon: 'fa-wind',
                points: 80,
                condition: (stats) => stats.gameRecords.vortex && stats.gameRecords.vortex[currentSize] && stats.gameRecords.vortex[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.vortex && stats.gameRecords.vortex[currentSize] && stats.gameRecords.vortex[currentSize].gamesPlayed > 0 ? 1 : 0
            },
            {
                id: 'win_hidden_path',
                title: '–ü—Ä–æ–≤–æ–¥–Ω–∏–∫',
                description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–°–∫—Ä—ã—Ç—ã–π –ø—É—Ç—å".',
                icon: 'fa-eye-slash',
                points: 85,
                condition: (stats) => stats.gameRecords.hidden_path && stats.gameRecords.hidden_path[currentSize] && stats.gameRecords.hidden_path[currentSize].gamesPlayed > 0,
                progress: (stats) => stats.gameRecords.hidden_path && stats.gameRecords.hidden_path[currentSize] && stats.gameRecords.hidden_path[currentSize].gamesPlayed > 0 ? 1 : 0
            }
        ];

        const gameModes = [
            { id: 'classic', title: '–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π', description: '–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø—è—Ç–Ω–∞—à–∫–∏', icon: 'fa-th', active: true,
              getLimits: (size) => ({ moves: Infinity, time: Infinity })
            },
            { id: 'time', title: '–ù–∞ –≤—Ä–µ–º—è', description: '–°–æ–±–µ—Ä–∏—Ç–µ –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É –∫–∞–∫ –º–æ–∂–Ω–æ –±—ã—Å—Ç—Ä–µ–µ', icon: 'fa-stopwatch', active: false,
              getLimits: (size) => ({ moves: Infinity, time: size * size * 5 })
            },
            { id: 'moves', title: '–° –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Ö–æ–¥–æ–≤', description: '–°–æ–±–µ—Ä–∏—Ç–µ –∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ö–æ–¥–æ–≤', icon: 'fa-shoe-prints', active: false,
              getLimits: (size) => ({ moves: size * size * 15, time: Infinity })
            },
            { id: 'reverse', title: '–û–±—Ä–∞—Ç–Ω—ã–π', description: '–ù–∞—á–Ω–∏—Ç–µ —Å —Å–æ–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ —Å–æ–±–µ—Ä–∏—Ç–µ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ', icon: 'fa-exchange-alt', active: false,
              getLimits: (size) => ({ moves: Infinity, time: Infinity })
            },
            { id: 'image', title: '–° –∫–∞—Ä—Ç–∏–Ω–∫–æ–π', description: '–í–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä - —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è', icon: 'fa-image', active: false,
              getLimits: (size) => ({ moves: Infinity, time: Infinity })
            },
            { id: 'obstacle', title: '–° –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏', description: '–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–ª–∏—Ç–∫–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ —Å–≤–æ–∏—Ö –º–µ—Å—Ç–∞—Ö', icon: 'fa-ban', active: false,
              getLimits: (size) => ({ moves: Infinity, time: Infinity }),
              getObstacleCount: (size) => Math.max(1, Math.floor(size * size * 0.05))
            },
            { id: 'teleport', title: '–¢–µ–ª–µ–ø–æ—Ä—Ç', description: '–ü—É—Å—Ç–∞—è —è—á–µ–π–∫–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ö–æ–¥–æ–≤', icon: 'fa-bolt', active: false,
              getLimits: (size) => ({ moves: Infinity, time: Infinity }),
              teleportFrequency: (size) => Math.max(3, Math.floor(size * 1.5))
            },
            { id: 'vortex', title: '–í–∏—Ö—Ä—å', description: '–ü—É—Å—Ç–∞—è –ø–ª–∏—Ç–∫–∞ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ö–æ–¥–∞', icon: 'fa-wind', active: false,
              getLimits: (size) => ({ moves: Infinity, time: Infinity })
            },
            { id: 'hidden_path', title: '–°–∫—Ä—ã—Ç—ã–π –ø—É—Ç—å', description: '–í–∏–¥–Ω—ã —Ç–æ–ª—å–∫–æ –ø–ª–∏—Ç–∫–∏ –≤–æ–∫—Ä—É–≥ –ø—É—Å—Ç–æ–π —è—á–µ–π–∫–∏', icon: 'fa-eye-slash', active: false,
              getLimits: (size) => ({ moves: Infinity, time: Infinity })
            }
        ];

        // ‚ú® –ò–ó–ú–ï–ù–ï–ù–ò–ï: –î–∞–Ω–Ω—ã–µ –¥–ª—è –≤–∫–ª–∞–¥–∫–∏ "–ê—Ä—Ö–∏–≤"
        const archiveVersions = [
            { date: "22 –∏—é–ª—è 2025", label: "(–¢–µ–∫—É—â–∞—è –≤–µ—Ä—Å–∏—è)", url: null },
            { date: "21 –∏—é–ª—è 2025", label: "", url: "archive/12.html" },
            { date: "20 –º–∞—è 2025", label: "", url: "archive/11.html" },
            { date: "28 –∞–ø—Ä–µ–ª—è 2025", label: "", url: "archive/10.html" },
            { date: "11 –∞–ø—Ä–µ–ª—è 2025", label: "", url: "archive/9.html" },
            { date: "21 –º–∞—Ä—Ç–∞ 2025", label: "", url: "archive/8.html" },
            { date: "19 –º–∞—Ä—Ç–∞ 2025", label: "", url: "archive/7.html" },
            { date: "29 –Ω–æ—è–±—Ä—è 2024", label: "", url: "archive/6.html" },
            { date: "27 –Ω–æ—è–±—Ä—è 2024", label: "", url: "archive/5.html" },
            { date: "25 –Ω–æ—è–±—Ä—è 2024", label: "(–°–æ–∑–¥–∞–Ω–∏–µ)", url: "archive/4.html" }
        ];

        let gameStats = {};
        
        // ‚ú® –ò–ó–ú–ï–ù–ï–ù–ò–ï: –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –∫–∞—Ä—Ç–æ—á–µ–∫
        function animateCards(tabId) {
            const activeTab = document.getElementById(tabId);
            if (!activeTab) return;

            const cards = activeTab.querySelectorAll('.card');
            cards.forEach((card, index) => {
                setTimeout(() => {
                    card.classList.add('visible');
                }, index * 80); // –ó–∞–¥–µ—Ä–∂–∫–∞ 80–º—Å –º–µ–∂–¥—É –∫–∞—Ä—Ç–æ—á–∫–∞–º–∏
            });
        }

        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ–º
                    content.querySelectorAll('.card').forEach(card => card.classList.remove('visible'));
                });
                
                const newActiveTab = document.getElementById(`${tabId}-tab`);
                newActiveTab.classList.add('active');
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –¥–ª—è –Ω–æ–≤–æ–π –∞–∫—Ç–∏–≤–Ω–æ–π –≤–∫–ª–∞–¥–∫–∏
                animateCards(`${tabId}-tab`);
            });
        });

        function initializeStats() {
             gameStats = {
                currentMoves: 0, totalMoves: 0, totalScore: 0, achievementScore: 0, totalGamesWon: 0, shuffles: 0,
                numbersFound: 0, winsWithAutohighlight: 0, playedSizes: new Set(), colorsChanged: new Set(),
                styleChanges: new Set(), modesTried: new Set(['classic']), gamesWonBySize: {}, gameRecords: {} 
            };
            
            const maxSliderSize = 20; // –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–æ 20
            gameModes.forEach(mode => {
                gameStats.gameRecords[mode.id] = {};
                for (let s = 2; s <= maxSliderSize; s++) {
                    gameStats.gameRecords[mode.id][s] = {
                        gamesPlayed: 0, bestTime: Infinity, worstTime: 0, bestMoves: Infinity, worstMoves: 0
                    };
                }
            });
        }

        // ‚ú® –ò–ó–ú–ï–ù–ï–ù–ò–ï: –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –≤–∫–ª–∞–¥–æ–∫
        function renderAllTabs() {
            renderSettingsTab();
            renderModesTab();
            renderAchievementsTab();
            renderStatsTab();
            renderArchiveTab();
        }

        function renderSettingsTab() {
            const grid = document.querySelector('#settings-tab .settings-grid');
            grid.innerHTML = `
                <div class="settings-card card">
                    <h3><i class="fas fa-sliders-h"></i> –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
                    <div class="control-row">
                        <span class="control-label">–†–∞–∑–º–µ—Ä –ø–æ–ª—è:</span>
                        <input type="range" id="sizeSlider" min="2" max="20" value="4" step="1">
                        <span class="range-value" id="sizeValue">4</span>
                    </div>
                    <button class="btn" id="applySize"><i class="fas fa-check"></i> –ü—Ä–∏–º–µ–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä</button>
                    <button class="btn" id="shuffleBtn"><i class="fas fa-random"></i> –ü–µ—Ä–µ–º–µ—à–∞—Ç—å</button>
                </div>
                <div class="settings-card card">
                    <h3><i class="fas fa-palette"></i> –í–Ω–µ—à–Ω–∏–π –≤–∏–¥</h3>
                    <div class="control-row">
                        <span class="control-label">–¶–≤–µ—Ç –ø–ª–∏—Ç–æ–∫:</span>
                        <input type="color" id="tileColor" value="#ffeaa7">
                    </div>
                    <div class="control-row">
                        <span class="control-label">–†–∞–∑–º–µ—Ä –ø–ª–∏—Ç–æ–∫:</span>
                        <input type="range" id="tileSizeSlider" min="30" max="100" value="60" step="1">
                        <span class="range-value" id="tileSizeValue">60px</span>
                    </div>
                    <div class="control-row">
                        <span class="control-label">–ó–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ:</span>
                        <input type="range" id="tileRadiusSlider" min="0" max="50" value="10" step="1">
                        <span class="range-value" id="tileRadiusValue">10px</span>
                    </div>
                    <div class="control-row">
                        <span class="control-label">–†–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞:</span>
                        <input type="range" id="fontSizeSlider" min="12" max="48" value="24" step="1">
                        <span class="range-value" id="fontSizeValue">24px</span>
                    </div>
                </div>
                <div class="settings-card card">
                    <h3><i class="fas fa-fill-drip"></i> –¶–≤–µ—Ç–∞</h3>
                    <div class="control-row">
                        <span class="control-label">–¶–≤–µ—Ç —Ñ–æ–Ω–∞:</span>
                        <input type="color" id="bgColor" value="#f5f6fa">
                    </div>
                    <div class="control-row">
                        <span class="control-label">–¶–≤–µ—Ç —Ä–∞–º–∫–∏:</span>
                        <input type="color" id="borderColor" value="#6c5ce7">
                    </div>
                    <div class="control-row">
                        <span class="control-label">–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞:</span>
                        <input type="color" id="textColor" value="#2d3436">
                    </div>
                    <div class="control-row">
                        <span class="control-label">–¶–≤–µ—Ç –ø–æ–¥—Å–≤–µ—Ç–∫–∏:</span>
                        <input type="color" id="highlightColor" value="#74b9ff">
                    </div>
                    <div class="control-row">
                        <span class="control-label">–¶–≤–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö:</span>
                        <input type="color" id="correctColor" value="#55efc4">
                    </div>
                </div>
                <div class="settings-card card">
                    <h3><i class="fas fa-search"></i> –ü–æ–∏—Å–∫ –∏ –ø–æ–¥—Å–≤–µ—Ç–∫–∞</h3>
                    <div class="input-group">
                        <input type="number" id="numberInput" min="1" placeholder="–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ" class="form-input">
                    </div>
                    <button class="btn" id="findNumberBtn"><i class="fas fa-search"></i> –ù–∞–π—Ç–∏ —á–∏—Å–ª–æ</button>
                    <button class="btn" id="autoHighlightBtn"><i class="fas fa-magic"></i> –ê–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫–∞</button>
                </div>
            `;
            initSliders();
            initSettingsListeners();
        }

        function renderModesTab() {
            const grid = document.querySelector('#modes-tab .modes-grid');
            grid.innerHTML = '';
            gameModes.forEach(mode => {
                const card = document.createElement('div');
                card.className = `mode-card card ${mode.active ? 'active' : ''}`;
                card.dataset.mode = mode.id;
                
                card.innerHTML = `
                    <div class="mode-icon"><i class="fas ${mode.icon}"></i></div>
                    <div class="mode-title">${mode.title}</div>
                    <div class="mode-desc">${mode.description}</div>
                `;

                if (mode.id === 'image') {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'input-group';
                    inputGroup.style.marginTop = '10px';
                    
                    const imageInput = document.createElement('input');
                    imageInput.type = 'file';
                    imageInput.accept = 'image/*';
                    imageInput.id = 'image-upload-input';
                    imageInput.addEventListener('change', (e) => loadImageForMode(e.target.files[0]));

                    const imageLabel = document.createElement('label');
                    imageLabel.htmlFor = 'image-upload-input';
                    imageLabel.className = 'btn btn-block';
                    imageLabel.innerHTML = '<i class="fas fa-upload"></i> –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª';
                    
                    inputGroup.appendChild(imageInput);
                    inputGroup.appendChild(imageLabel);
                    card.appendChild(inputGroup);
                }
                
                card.addEventListener('click', (e) => {
                    if (e.target.closest('label[for="image-upload-input"]')) return;
                    setActiveMode(mode.id);
                });
                grid.appendChild(card);
            });
        }

        function renderAchievementsTab() {
            const grid = document.querySelector('#achievements-tab .achievements-grid');
            grid.innerHTML = '';
            achievementsData.forEach(achievement => {
                const isCompleted = completedAchievements.includes(achievement.id);
                const progress = achievement.progress(gameStats);
                
                const card = document.createElement('div');
                card.className = `achievement-card card ${isCompleted ? '' : 'locked'}`;
                
                card.innerHTML = `
                    <div class="achievement-icon"><i class="fas ${achievement.icon}"></i></div>
                    <div class="achievement-title">${achievement.title}</div>
                    <div class="achievement-desc">${achievement.description}</div>
                    <div class="achievement-progress"><div class="progress-bar" style="width: ${progress * 100}%"></div></div>
                    <div class="achievement-points">+${achievement.points} –æ—á–∫–æ–≤</div>
                    ${isCompleted ? '<div class="ribbon">–ü–æ–ª—É—á–µ–Ω–æ!</div>' : ''}
                `;
                grid.appendChild(card);
            });
        }

        function renderStatsTab() {
            const grid = document.querySelector('#stats-tab .stats-grid');
            grid.innerHTML = `
                <div class="stats-card card">
                    <i class="fas fa-gamepad stats-icon"></i>
                    <div class="stats-value">${gameStats.totalGamesWon}</div>
                    <div class="stats-label">–°–æ–±—Ä–∞–Ω–æ –∏–≥—Ä</div>
                </div>
                <div class="stats-card card">
                    <i class="fas fa-arrows-alt-h stats-icon"></i>
                    <div class="stats-value">${gameStats.totalMoves}</div>
                    <div class="stats-label">–ü–µ—Ä–µ–¥–≤–∏–Ω—É—Ç–æ –ø–ª–∏—Ç–æ–∫</div>
                </div>
                <div class="stats-card card">
                    <i class="fas fa-coins stats-icon"></i>
                    <div class="stats-value">${gameStats.totalScore}</div>
                    <div class="stats-label">–û—á–∫–æ–≤ –ø–æ–ª—É—á–µ–Ω–æ</div>
                </div>
                 <div class="stats-card card">
                    <i class="fas fa-trophy stats-icon"></i>
                    <div class="stats-value">${gameStats.achievementScore}</div>
                    <div class="stats-label">–û—á–∫–∏ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è</div>
                </div>
                <div class="stats-list-card card">
                    <h3>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ä–µ–∂–∏–º–∞–º –∏ —Ä–∞–∑–º–µ—Ä–∞–º:</h3>
                    <ul class="stats-list" id="statsModeSizeList"></ul>
                </div>
            `;
            
            const modeSizeList = document.getElementById('statsModeSizeList');
            modeSizeList.innerHTML = '';
            gameModes.forEach(mode => {
                const modeLi = document.createElement('li');
                modeLi.innerHTML = `<span class="stats-list-label">${mode.title}</span><span class="stats-list-value"></span>`;
                modeSizeList.appendChild(modeLi);

                const subList = document.createElement('ul');
                subList.className = 'stats-sub-list';
                modeLi.appendChild(subList);

                const sortedSizes = Object.keys(gameStats.gameRecords[mode.id]).sort((a,b) => parseInt(a) - parseInt(b));
                
                let modeHasData = false;
                sortedSizes.forEach(size => {
                    const record = gameStats.gameRecords[mode.id][size];
                    if (record.gamesPlayed > 0) {
                        modeHasData = true;
                        const sizeLi = document.createElement('li');
                        let statsHtml = `<span>–ü–æ–ª–µ ${size}x${size}:</span><span>–ò–≥—Ä: ${record.gamesPlayed}`;
                        if (record.bestMoves !== Infinity) statsHtml += `, –•–æ–¥—ã: ${record.bestMoves}`;
                        if (record.bestTime !== Infinity) {
                            const bestMin = Math.floor(record.bestTime / 60);
                            const bestSec = record.bestTime % 60;
                            statsHtml += `, –í—Ä–µ–º—è: ${bestMin.toString().padStart(2, '0')}:${bestSec.toString().padStart(2, '0')}`;
                        }
                        statsHtml += `</span>`;
                        sizeLi.innerHTML = statsHtml;
                        subList.appendChild(sizeLi);
                    }
                });

                if (!modeHasData) {
                    const noDataLi = document.createElement('li');
                    noDataLi.textContent = '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç—Ç–æ–≥–æ —Ä–µ–∂–∏–º–∞.';
                    subList.appendChild(noDataLi);
                }
            });
        }

        function renderArchiveTab() {
            const grid = document.querySelector('#archive-tab .archive-grid');
            grid.innerHTML = '';
            archiveVersions.forEach(version => {
                let card;
                if (version.url) {
                    card = document.createElement('a');
                    card.href = version.url;
                } else {
                    card = document.createElement('div');
                    card.classList.add('current-version');
                }
                card.className += ' archive-card card';
                card.innerHTML = `
                    <div class="version-date">${version.date}</div>
                    <div class="version-label">${version.label}</div>
                `;
                grid.appendChild(card);
            });
        }

        function initSliders() {
            const sizeSlider = document.getElementById('sizeSlider');
            const sizeValue = document.getElementById('sizeValue');
            const tileSizeSlider = document.getElementById('tileSizeSlider');
            const tileSizeValue = document.getElementById('tileSizeValue');
            const tileRadiusSlider = document.getElementById('tileRadiusSlider');
            const tileRadiusValue = document.getElementById('tileRadiusValue');
            const fontSizeSlider = document.getElementById('fontSizeSlider');
            const fontSizeValue = document.getElementById('fontSizeValue');

            sizeValue.textContent = sizeSlider.value;
            tileSizeValue.textContent = tileSizeSlider.value + 'px';
            tileRadiusValue.textContent = tileRadiusSlider.value + 'px';
            fontSizeValue.textContent = fontSizeSlider.value + 'px';
            
            sizeSlider.addEventListener('input', () => sizeValue.textContent = sizeSlider.value);
            tileSizeSlider.addEventListener('input', () => {
                tileSize = parseInt(tileSizeSlider.value);
                tileSizeValue.textContent = tileSize + 'px';
                applyVisualUpdates();
                gameStats.styleChanges.add('tileSize');
                saveStats();
                checkAchievements();
            });
            tileRadiusSlider.addEventListener('input', () => {
                tileRadius = parseInt(tileRadiusSlider.value);
                tileRadiusValue.textContent = tileRadius + 'px';
                applyVisualUpdates();
                gameStats.styleChanges.add('tileRadius');
                saveStats();
                checkAchievements();
            });
            fontSizeSlider.addEventListener('input', () => {
                fontSize = parseInt(fontSizeSlider.value);
                fontSizeValue.textContent = fontSize + 'px';
                applyVisualUpdates();
                gameStats.styleChanges.add('fontSize');
                saveStats();
                checkAchievements();
            });
        }

        function initSettingsListeners() {
            const tileColorPicker = document.getElementById('tileColor');
            const numberInput = document.getElementById('numberInput');
            const findNumberBtn = document.getElementById('findNumberBtn');
            const sizeSlider = document.getElementById('sizeSlider');
            const applySizeBtn = document.getElementById('applySize');
            const shuffleBtn = document.getElementById('shuffleBtn');
            const autoHighlightBtn = document.getElementById('autoHighlightBtn');
            const bgColorPicker = document.getElementById('bgColor');
            const borderColorPicker = document.getElementById('borderColor');
            const textColorPicker = document.getElementById('textColor');
            const highlightColorPicker = document.getElementById('highlightColor');
            const correctColorPicker = document.getElementById('correctColor');

            tileColorPicker.addEventListener('change', () => updateColors('tile'));
            bgColorPicker.addEventListener('change', () => updateColors('bg'));
            borderColorPicker.addEventListener('change', () => updateColors('border'));
            textColorPicker.addEventListener('change', () => updateColors('text'));
            highlightColorPicker.addEventListener('change', () => {
                if (highlightedTile) {
                    highlightedTile.style.backgroundColor = highlightColorPicker.value;
                    highlightedTile.style.color = getContrastColor(highlightColorPicker.value);
                }
                updateColors('highlight');
            });
            correctColorPicker.addEventListener('change', () => {
                highlightCorrectTiles(currentSize);
                updateColors('correct');
            });
            findNumberBtn.addEventListener('click', () => {
                const number = parseInt(numberInput.value);
                if (!isNaN(number)) highlightNumber(number);
            });
            numberInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') findNumberBtn.click();
            });
            applySizeBtn.addEventListener('click', () => {
                const size = parseInt(sizeSlider.value);
                if (size >= 2 && size <= 20) {
                    currentSize = size;
                    createGame(size);
                    shuffleTiles();
                }
            });
            shuffleBtn.addEventListener('click', shuffleTiles);
            autoHighlightBtn.addEventListener('click', toggleAutoHighlight);
        }
        
        function applyVisualUpdates() {
            gameField.style.width = `${currentSize * (tileSize + tileGap)}px`;
            gameField.style.height = `${currentSize * (tileSize + tileGap)}px`;
            
            tiles.forEach(tile => {
                tile.style.width = tileSize + 'px';
                tile.style.height = tileSize + 'px';
                tile.style.borderRadius = tileRadius + 'px';
                tile.style.fontSize = fontSize + 'px';
            });
            
            renderTiles(currentSize, false);
        }

        function startTimer() {
            const currentMode = gameModes.find(mode => mode.id === gameMode);
            const limits = currentMode.getLimits(currentSize);
            timeLeft = limits.time; 
            updateScore(); 

            timerInterval = setInterval(() => {
                timeLeft--; 
                updateScore();
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endGame(false, '–í—Ä–µ–º—è –≤—ã—à–ª–æ!'); 
                }
            }, 1000);
        }

        function stopGameMechanisms() {
            clearInterval(timerInterval);
            timerInterval = null;
            stopAutoHighlight(); 
            clearTimeout(memoryRevealTimeout); 
            document.querySelectorAll('.tile.hidden-number.revealed').forEach(tile => tile.classList.remove('revealed'));
            document.querySelectorAll('.tile.hidden-path-hidden').forEach(tile => tile.classList.remove('hidden-path-hidden'));
        }

        function createGame(size) {
            stopGameMechanisms(); 

            gameField.innerHTML = '';
            tiles = [];
            emptyTileIndex = size * size - 1;
            currentSize = size;
            currentScore = 0;
            gameStats.currentMoves = 0;
            isTimeModeGameStarted = false;

            timeLeft = 0;
            movesLeft = 0;
            obstacleTiles.clear();
            teleportMoveCounter = 0;
            
            const currentMode = gameModes.find(mode => mode.id === gameMode);
            const limits = currentMode.getLimits(currentSize);

            if (gameMode === 'moves') movesLeft = limits.moves;
            else if (gameMode === 'time') {
                timeLeft = limits.time;
                hintMessage.classList.add('active');
            } else {
                hintMessage.classList.remove('active');
            }
            
            targetOrder = (gameMode === 'reverse') 
                ? Array.from({length: size * size - 1}, (_, i) => size * size - 1 - i)
                : Array.from({length: size * size - 1}, (_, i) => i + 1);

            gameStats.playedSizes.add(size);
            saveStats();
            checkAchievements();
            
            gameField.style.width = `${size * (tileSize + tileGap)}px`;
            gameField.style.height = `${size * (tileSize + tileGap)}px`;
            gameField.style.gap = tileGap + 'px';

            for (let i = 1; i <= size * size - 1; i++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.id = `tile-${i}`;
                
                const tileInner = document.createElement('div');
                tileInner.className = 'tile-inner';
                tileInner.textContent = i;
                tile.appendChild(tileInner);
                
                tile.style.width = tileSize + 'px';
                tile.style.height = tileSize + 'px';
                tile.style.borderRadius = tileRadius + 'px';
                tile.style.fontSize = fontSize + 'px';
                tile.style.color = document.getElementById('textColor')?.value || '#2d3436';
                tile.style.opacity = 0;
                tiles.push(tile);
                gameField.appendChild(tile);
            }

            const emptyTile = document.createElement('div');
            emptyTile.className = 'empty-tile';
            emptyTile.id = 'empty-tile';
            tiles.push(emptyTile);
            gameField.appendChild(emptyTile);

            updateScore();
        }

        function updateScore() {
            scoreDisplay.innerHTML = `<i class="fas fa-star"></i> <span>–û—á–∫–∏: ${currentScore}</span>`;
            let statusText = '';
            if (gameMode === 'time') {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                statusText = `<i class="fas fa-clock"></i> <span>–í—Ä–µ–º—è: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}</span>`;
            } else if (gameMode === 'moves') {
                statusText = `<i class="fas fa-shoe-prints"></i> <span>–•–æ–¥—ã: ${movesLeft}</span>`;
            } else { 
                statusText = `<i class="fas fa-shoe-prints"></i> <span>–•–æ–¥—ã: ${gameStats.currentMoves}</span>`;
            }
            gameStatusDisplay.innerHTML = statusText;
        }

        function addScore(points) {
            currentScore += points;
            updateScore();
        }

        function highlightNumber(number) {
            const highlightColorPicker = document.getElementById('highlightColor');
            const tileColorPicker = document.getElementById('tileColor');
            const textColorPicker = document.getElementById('textColor');

            if (highlightedTile) {
                highlightedTile.classList.remove('highlight');
                highlightedTile.style.backgroundColor = tileColorPicker.value;
                highlightedTile.style.color = textColorPicker.value;
            }
            
            if (!number || number < 1 || number > currentSize * currentSize - 1) return;
            
            highlightedTile = tiles.find(tile => !tile.classList.contains('empty-tile') && tile.querySelector('.tile-inner')?.textContent == number);
            
            if (highlightedTile) {
                highlightedTile.classList.add('highlight');
                highlightedTile.style.backgroundColor = highlightColorPicker.value;
                highlightedTile.style.color = getContrastColor(highlightColorPicker.value);
                
                gameStats.numbersFound++;
                saveStats();
                checkAchievements();
            }
        }

        function getContrastColor(hexColor) {
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128 ? '#000000' : '#FFFFFF';
        }

        function checkTilePositions() {
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);

            for (let num = 0; num < checkTargetOrder.length; num++) {
                const expectedValue = checkTargetOrder[num]; 
                const tileAtCurrentIndexValue = tiles[num].querySelector('.tile-inner')?.textContent;
                if (parseInt(tileAtCurrentIndexValue) !== expectedValue) {
                     currentTargetNumber = expectedValue;
                     return currentTargetNumber;
                }
            }
            
            stopAutoHighlight();
            if (checkWin(currentSize)) {
                 endGame(true, '–ü–æ–±–µ–¥–∞ —á–µ—Ä–µ–∑ –∞–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫—É!');
            }
            return null;
        }

        function autoHighlightNext() {
            const autoHighlightBtn = document.getElementById('autoHighlightBtn');
            if (isAutoHighlighting) return;
            
            isAutoHighlighting = true;
            autoHighlightBtn.classList.add('active');
            autoHighlightBtn.innerHTML = '<i class="fas fa-stop"></i> –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å';
            currentTargetNumber = 1;
            
            const firstNumber = checkTilePositions();
            if (firstNumber) highlightNumber(firstNumber);
            
            autoHighlightInterval = setInterval(() => {
                const nextNumber = checkTilePositions();
                if (nextNumber) highlightNumber(nextNumber);
            }, 1000);
        }

        function stopAutoHighlight() {
            const autoHighlightBtn = document.getElementById('autoHighlightBtn');
            const tileColorPicker = document.getElementById('tileColor');
            const textColorPicker = document.getElementById('textColor');

            isAutoHighlighting = false;
            clearInterval(autoHighlightInterval);
            autoHighlightBtn.classList.remove('active');
            autoHighlightBtn.innerHTML = '<i class="fas fa-magic"></i> –ê–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫–∞';
            
            if (highlightedTile) {
                highlightedTile.classList.remove('highlight');
                highlightedTile.style.backgroundColor = tileColorPicker.value;
                highlightedTile.style.color = textColorPicker.value;
                highlightedTile = null;
            }
        }

        function toggleAutoHighlight() {
            if (isAutoHighlighting) stopAutoHighlight();
            else autoHighlightNext();
        }

        function shuffleTiles() {
            stopGameMechanisms();
            
            gameStats.shuffles++;
            saveStats();
            checkAchievements();
            
            let tempTiles = [...tiles.filter(t => !t.classList.contains('empty-tile'))];
            
            let solvable = false;
            while (!solvable) {
                for (let i = tempTiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tempTiles[i], tempTiles[j]] = [tempTiles[j], tempTiles[i]];
                }
                let valuesForSolvabilityCheck = tempTiles.map(t => parseInt(t.querySelector('.tile-inner')?.textContent));
                solvable = isSolvable(valuesForSolvabilityCheck, currentSize, currentSize * currentSize); 
            }

            const emptyTileElement = tiles.find(t => t.classList.contains('empty-tile'));
            tiles = [...tempTiles, emptyTileElement];
            emptyTileIndex = tiles.length - 1; 

            applyModeSpecificStylesAndLogic();
            const useComplexAnimation = currentSize <= 10;
            renderTiles(currentSize, useComplexAnimation);
        }

        function applyModeSpecificStylesAndLogic() {
            const tileColorPicker = document.getElementById('tileColor');
            const textColorPicker = document.getElementById('textColor');

            tiles.forEach(tile => {
                tile.classList.remove('obstacle-tile', 'hidden-number', 'revealed', 'hidden-path-hidden');
                tile.style.backgroundImage = '';
                tile.style.backgroundSize = '';
                tile.style.backgroundPosition = '';
                const tileInner = tile.querySelector('.tile-inner');
                if (tileInner) {
                    tileInner.style.display = 'flex';
                    tile.style.backgroundColor = tileColorPicker.value;
                    tile.style.color = textColorPicker.value;
                }
                tile.style.pointerEvents = 'auto';
            });
            obstacleTiles.clear();
            teleportMoveCounter = 0;

            if (gameMode === 'obstacle') {
                const currentMode = gameModes.find(mode => mode.id === gameMode);
                const count = currentMode.getObstacleCount(currentSize);
                let obstaclesAdded = 0;
                const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);

                for (let i = 0; i < tiles.length - 1 && obstaclesAdded < count; i++) {
                    const tile = tiles[i];
                    const tileValue = parseInt(tile.querySelector('.tile-inner')?.textContent);
                    if (tileValue === checkTargetOrder[i]) {
                        tile.classList.add('obstacle-tile');
                        obstacleTiles.add(tile.id);
                        tile.style.pointerEvents = 'none';
                        obstaclesAdded++;
                    }
                }
            }

            if (gameMode === 'memory') {
                tiles.forEach(tile => {
                    if (!tile.classList.contains('empty-tile')) tile.classList.add('hidden-number');
                });
                const currentMode = gameModes.find(mode => mode.id === gameMode);
                setTimeout(() => {
                    tiles.forEach(tile => {
                        if (!tile.classList.contains('empty-tile')) tile.classList.add('revealed');
                    });
                    memoryRevealTimeout = setTimeout(() => {
                        tiles.forEach(tile => {
                            if (!tile.classList.contains('empty-tile')) tile.classList.remove('revealed');
                        });
                    }, currentMode.revealTime || 1500);
                }, 500); 
            }

            if (gameMode === 'image' && imageModeData.image) applyImageToTiles();
            if (gameMode === 'hidden_path') updateHiddenPathTiles(emptyTileIndex);
        }


        function isSolvable(arr, size, emptyTileVal) {
            let inversions = 0;
            const puzzleArray = arr.filter(n => !isNaN(n) && n !== emptyTileVal);
            
            for (let i = 0; i < puzzleArray.length - 1; i++) {
                for (let j = i + 1; j < puzzleArray.length; j++) {
                    if (puzzleArray[i] > puzzleArray[j]) inversions++;
                }
            }

            if (size % 2 === 1) return inversions % 2 === 0;
            
            const emptyTileCurrentPos = arr.indexOf(emptyTileVal);
            const emptyRowFromBottom = size - Math.floor(emptyTileCurrentPos / size); 
            return (emptyRowFromBottom % 2 === 1) ? (inversions % 2 === 0) : (inversions % 2 === 1);
        }


        function isValidMove(fromIndex, toIndex, size) {
            const rowDiff = Math.abs(Math.floor(fromIndex / size) - Math.floor(toIndex / size));
            const colDiff = Math.abs((fromIndex % size) - (toIndex % size));
            return rowDiff + colDiff === 1;
        }

        async function moveTile(tileIndex, size) {
            if (tileIndex === emptyTileIndex || (gameMode === 'obstacle' && obstacleTiles.has(tiles[tileIndex].id))) return;
            
            if (isValidMove(tileIndex, emptyTileIndex, size)) {
                if (gameMode === 'time' && !isTimeModeGameStarted) {
                    isTimeModeGameStarted = true;
                    hintMessage.classList.remove('active');
                    startTimer();
                }

                [tiles[emptyTileIndex], tiles[tileIndex]] = [tiles[tileIndex], tiles[emptyTileIndex]];
                const oldEmptyIndex = emptyTileIndex;
                emptyTileIndex = tileIndex;
                
                if (gameMode === 'teleport') await applyTeleport();
                else if (gameMode === 'vortex') await applyVortex();
                
                if (gameMode === 'hidden_path') updateHiddenPathTiles(emptyTileIndex);

                renderTiles(size);
                
                gameStats.currentMoves++;
                gameStats.totalMoves++;
                addScore(1);

                if (gameMode === 'moves') {
                    movesLeft--;
                    if (movesLeft <= 0 && !checkWin(size)) {
                        endGame(false, '–•–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å!'); 
                        return; 
                    }
                }

                if (gameMode === 'memory') {
                    const currentMode = gameModes.find(mode => mode.id === gameMode);
                    const movedTile = tiles[tileIndex];
                    movedTile.classList.add('revealed');
                    clearTimeout(memoryRevealTimeout); 
                    memoryRevealTimeout = setTimeout(() => movedTile.classList.remove('revealed'), currentMode.revealTime || 1500);
                }

                saveStats();
                checkAchievements();
                
                const movedTile = tiles[tileIndex];
                const tileContent = movedTile.querySelector('.tile-inner')?.textContent;
                const expectedForHighlight = (gameMode === 'reverse') ? targetOrder[tileIndex] : (tileIndex + 1);

                if (tileContent && parseInt(tileContent) === expectedForHighlight) {
                    movedTile.classList.add('correct-position');
                    setTimeout(() => movedTile.classList.remove('correct-position'), 1000);
                }
                
                highlightCorrectTiles(size); 
                updateScore(); 

                if (isAutoHighlighting) {
                    const nextNumber = checkTilePositions();
                    if (nextNumber) highlightNumber(nextNumber);
                }

                if (checkWin(size)) {
                    endGame(true, `–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –í—ã —Å–æ–±—Ä–∞–ª–∏ –≤—Å–µ –ø–ª–∏—Ç–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ!\n–í–∞—à —Å—á–µ—Ç: ${currentScore}\n–•–æ–¥–æ–≤ —Å–¥–µ–ª–∞–Ω–æ: ${gameStats.currentMoves}`);
                }
            }
        }

        async function applyTeleport() {
            teleportMoveCounter++;
            const currentMode = gameModes.find(mode => mode.id === 'teleport');
            const frequency = currentMode.teleportFrequency(currentSize);

            if (teleportMoveCounter >= frequency) {
                teleportMoveCounter = 0;
                const oldEmptyIndex = emptyTileIndex;
                const availableSpots = tiles.map((tile, index) => index).filter(index => index !== oldEmptyIndex && !tiles[index].classList.contains('obstacle-tile'));

                if (availableSpots.length > 0) {
                    const newEmptyIndex = availableSpots[Math.floor(Math.random() * availableSpots.length)];
                    [tiles[oldEmptyIndex], tiles[newEmptyIndex]] = [tiles[newEmptyIndex], tiles[oldEmptyIndex]];
                    emptyTileIndex = newEmptyIndex;
                    renderTiles(currentSize);
                    await new Promise(resolve => setTimeout(resolve, 150));
                }
            }
        }

        async function applyVortex() {
            const emptyRow = Math.floor(emptyTileIndex / currentSize);
            const emptyCol = emptyTileIndex % currentSize;
            
            const possibleMoves = [];
            if (emptyRow > 0) possibleMoves.push(emptyTileIndex - currentSize);
            if (emptyRow < currentSize - 1) possibleMoves.push(emptyTileIndex + currentSize);
            if (emptyCol > 0) possibleMoves.push(emptyTileIndex - 1);
            if (emptyCol < currentSize - 1) possibleMoves.push(emptyTileIndex + 1);

            const validMoves = possibleMoves.filter(index => !tiles[index].classList.contains('obstacle-tile'));
            if (validMoves.length > 0) {
                const randomIndex = validMoves[Math.floor(Math.random() * validMoves.length)];
                [tiles[emptyTileIndex], tiles[randomIndex]] = [tiles[randomIndex], tiles[emptyTileIndex]];
                emptyTileIndex = randomIndex;
                renderTiles(currentSize);
                await new Promise(resolve => setTimeout(resolve, 150));
            }
        }

        function updateHiddenPathTiles(emptyIndex) {
            const emptyRow = Math.floor(emptyIndex / currentSize);
            const emptyCol = emptyIndex % currentSize;

            const adjacentIndexes = new Set();
            const adjacentOffsets = [[-1, 0], [1, 0], [0, -1], [0, 1]];

            for (const [dr, dc] of adjacentOffsets) {
                const checkRow = emptyRow + dr;
                const checkCol = emptyCol + dc;

                if (checkRow >= 0 && checkRow < currentSize && checkCol >= 0 && checkCol < currentSize) {
                    adjacentIndexes.add(checkRow * currentSize + checkCol);
                }
            }

            tiles.forEach((tile, index) => {
                if (!tile.classList.contains('empty-tile')) {
                    if (adjacentIndexes.has(index)) tile.classList.remove('hidden-path-hidden');
                    else tile.classList.add('hidden-path-hidden');
                }
            });
        }

        function checkWin(size) {
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: size * size - 1}, (_, i) => i + 1);
            for (let i = 0; i < size * size - 1; i++) {
                const tileContent = tiles[i].querySelector('.tile-inner')?.textContent;
                const tileValue = gameMode === 'image' ? parseInt(tiles[i].id.replace('tile-', '')) : parseInt(tileContent);
                if (tileValue !== checkTargetOrder[i]) return false;
            }
            return true;
        }

        function endGame(win, message) {
            stopGameMechanisms(); 
            if (win) showWinAnimation(); 
            else showMessageModal('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!', message + '\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑!', () => shuffleTiles());
        }

        function showWinAnimation() {
            gameStats.totalGamesWon++;
            gameStats.totalScore += currentScore;
            
            if (!gameStats.gamesWonBySize[currentSize]) gameStats.gamesWonBySize[currentSize] = 0;
            gameStats.gamesWonBySize[currentSize]++;
            
            const currentRecord = gameStats.gameRecords[gameMode][currentSize];
            currentRecord.gamesPlayed++;
            
            if (gameMode === 'time') {
                const timeTaken = gameModes.find(mode => mode.id === gameMode).getLimits(currentSize).time - timeLeft;
                if (timeTaken < currentRecord.bestTime) currentRecord.bestTime = timeTaken;
                if (timeTaken > currentRecord.worstTime) currentRecord.worstTime = timeTaken;
            } else { 
                const movesTaken = gameStats.currentMoves;
                if (movesTaken < currentRecord.bestMoves) currentRecord.bestMoves = movesTaken;
                if (movesTaken > currentRecord.worstMoves) currentRecord.worstMoves = movesTaken;
            }

            if (isAutoHighlighting) gameStats.winsWithAutohighlight++;
            
            saveStats();
            checkAchievements();
            renderStatsTab();
            animateCards('stats-tab');
            
            createConfetti();
            
            setTimeout(() => {
                showMessageModal('üéâ –ü–æ–±–µ–¥–∞!', `–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –í—ã —Å–æ–±—Ä–∞–ª–∏ –≤—Å–µ –ø–ª–∏—Ç–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ!\n–í–∞—à —Å—á–µ—Ç: ${currentScore}\n–•–æ–¥–æ–≤ —Å–¥–µ–ª–∞–Ω–æ: ${gameStats.currentMoves}`, () => shuffleTiles());
            }, 1000);
        }

        function createConfetti() {
            const colors = ['#fd79a8', '#74b9ff', '#55efc4', '#ffeaa7', '#a29bfe'];
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = Math.random() * 10 + 5 + 'px';
                confetti.style.height = Math.random() * 10 + 5 + 'px';
                confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
                confetti.style.animationDelay = Math.random() * 2 + 's';
                document.body.appendChild(confetti);
                setTimeout(() => confetti.remove(), 5000);
            }
        }

        function renderTiles(size, initialAnimation = false) {
            tiles.forEach((tile, index) => {
                const row = Math.floor(index / size);
                const col = index % size;
                const targetX = col * (tileSize + tileGap);
                const targetY = row * (tileSize + tileGap);

                if (initialAnimation) {
                    tile.style.transition = 'none';
                    tile.style.opacity = 1;
                    setTimeout(() => {
                        tile.style.transition = `transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55)`;
                        tile.style.transform = `translate(${targetX}px, ${targetY}px)`;
                    }, 50); 
                } else {
                    tile.style.transition = `transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease`;
                    tile.style.transform = `translate(${targetX}px, ${targetY}px)`;
                    tile.style.opacity = 1;
                }
            });
            highlightCorrectTiles(size);
        }

        function highlightCorrectTiles(size) {
            const correctColorPicker = document.getElementById('correctColor');
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: size * size - 1}, (_, i) => i + 1);

            tiles.forEach((tile, index) => {
                const tileInner = tile.querySelector('.tile-inner');
                if (tileInner || gameMode === 'image') { 
                    const tileValue = gameMode === 'image' ? parseInt(tile.id.replace('tile-', '')) : parseInt(tileInner.textContent);
                    const isCorrect = (tileValue === checkTargetOrder[index]);
                    if (isCorrect) {
                        tile.classList.add('correct');
                        tile.style.borderColor = correctColorPicker.value;
                    } else {
                        tile.classList.remove('correct');
                        tile.style.borderColor = 'transparent';
                    }
                }
            });
        }
        
        function updateColors(colorType) {
            const bgColorPicker = document.getElementById('bgColor');
            const borderColorPicker = document.getElementById('borderColor');
            const tileColorPicker = document.getElementById('tileColor');
            const textColorPicker = document.getElementById('textColor');

            document.body.style.backgroundColor = bgColorPicker.value;
            document.body.style.color = getContrastColor(bgColorPicker.value);
            gameField.style.borderColor = borderColorPicker.value;
            
            tiles.forEach(tile => {
                if (!tile.classList.contains('empty-tile') && !tile.classList.contains('obstacle-tile')) {
                    tile.style.backgroundColor = tileColorPicker.value;
                    tile.style.color = textColorPicker.value;
                }
            });
            
            highlightCorrectTiles(currentSize);
            gameStats.colorsChanged.add(colorType);
            saveStats();
            checkAchievements();
        }

        function saveStats() {
            const statsToSave = {
                ...gameStats,
                playedSizes: Array.from(gameStats.playedSizes),
                colorsChanged: Array.from(gameStats.colorsChanged),
                styleChanges: Array.from(gameStats.styleChanges),
                modesTried: Array.from(gameStats.modesTried)
            };
            localStorage.setItem('gameStats_v13_final', JSON.stringify(statsToSave)); 
            localStorage.setItem('completedAchievements_v13_final', JSON.stringify(completedAchievements)); 
        }

        function loadStats() {
            const savedStats = localStorage.getItem('gameStats_v13_final');
            const savedAchievements = localStorage.getItem('completedAchievements_v13_final');
            
            initializeStats(); 

            if (savedStats) {
                const parsedStats = JSON.parse(savedStats);
                Object.assign(gameStats, parsedStats);
                gameStats.playedSizes = new Set(parsedStats.playedSizes || []);
                gameStats.colorsChanged = new Set(parsedStats.colorsChanged || []);
                gameStats.styleChanges = new Set(parsedStats.styleChanges || []);
                gameStats.modesTried = new Set(parsedStats.modesTried || ['classic']);
                
                if (parsedStats.gameRecords) {
                    for (const modeId in gameStats.gameRecords) {
                        if (parsedStats.gameRecords[modeId]) {
                            for (const size in gameStats.gameRecords[modeId]) {
                                if (parsedStats.gameRecords[modeId][size]) {
                                    Object.assign(gameStats.gameRecords[modeId][size], parsedStats.gameRecords[modeId][size]);
                                }
                            }
                        }
                    }
                }
            }
            
            if (savedAchievements) completedAchievements = JSON.parse(savedAchievements);
            
            calculateAchievementScore();
        }

        function calculateAchievementScore() {
            let total = 0;
            completedAchievements.forEach(achId => {
                const achievement = achievementsData.find(a => a.id === achId);
                if (achievement) total += achievement.points;
            });
            gameStats.achievementScore = total;
            saveStats();
        }

        function checkAchievements() {
            let changed = false;
            achievementsData.forEach(achievement => {
                if (!completedAchievements.includes(achievement.id) && achievement.condition(gameStats)) {
                    completedAchievements.push(achievement.id);
                    showAchievementUnlocked(achievement);
                    gameStats.achievementScore += achievement.points;
                    changed = true;
                }
            });
            
            if(changed) {
                saveStats();
                renderAchievementsTab();
                renderStatsTab();
            }
        }

        function showAchievementUnlocked(achievement) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20px; right: 20px; background: white; padding: 15px;
                border-radius: 10px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
                display: flex; align-items: center; gap: 15px; z-index: 1000;
                transform: translateX(200%); transition: transform 0.5s ease;
            `;
            notification.innerHTML = `
                <div style="background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.5rem;">
                    <i class="fas ${achievement.icon}"></i>
                </div>
                <div>
                    <div style="font-weight: bold; color: var(--primary-color);">–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ!</div>
                    <div style="font-weight: 600; margin: 5px 0;">${achievement.title}</div>
                    <div style="font-size: 0.9rem; color: #636e72;">+${achievement.points} –æ—á–∫–æ–≤</div>
                </div>
            `;
            document.body.appendChild(notification);
            setTimeout(() => notification.style.transform = 'translateX(0)', 100);
            setTimeout(() => {
                notification.style.transform = 'translateX(200%)';
                setTimeout(() => notification.remove(), 500);
            }, 5000);
        }

        function setActiveMode(modeId) {
            gameMode = modeId;
            gameStats.modesTried.add(modeId);
            saveStats();
            checkAchievements();
            
            gameModes.forEach(mode => mode.active = (mode.id === modeId));
            
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.toggle('active', card.dataset.mode === modeId);
            });
            
            createGame(currentSize); 
            shuffleTiles(); 
            
            if (gameMode === 'time') hintMessage.classList.add('active');
            else {
                hintMessage.classList.remove('active');
                stopGameMechanisms(); 
            }
        }

        function loadImageForMode(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    imageModeData.image = img;
                    imageModeData.imageUrl = e.target.result;
                    if (!imageModeData.canvas) {
                        imageModeData.canvas = document.createElement('canvas');
                        imageModeData.ctx = imageModeData.canvas.getContext('2d');
                        imageModeData.canvas.style.display = 'none';
                        document.body.appendChild(imageModeData.canvas);
                    }
                    imageModeData.canvas.width = img.width;
                    imageModeData.canvas.height = img.height;
                    imageModeData.ctx.drawImage(img, 0, 0);
                    if (gameMode === 'image') applyImageToTiles();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function applyImageToTiles() {
            if (!imageModeData.image || !imageModeData.ctx) return;
            const img = imageModeData.image;
            const tileWidth = img.width / currentSize;
            const tileHeight = img.height / currentSize;

            tiles.forEach((tile) => {
                if (tile.classList.contains('empty-tile')) {
                    tile.style.backgroundImage = ''; return;
                }
                const originalNumber = parseInt(tile.id.replace('tile-', ''));
                const originalIndex = originalNumber - 1;
                const col = originalIndex % currentSize;
                const row = Math.floor(originalIndex / currentSize);
                const sx = col * tileWidth;
                const sy = row * tileHeight;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = tileWidth;
                tempCanvas.height = tileHeight;
                tempCanvas.getContext('2d').drawImage(img, sx, sy, tileWidth, tileHeight, 0, 0, tileWidth, tileHeight);
                tile.style.backgroundImage = `url(${tempCanvas.toDataURL()})`;
                tile.style.backgroundSize = 'cover'; 
                const tileInner = tile.querySelector('.tile-inner');
                if (tileInner) tileInner.style.display = 'none'; 
            });
        }

        function showMessageModal(title, message, onCloseCallback = null) {
            modalTitle.textContent = title;
            modalMessage.innerHTML = message.replace(/\n/g, '<br>');
            messageModal.classList.add('active');
            const closeHandler = () => {
                messageModal.classList.remove('active');
                modalCloseBtn.removeEventListener('click', closeHandler);
                if (onCloseCallback) onCloseCallback();
            };
            modalCloseBtn.addEventListener('click', closeHandler);
        }
        
        // Event Handlers
        gameField.addEventListener('click', (e) => {
            const tile = e.target.closest('.tile');
            if (tile) {
                const tileIndex = tiles.indexOf(tile);
                if (tileIndex !== -1) moveTile(tileIndex, currentSize);
            }
        });

        let swipeStartX, swipeStartY;
        gameField.addEventListener('touchstart', (e) => {
            swipeStartX = e.touches[0].clientX;
            swipeStartY = e.touches[0].clientY;
        });
        gameField.addEventListener('touchmove', (e) => e.preventDefault());
        gameField.addEventListener('touchend', (e) => {
            const swipeEndX = e.changedTouches[0].clientX;
            const swipeEndY = e.changedTouches[0].clientY;
            const deltaX = swipeEndX - swipeStartX;
            const deltaY = swipeEndY - swipeStartY;
            let tileToMoveIndex = -1;
            const emptyTileRow = Math.floor(emptyTileIndex / currentSize);
            const emptyTileCol = emptyTileIndex % currentSize;

            if (Math.abs(deltaX) > Math.abs(deltaY)) { 
                if (deltaX < 0 && emptyTileCol < currentSize - 1) tileToMoveIndex = emptyTileIndex + 1;
                else if (deltaX > 0 && emptyTileCol > 0) tileToMoveIndex = emptyTileIndex - 1;
            } else { 
                if (deltaY < 0 && emptyTileRow < currentSize - 1) tileToMoveIndex = emptyTileIndex + currentSize;
                else if (deltaY > 0 && emptyTileRow > 0) tileToMoveIndex = emptyTileIndex - currentSize;
            }
            if (tileToMoveIndex !== -1) moveTile(tileToMoveIndex, currentSize);
        });

        // Initialize game
        function init() {
            loadStats();
            renderAllTabs();
            createGame(4); 
            shuffleTiles();
            checkAchievements(); 
            animateCards('settings-tab'); // –ê–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –ø–µ—Ä–≤–æ–π –≤–∫–ª–∞–¥–∫–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        }
        
        init();
        
        window.addEventListener('beforeunload', () => saveStats());

    </script>
</body>
</html>
