<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—è—Ç–Ω–∞—à–∫–∏–Ω—ÅüéÄ</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Pacifico&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* –°—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
        :root {
            --primary-color: #6c5ce7;
            --secondary-color: #a29bfe;
            --accent-color: #fd79a8;
            --dark-color: #2d3436;
            --light-color: #f5f6fa;
            --success-color: #00b894;
            --warning-color: #fdcb6e;
            --danger-color: #e17055;
            --tile-color: #ffeaa7;
            --highlight-color: #74b9ff;
            --correct-color: #55efc4;
            --info-color: #0984e3;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--light-color);
            color: var(--dark-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 20px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 10;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .logo {
            font-family: 'Pacifico', cursive;
            font-size: 2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo i {
            color: var(--accent-color);
        }

        .score-display {
            background-color: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
            margin-left: 10px; /* –û—Ç—Å—Ç—É–ø –º–µ–∂–¥—É –ø–æ–∫–∞–∑–∞—Ç–µ–ª—è–º–∏ */
        }

        .score-display i {
            color: var(--warning-color);
        }

        /* Main content */
        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 30px 0;
        }

        /* Game area */
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
            width: 100%;
            overflow: auto;
            position: relative; /* –î–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–¥—Å–∫–∞–∑–∫–∏ */
        }

        .game-field {
            display: grid;
            gap: 8px;
            margin: 20px auto;
            border: 3px solid var(--primary-color);
            touch-action: none;
            border-radius: 15px;
            background-color: white;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .tile {
            background-color: var(--tile-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            border-radius: 10px;
            transition: transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease;
            position: absolute;
            width: 60px;
            height: 60px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            color: var(--dark-color);
            border: 2px solid transparent;
            user-select: none;
            overflow: hidden; /* –î–ª—è —Ä–µ–∂–∏–º–∞ —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π */
            opacity: 0; /* –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã—Ç—ã –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ */
        }

        .tile.show {
            opacity: 1;
        }

        .tile.correct {
            border-color: var(--correct-color);
            box-shadow: 0 0 15px rgba(85, 239, 196, 0.5);
        }

        .tile.highlight {
            z-index: 10;
            background-color: var(--highlight-color);
            color: white;
            box-shadow: 0 0 20px rgba(116, 185, 255, 0.7);
        }

        .tile-inner {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            transition: opacity 0.3s ease; /* –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –¥–ª—è —Ü–∏—Ñ—Ä –≤ —Ä–µ–∂–∏–º–µ "–ü–∞–º—è—Ç—å" */
        }

        .tile.highlight .tile-inner {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .tile.correct-position {
            animation: correctGlow 1s ease;
        }

        @keyframes correctGlow {
            0% { box-shadow: 0 0 10px rgba(85, 239, 196, 0.5); }
            50% { box-shadow: 0 0 20px rgba(85, 239, 196, 0.8); }
            100% { box-shadow: 0 0 10px rgba(85, 239, 196, 0.5); }
        }

        .empty-tile {
            background-color: transparent;
            color: transparent;
            border: none;
            box-shadow: none;
            opacity: 1 !important; /* –ü—É—Å—Ç–∞—è –ø–ª–∏—Ç–∫–∞ –≤—Å–µ–≥–¥–∞ –≤–∏–¥–∏–º–∞ */
        }

        .tile.obstacle-tile {
            background-color: #b2bec3; /* –°–µ—Ä—ã–π —Ü–≤–µ—Ç –¥–ª—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π */
            cursor: not-allowed;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            pointer-events: none; /* –ó–∞–ø—Ä–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è */
        }
        
        .tile.hidden-number .tile-inner {
            opacity: 0; /* –°–∫—Ä—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—É */
        }

        .tile.hidden-number.revealed .tile-inner {
            opacity: 1; /* –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–∏—Ñ—Ä—É */
        }
        
        .tile.darkness-hidden,
        .tile.hidden-path-hidden {
            background-color: #444; /* –¢–µ–º–Ω—ã–π —Ñ–æ–Ω –¥–ª—è —Å–∫—Ä—ã—Ç—ã—Ö –ø–ª–∏—Ç–æ–∫ */
            color: transparent; /* –°–∫—Ä—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç */
            box-shadow: none;
        }

        /* Hint for Time mode */
        .hint-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.1rem;
            text-align: center;
            z-index: 50;
            pointer-events: none; /* –ù–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏—è –º—ã—à–∏/–∫–∞—Å–∞–Ω–∏—è */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .hint-message.active {
            opacity: 1;
            visibility: visible;
        }

        /* Tabs */
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            position: relative;
            flex-wrap: wrap; /* –î–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
            gap: 10px; /* –û—Ç—Å—Ç—É–ø –º–µ–∂–¥—É –∫–Ω–æ–ø–∫–∞–º–∏ */
        }

        .tab-button {
            padding: 12px 25px;
            background: white;
            border: none;
            border-radius: 30px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--dark-color);
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(108, 92, 231, 0.4);
        }

        .tab-button i {
            font-size: 1.1rem;
        }

        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Settings, Achievements, Modes, Stats Grids */
        .settings-grid, .achievements-grid, .modes-grid, .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .settings-card, .achievement-card, .mode-card, .stats-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            opacity: 0; /* –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã—Ç—ã –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ */
            animation: fadeInUp 0.5s ease-out forwards;
        }
        
        .settings-card:hover, .achievement-card:hover, .mode-card:hover, .stats-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .settings-card h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.2rem;
        }

        .settings-card h3 i {
            color: var(--accent-color);
        }
        
        /* Statistics Tab */
        .stats-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .stats-icon {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .stats-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--dark-color);
            line-height: 1;
        }

        .stats-label {
            font-size: 1rem;
            color: #636e72;
            margin-top: 5px;
        }
        
        .stats-list-card {
            grid-column: 1 / -1; /* Span full width */
        }
        
        .stats-list-card h3 {
             color: var(--primary-color);
             margin-bottom: 15px;
        }

        .stats-list {
            list-style: none;
            padding: 0;
            max-height: 300px; /* –£–≤–µ–ª–∏—á–∏–ª –≤—ã—Å–æ—Ç—É –¥–ª—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ */
            overflow-y: auto;
            border: 1px solid #dfe6e9;
            border-radius: 10px;
            padding: 10px;
        }
        
        .stats-list li {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 8px;
            transition: background-color 0.2s;
            flex-wrap: wrap; /* –î–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
        }

        .stats-list li:nth-child(odd) {
            background-color: rgba(108, 92, 231, 0.05);
        }
        
        .stats-list li:hover {
            background-color: rgba(108, 92, 231, 0.1);
        }

        .stats-list-label {
            font-weight: 600;
            flex-basis: 60%; /* –î–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
        }

        .stats-list-value {
            font-weight: 700;
            color: var(--primary-color);
            flex-basis: 35%; /* –î–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
            text-align: right;
        }
        
        .stats-sub-list {
            list-style: none;
            padding-left: 20px;
            margin-top: 5px;
            font-size: 0.9em;
            color: #636e72;
        }

        .stats-sub-list li {
            padding: 3px 0;
            display: flex;
            justify-content: space-between;
        }


        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .control-label {
            font-size: 16px;
            margin-right: 10px;
            color: var(--dark-color);
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            border: 3px solid white;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        input[type="range"] {
            flex-grow: 1;
            height: 8px;
            border-radius: 4px;
            background: var(--secondary-color);
            -webkit-appearance: none;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .range-value {
            min-width: 40px;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            color: var(--primary-color);
            margin-left: 10px;
        }

        .btn {
            padding: 12px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 10px rgba(108, 92, 231, 0.3);
            margin-right: 10px; /* –û—Ç—Å—Ç—É–ø –º–µ–∂–¥—É –∫–Ω–æ–ø–∫–∞–º–∏ */
            margin-bottom: 10px; /* –û—Ç—Å—Ç—É–ø –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
        }

        .btn:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(108, 92, 231, 0.4);
        }
        
        .btn:disabled {
            background-color: #b2bec3;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn i {
            font-size: 1rem;
        }

        .btn-block {
            display: block;
            width: 100%;
        }

        .btn-success {
            background: var(--success-color);
            box-shadow: 0 4px 10px rgba(0, 184, 148, 0.3);
        }

        .btn-success:hover {
            background: #00a884;
            box-shadow: 0 6px 15px rgba(0, 184, 148, 0.4);
        }

        .btn-warning {
            background: var(--warning-color);
            box-shadow: 0 4px 10px rgba(253, 203, 110, 0.3);
        }

        .btn-warning:hover {
            background: #f5b74f;
            box-shadow: 0 6px 15px rgba(253, 203, 110, 0.4);
        }
        
        .btn-info {
            background: var(--info-color);
            box-shadow: 0 4px 10px rgba(9, 132, 227, 0.3);
        }

        .btn-info:hover {
            background: #0984e3;
            box-shadow: 0 6px 15px rgba(9, 132, 227, 0.4);
        }


        .btn-danger {
            background: var(--danger-color);
            box-shadow: 0 4px 10px rgba(225, 112, 85, 0.3);
        }

        .btn-danger:hover {
            background: #d15f44;
            box-shadow: 0 6px 15px rgba(225, 112, 85, 0.4);
        }

        .btn.active {
            background: var(--danger-color);
        }

        .btn.active:hover {
            background: #d15f44;
        }

        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label.btn {
            margin-bottom: 0;
        }

        .input-group input[type="number"],
        .input-group input[type="file"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #dfe6e9;
            border-radius: 30px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .input-group input[type="number"]:focus,
        .input-group input[type="file"]:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.2);
        }
        
        .input-group input[type="file"] {
            display: none; /* –°–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∏–Ω–ø—É—Ç */
        }

        /* Achievements tab */
        .achievements-intro {
            text-align: center;
            font-size: 1rem;
            color: #636e72;
            margin: 0 auto 20px;
            max-width: 600px;
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .achievement-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .achievement-card.locked {
            opacity: 0.7;
            filter: grayscale(70%);
        }

        .achievement-icon {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            color: white;
            font-size: 1.8rem;
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.3);
        }

        .achievement-card.locked .achievement-icon {
            background: linear-gradient(135deg, #b2bec3, #dfe6e9);
        }

        .achievement-title {
            font-weight: 700;
            margin-bottom: 5px;
            color: var(--dark-color);
        }

        .achievement-desc {
            font-size: 0.9rem;
            color: #636e72;
            margin-bottom: 10px;
        }

        .achievement-progress {
            width: 100%;
            height: 6px;
            background: #dfe6e9;
            border-radius: 3px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--danger-color));
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .achievement-points {
            font-weight: 700;
            color: var(--primary-color);
            font-size: 0.9rem;
        }

        .achievement-date {
            font-size: 0.8rem;
            color: #b2bec3;
            margin-top: 5px;
        }

        .ribbon {
            position: absolute;
            top: 10px;
            right: -30px;
            background: var(--accent-color);
            color: white;
            padding: 3px 30px;
            font-size: 0.7rem;
            font-weight: 600;
            transform: rotate(45deg);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Modes tab */
        .mode-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .mode-card.active {
            border-color: var(--primary-color);
            background: rgba(108, 92, 231, 0.05);
        }

        .mode-icon {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            color: white;
            font-size: 1.8rem;
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.3);
        }

        .mode-title {
            font-weight: 700;
            margin-bottom: 5px;
            color: var(--dark-color);
        }

        .mode-desc {
            font-size: 0.9rem;
            color: #636e72;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-50px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-content h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .modal-content p {
            color: var(--dark-color);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .modal-content .btn {
            margin: 0 5px;
        }

        /* Animations */
        @keyframes confetti {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: var(--accent-color);
            opacity: 0;
            z-index: 1000;
            animation: confetti 3s ease-out forwards;
        }
        
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        .fa-spinner {
            animation: spin 1s linear infinite;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 15px;
            }
            
            .tabs {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .tab-button {
                margin: 5px;
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .settings-grid, .achievements-grid, .modes-grid, .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .tile {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        @media (max-width: 480px) {
            .logo {
                font-size: 1.5rem;
            }
            
            .score-display {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .tile {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            .control-row {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .control-label {
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container header-content">
            <div class="logo">
                <i class="fas fa-gamepad"></i>
                <span>–ü—è—Ç–Ω–∞—à–∫–∏–Ω—ÅüéÄ</span>
            </div>
            <div class="score-display" id="scoreDisplay">
                <i class="fas fa-star"></i>
                <span>–û—á–∫–∏: 0</span>
            </div>
            <div class="score-display" id="gameStatusDisplay"></div>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <div class="game-area">
                <div class="game-field" id="gameField"></div>
                <div class="hint-message" id="hintMessage">
                    –°–º–∞—Ö–Ω–∏—Ç–µ –ø–ª–∏—Ç–∫—É, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!
                </div>
            </div>

            <div class="tabs">
                <button class="tab-button active" data-tab="game">
                    <i class="fas fa-puzzle-piece"></i> –ò–≥—Ä–∞
                </button>
                <button class="tab-button" data-tab="modes">
                    <i class="fas fa-chess-board"></i> –†–µ–∂–∏–º—ã
                </button>
                <button class="tab-button" data-tab="settings">
                    <i class="fas fa-cog"></i> –ù–∞—Å—Ç—Ä–æ–π–∫–∏
                </button>
                <button class="tab-button" data-tab="achievements">
                    <i class="fas fa-trophy"></i> –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è
                </button>
                <button class="tab-button" data-tab="stats">
                    <i class="fas fa-chart-bar"></i> –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
                </button>
            </div>

            <div class="tab-content active" id="game-tab">
                <div class="settings-grid">
                    <div class="settings-card">
                        <h3><i class="fas fa-sliders-h"></i> –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
                        <div class="control-row">
                            <span class="control-label">–†–∞–∑–º–µ—Ä –ø–æ–ª—è:</span>
                            <input type="range" id="sizeSlider" min="2" max="20" value="4" step="1">
                            <span class="range-value" id="sizeValue">4</span>
                        </div>
                        <button class="btn btn-success" id="applySize">
                            <i class="fas fa-check"></i> –ü—Ä–∏–º–µ–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä
                        </button>
                        <button class="btn btn-warning" id="shuffleBtn">
                            <i class="fas fa-random"></i> –ü–µ—Ä–µ–º–µ—à–∞—Ç—å
                        </button>
                    </div>

                    <div class="settings-card">
                        <h3><i class="fas fa-palette"></i> –í–Ω–µ—à–Ω–∏–π –≤–∏–¥</h3>
                        <div class="control-row">
                            <span class="control-label">–†–∞–∑–º–µ—Ä –ø–ª–∏—Ç–æ–∫:</span>
                            <input type="range" id="tileSizeSlider" min="30" max="100" value="60" step="1">
                            <span class="range-value" id="tileSizeValue">60px</span>
                        </div>
                        <div class="control-row">
                            <span class="control-label">–ó–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ:</span>
                            <input type="range" id="tileRadiusSlider" min="0" max="50" value="10" step="1">
                            <span class="range-value" id="tileRadiusValue">10px</span>
                        </div>
                        <div class="control-row">
                            <span class="control-label">–†–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞:</span>
                            <input type="range" id="fontSizeSlider" min="12" max="48" value="24" step="1">
                            <span class="range-value" id="fontSizeValue">24px</span>
                        </div>
                    </div>

                    <div class="settings-card">
                        <h3><i class="fas fa-fill-drip"></i> –¶–≤–µ—Ç–∞</h3>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç –ø–ª–∏—Ç–æ–∫:</span>
                            <input type="color" id="tileColor" value="#ffeaa7">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç —Ñ–æ–Ω–∞:</span>
                            <input type="color" id="bgColor" value="#f5f6fa">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç —Ä–∞–º–∫–∏:</span>
                            <input type="color" id="borderColor" value="#6c5ce7">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞:</span>
                            <input type="color" id="textColor" value="#2d3436">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç –ø–æ–¥—Å–≤–µ—Ç–∫–∏:</span>
                            <input type="color" id="highlightColor" value="#74b9ff">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö:</span>
                            <input type="color" id="correctColor" value="#55efc4">
                        </div>
                    </div>

                    <div class="settings-card">
                        <h3><i class="fas fa-search"></i> –ü–æ–∏—Å–∫ –∏ –ø–æ–¥—Å–≤–µ—Ç–∫–∞</h3>
                        <div class="input-group">
                            <input type="number" id="numberInput" min="1" placeholder="–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ" class="form-input">
                        </div>
                        <button class="btn" id="findNumberBtn">
                            <i class="fas fa-search"></i> –ù–∞–π—Ç–∏ —á–∏—Å–ª–æ
                        </button>
                        <button class="btn" id="autoHighlightBtn">
                            <i class="fas fa-magic"></i> –ê–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫–∞
                        </button>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="modes-tab">
                <div class="modes-grid" id="modesGrid">
                    </div>
            </div>
            
            <div class="tab-content" id="settings-tab">
                <div class="settings-grid">
                     <div class="settings-card">
                        <h3><i class="fas fa-bullhorn"></i> –û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å</h3>
                        <div class="control-row">
                            <span class="control-label">–í–∏–±—Ä–∞—Ü–∏—è</span>
                            <button class="btn" id="vibrationToggleBtn">
                                <i class="fas fa-check"></i> –í–∫–ª—é—á–µ–Ω–∞
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="achievements-tab">
                 <div class="achievements-intro">
                    ‚ú® –î–æ–∫–∞–∂–∏—Ç–µ —Å–≤–æ—ë –º–∞—Å—Ç–µ—Ä—Å—Ç–≤–æ, –æ—Ç–∫—Ä—ã–≤ –≤—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è! ‚ú®
                </div>
                <div class="achievements-grid" id="achievementsGrid">
                </div>
            </div>
            
            <div class="tab-content" id="stats-tab">
                <div class="stats-grid" id="statsGrid">
                     </div>
            </div>
        </div>
    </main>

    <div class="modal-overlay" id="messageModal">
        <div class="modal-content">
            <h3 id="modalTitle"></h3>
            <p id="modalMessage"></p>
            <button class="btn btn-primary" id="modalCloseBtn">–û–ö</button>
        </div>
    </div>

    <script>
        // DOM elements
        const gameField = document.getElementById('gameField');
        const tileColorPicker = document.getElementById('tileColor');
        const numberInput = document.getElementById('numberInput');
        const findNumberBtn = document.getElementById('findNumberBtn');
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');
        const applySizeBtn = document.getElementById('applySize');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const autoHighlightBtn = document.getElementById('autoHighlightBtn');
        const bgColorPicker = document.getElementById('bgColor');
        const borderColorPicker = document.getElementById('borderColor');
        const textColorPicker = document.getElementById('textColor');
        const highlightColorPicker = document.getElementById('highlightColor');
        const correctColorPicker = document.getElementById('correctColor');
        const tileSizeSlider = document.getElementById('tileSizeSlider');
        const tileSizeValue = document.getElementById('tileSizeValue');
        const tileRadiusSlider = document.getElementById('tileRadiusSlider');
        const tileRadiusValue = document.getElementById('tileRadiusValue');
        const fontSizeSlider = document.getElementById('fontSizeSlider');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const gameStatusDisplay = document.getElementById('gameStatusDisplay');
        const achievementsGrid = document.getElementById('achievementsGrid');
        const modesGrid = document.getElementById('modesGrid');
        const statsGrid = document.getElementById('statsGrid');
        const messageModal = document.getElementById('messageModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const hintMessage = document.getElementById('hintMessage');
        const vibrationToggleBtn = document.getElementById('vibrationToggleBtn');
        
        // Tab functionality
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    content.querySelectorAll('.settings-card, .achievement-card, .mode-card, .stats-card').forEach(card => {
                         card.style.animation = 'none';
                         card.style.opacity = '0';
                    });
                });
                
                const newTabContent = document.getElementById(`${tabId}-tab`);
                newTabContent.classList.add('active');
                
                const cards = newTabContent.querySelectorAll('.settings-card, .achievement-card, .mode-card, .stats-card');
                cards.forEach((card, index) => {
                    card.style.animation = `fadeInUp 0.5s ease-out ${index * 0.07}s forwards`;
                });
            });
        });
        
        const vibrationManager = {
            enabled: true,
            load() {
                const saved = localStorage.getItem('vibrationEnabled_v1');
                this.enabled = saved !== 'false';
                this.updateButton();
            },
            save() {
                localStorage.setItem('vibrationEnabled_v1', this.enabled);
            },
            toggle() {
                this.enabled = !this.enabled;
                this.save();
                this.updateButton();
            },
            updateButton() {
                if (this.enabled) {
                    vibrationToggleBtn.innerHTML = `<i class="fas fa-check"></i> –í–∫–ª—é—á–µ–Ω–∞`;
                    vibrationToggleBtn.classList.remove('btn-danger');
                    vibrationToggleBtn.classList.add('btn-success');
                } else {
                    vibrationToggleBtn.innerHTML = `<i class="fas fa-times"></i> –í—ã–∫–ª—é—á–µ–Ω–∞`;
                    vibrationToggleBtn.classList.remove('btn-success');
                    vibrationToggleBtn.classList.add('btn-danger');
                }
            },
            vibrate(pattern) {
                if (this.enabled && 'vibrate' in navigator) {
                    try {
                         navigator.vibrate(pattern);
                    } catch (e) {
                        console.error("Vibration failed:", e);
                    }
                }
            },
            click: function() { this.vibrate(15); },
            shuffle: function() { this.vibrate([50, 30, 50]); },
            tileAppear: function() { this.vibrate(5); },
            win: function() { this.vibrate([100, 50, 100, 50, 100]); },
            error: function() { this.vibrate([70, 40, 70]); }
        };


        // Game variables
        let tiles = [];
        let emptyTileIndex = 0;
        let currentSize = 4;
        let highlightedTile = null;
        let autoHighlightInterval = null;
        let isAutoHighlighting = false;
        let currentTargetNumber = 1;
        let tileSize = 60;
        let tileGap = 8;
        let tileRadius = 10;
        let fontSize = 24;
        let currentScore = 0;
        let completedAchievements = [];
        let gameMode = 'classic';
        let timerInterval = null;
        let timeLeft = 0;
        let movesLeft = 0;
        let targetOrder = [];
        let obstacleTiles = new Set();
        let imageModeData = {
            imageUrl: '',
            image: null,
            canvas: null,
            ctx: null
        };
        let memoryRevealTimeout = null;
        let isTimeModeGameStarted = false;
        let darknessRevealedTiles = new Set();
        let teleportMoveCounter = 0;

        // Achievement Data
        const achievementsData = [
            { id: 'legend', title: '–õ–µ–≥–µ–Ω–¥–∞ –ü—è—Ç–Ω–∞—à–µ–∫', description: '–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –≤ –∏–≥—Ä–µ. –í—ã - –Ω–∞—Å—Ç–æ—è—â–∏–π –º–∞—Å—Ç–µ—Ä!', icon: 'fa-crown', points: 1000, condition: (stats) => completedAchievements.length >= (achievementsData.length - 1), progress: (stats) => Math.min(completedAchievements.length / (achievementsData.length - 1), 1) },
            { id: 'first_move', title: '–ü–µ—Ä–≤—ã–π —à–∞–≥', description: '–°–¥–µ–ª–∞–π—Ç–µ –ø–µ—Ä–≤—ã–π —Ö–æ–¥ –≤ –∏–≥—Ä–µ.', icon: 'fa-hand-point-right', points: 10, condition: (stats) => stats.totalMoves > 0, progress: (stats) => stats.totalMoves > 0 ? 1 : 0 },
            { id: 'first_win', title: '–ù–∞—á–∞–ª–æ –ø–æ–ª–æ–∂–µ–Ω–æ', description: '–ó–∞–≤–µ—Ä—à–∏—Ç–µ —Å–≤–æ—é –ø–µ—Ä–≤—É—é –∏–≥—Ä—É.', icon: 'fa-flag-checkered', points: 50, condition: (stats) => stats.totalGamesWon > 0, progress: (stats) => stats.totalGamesWon > 0 ? 1 : 0 },
            { id: 'shuffler_10', title: '–ü–µ—Ä–µ–º–µ—à–∏–≤–∞—Ç–µ–ª—å', description: '–ü–µ—Ä–µ–º–µ—à–∞–π—Ç–µ –ø–ª–∏—Ç–∫–∏ 10 —Ä–∞–∑.', icon: 'fa-random', points: 25, condition: (stats) => stats.shuffles >= 10, progress: (stats) => Math.min(stats.shuffles / 10, 1) },
            { id: 'explorer_10', title: '–õ—é–±–æ–ø—ã—Ç–Ω—ã–π', description: '–ù–∞–π–¥–∏—Ç–µ 10 —á–∏—Å–µ–ª —Å –ø–æ–º–æ—â—å—é –ø–æ–∏—Å–∫–∞.', icon: 'fa-search', points: 30, condition: (stats) => stats.numbersFound >= 10, progress: (stats) => Math.min(stats.numbersFound / 10, 1) },
            { id: 'color_changer', title: '–•—É–¥–æ–∂–Ω–∏–∫', description: '–ò–∑–º–µ–Ω–∏—Ç–µ –≤—Å–µ 5 —Ç–∏–ø–æ–≤ —Ü–≤–µ—Ç–æ–≤ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.', icon: 'fa-paint-brush', points: 20, condition: (stats) => stats.colorsChanged.size >= 5, progress: (stats) => Math.min(stats.colorsChanged.size / 5, 1) },
            { id: 'size_master_small', title: '–ú–∏–Ω–∏–∞—Ç—é—Ä–∏—Å—Ç', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –Ω–∞ –ø–æ–ª–µ 2x2.', icon: 'fa-compress-arrows-alt', points: 50, condition: (stats) => stats.gamesWonBySize[2] > 0, progress: (stats) => stats.gamesWonBySize[2] > 0 ? 1 : 0 },
            { id: 'size_master_big', title: '–ì—Ä–æ—Å—Å–º–µ–π—Å—Ç–µ—Ä', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –Ω–∞ –ø–æ–ª–µ 8x8.', icon: 'fa-expand-arrows-alt', points: 150, condition: (stats) => stats.gamesWonBySize[8] > 0, progress: (stats) => stats.gamesWonBySize[8] > 0 ? 1: 0 },
            { id: 'size_master_titanic', title: '–¢–∏—Ç–∞–Ω–∏—á–µ—Å–∫–∏–π –¢—Ä—É–¥', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –Ω–∞ –ø–æ–ª–µ 20x20.', icon: 'fa-globe-americas', points: 500, condition: (stats) => stats.gamesWonBySize[20] > 0, progress: (stats) => stats.gamesWonBySize[20] > 0 ? 1 : 0 },
            { id: 'size_master_all', title: '–ú–∞—Å—Ç–µ—Ä –†–∞–∑–º–µ—Ä–æ–≤', description: '–°—ã–≥—Ä–∞–π—Ç–µ –Ω–∞ 5 —Ä–∞–∑–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–∞—Ö –ø–æ–ª—è.', icon: 'fa-ruler-combined', points: 100, condition: (stats) => stats.playedSizes.size >= 5, progress: (stats) => Math.min(stats.playedSizes.size / 5, 1) },
            { id: 'mode_explorer', title: '–†–µ–∂–∏–º–Ω—ã–π –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å', description: '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ 5 —Ä–∞–∑–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤ –∏–≥—Ä—ã.', icon: 'fa-route', points: 100, condition: (stats) => stats.modesTried.size >= 5, progress: (stats) => Math.min(stats.modesTried.size / 5, 1) },
            { id: 'mode_master', title: '–ü–æ–≤–µ–ª–∏—Ç–µ–ª—å –†–µ–∂–∏–º–æ–≤', description: '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–µ–∂–∏–º—ã –∏–≥—Ä—ã.', icon: 'fa-dungeon', points: 250, condition: (stats) => stats.modesTried.size >= gameModes.length, progress: (stats) => Math.min(stats.modesTried.size / gameModes.length, 1) },
            { id: 'win_classic', title: '–ö–ª–∞—Å—Å–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π".', icon: 'fa-th', points: 20, condition: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[currentSize] && stats.gameRecords.classic[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[currentSize] && stats.gameRecords.classic[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_time', title: '–°–ø—Ä–∏–Ω—Ç–µ—Ä', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–ù–∞ –≤—Ä–µ–º—è".', icon: 'fa-stopwatch', points: 30, condition: (stats) => stats.gameRecords.time && stats.gameRecords.time[currentSize] && stats.gameRecords.time[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.time && stats.gameRecords.time[currentSize] && stats.gameRecords.time[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_moves', title: '–¢–∞–∫—Ç–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Ö–æ–¥–æ–≤".', icon: 'fa-shoe-prints', points: 30, condition: (stats) => stats.gameRecords.moves && stats.gameRecords.moves[currentSize] && stats.gameRecords.moves[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.moves && stats.gameRecords.moves[currentSize] && stats.gameRecords.moves[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_reverse', title: '–†–µ–≤–µ—Ä—Å–µ—Ä', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–û–±—Ä–∞—Ç–Ω—ã–π".', icon: 'fa-exchange-alt', points: 40, condition: (stats) => stats.gameRecords.reverse && stats.gameRecords.reverse[currentSize] && stats.gameRecords.reverse[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.reverse && stats.gameRecords.reverse[currentSize] && stats.gameRecords.reverse[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'collector_10', title: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 10 –∏–≥—Ä.', icon: 'fa-medal', points: 100, condition: (stats) => stats.totalGamesWon >= 10, progress: (stats) => Math.min(stats.totalGamesWon / 10, 1) },
            { id: 'collector_50', title: '–≠–Ω—Ç—É–∑–∏–∞—Å—Ç', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 50 –∏–≥—Ä.', icon: 'fa-award', points: 250, condition: (stats) => stats.totalGamesWon >= 50, progress: (stats) => Math.min(stats.totalGamesWon / 50, 1) },
            { id: 'mover_1k', title: '–ù–µ–ø–æ—Å–µ–¥–∞', description: '–°–¥–µ–ª–∞–π—Ç–µ 1000 —Ö–æ–¥–æ–≤.', icon: 'fa-walking', points: 50, condition: (stats) => stats.totalMoves >= 1000, progress: (stats) => Math.min(stats.totalMoves / 1000, 1) },
            { id: 'mover_10k', title: '–ú–∞—Ä–∞—Ñ–æ–Ω–µ—Ü', description: '–°–¥–µ–ª–∞–π—Ç–µ 10 000 —Ö–æ–¥–æ–≤.', icon: 'fa-running', points: 150, condition: (stats) => stats.totalMoves >= 10000, progress: (stats) => Math.min(stats.totalMoves / 10000, 1) },
            { id: 'score_1k', title: '–ù–∞–∫–æ–ø–∏—Ç–µ–ª—å', description: '–ù–∞–±–µ—Ä–∏—Ç–µ 1000 –æ—á–∫–æ–≤ (–±–µ–∑ —É—á–µ—Ç–∞ –æ—á–∫–æ–≤ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è).', icon: 'fa-coins', points: 50, condition: (stats) => stats.totalScore >= 1000, progress: (stats) => Math.min(stats.totalScore / 1000, 1) },
            { id: 'score_10k', title: '–ë–æ–≥–∞—á', description: '–ù–∞–±–µ—Ä–∏—Ç–µ 10 000 –æ—á–∫–æ–≤ (–±–µ–∑ —É—á–µ—Ç–∞ –æ—á–∫–æ–≤ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è).', icon: 'fa-gem', points: 150, condition: (stats) => stats.totalScore >= 10000, progress: (stats) => Math.min(stats.totalScore / 10000, 1) },
            { id: 'fast_solver_100', title: '–ë—ã—Å—Ç—Ä—ã–π —Ä–µ—à–∞—Ç–µ–ª—å', description: '–†–µ—à–∏—Ç–µ –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É 4x4 –º–µ–Ω–µ–µ —á–µ–º –∑–∞ 100 —Ö–æ–¥–æ–≤.', icon: 'fa-bolt', points: 75, condition: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[4] && stats.gameRecords.classic[4].bestMoves < 100, progress: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[4] ? Math.max(0, 1 - (stats.gameRecords.classic[4].bestMoves - 50) / 50) : 0 },
            { id: 'shuffler_50', title: '–•–∞–æ—Å-–º–µ–Ω–µ–¥–∂–µ—Ä', description: '–ü–µ—Ä–µ–º–µ—à–∞–π—Ç–µ –ø–ª–∏—Ç–∫–∏ 50 —Ä–∞–∑.', icon: 'fa-sync-alt', points: 50, condition: (stats) => stats.shuffles >= 50, progress: (stats) => Math.min(stats.shuffles / 50, 1) },
            { id: 'explorer_50', title: '–î–µ—Ç–µ–∫—Ç–∏–≤', description: '–ù–∞–π–¥–∏—Ç–µ 50 —á–∏—Å–µ–ª —Å –ø–æ–º–æ—â—å—é –ø–æ–∏—Å–∫–∞.', icon: 'fa-search-plus', points: 60, condition: (stats) => stats.numbersFound >= 50, progress: (stats) => Math.min(stats.numbersFound / 50, 1) },
            { id: 'autohighlight_user', title: '–ê–≤—Ç–æ–ø–∏–ª–æ—Ç', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É, –∏—Å–ø–æ–ª—å–∑—É—è –∞–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫—É.', icon: 'fa-robot', points: 30, condition: (stats) => stats.winsWithAutohighlight > 0, progress: (stats) => stats.winsWithAutohighlight > 0 ? 1 : 0 },
            { id: 'styler', title: '–°—Ç–∏–ª–∏—Å—Ç', description: '–ò–∑–º–µ–Ω–∏—Ç–µ —Ä–∞–∑–º–µ—Ä –ø–ª–∏—Ç–æ–∫, –∏—Ö –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∏ —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞.', icon: 'fa-magic', points: 25, condition: (stats) => stats.styleChanges.size >= 3, progress: (stats) => Math.min(stats.styleChanges.size / 3, 1) },
            { id: 'win_obstacle', title: '–ü—Ä–µ–æ–¥–æ–ª–µ–Ω–∏–µ', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏".', icon: 'fa-ban', points: 50, condition: (stats) => stats.gameRecords.obstacle && stats.gameRecords.obstacle[currentSize] && stats.gameRecords.obstacle[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.obstacle && stats.gameRecords.obstacle[currentSize] && stats.gameRecords.obstacle[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_memory', title: '–§–µ–Ω–æ–º–µ–Ω–∞–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –ø–∞–º—è—Ç—å—é".', icon: 'fa-brain', points: 60, condition: (stats) => stats.gameRecords.memory && stats.gameRecords.memory[currentSize] && stats.gameRecords.memory[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.memory && stats.gameRecords.memory[currentSize] && stats.gameRecords.memory[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_image', title: '–•—É–¥–æ–∂–Ω–∏–∫-–≥–æ–ª–æ–≤–æ–ª–æ–º—â–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –∫–∞—Ä—Ç–∏–Ω–∫–æ–π".', icon: 'fa-image', points: 80, condition: (stats) => stats.gameRecords.image && stats.gameRecords.image[currentSize] && stats.gameRecords.image[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.image && stats.gameRecords.image[currentSize] && stats.gameRecords.image[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_teleport', title: '–ú–∞—Å—Ç–µ—Ä —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–¢–µ–ª–µ–ø–æ—Ä—Ç".', icon: 'fa-random', points: 75, condition: (stats) => stats.gameRecords.teleport && stats.gameRecords.teleport[currentSize] && stats.gameRecords.teleport[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.teleport && stats.gameRecords.teleport[currentSize] && stats.gameRecords.teleport[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_vortex', title: '–ú–∞—Å—Ç–µ—Ä –≤–∏—Ö—Ä—è', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–í–∏—Ö—Ä—å".', icon: 'fa-wind', points: 80, condition: (stats) => stats.gameRecords.vortex && stats.gameRecords.vortex[currentSize] && stats.gameRecords.vortex[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.vortex && stats.gameRecords.vortex[currentSize] && stats.gameRecords.vortex[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_hidden_path', title: '–ü—Ä–æ–≤–æ–¥–Ω–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–°–∫—Ä—ã—Ç—ã–π –ø—É—Ç—å".', icon: 'fa-eye-slash', points: 85, condition: (stats) => stats.gameRecords.hidden_path && stats.gameRecords.hidden_path[currentSize] && stats.gameRecords.hidden_path[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.hidden_path && stats.gameRecords.hidden_path[currentSize] && stats.gameRecords.hidden_path[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_darkness', title: '–ù–æ—á–Ω–æ–π —Å—Ç—Ä–∞–Ω–Ω–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–¢–µ–º–Ω–æ—Ç–∞".', icon: 'fa-moon', points: 90, condition: (stats) => stats.gameRecords.darkness && stats.gameRecords.darkness[currentSize] && stats.gameRecords.darkness[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.darkness && stats.gameRecords.darkness[currentSize] && stats.gameRecords.darkness[currentSize].gamesPlayed > 0 ? 1 : 0 }
        ];

        // Game Modes Data
        const gameModes = [
            { id: 'classic', title: '–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π', description: '–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø—è—Ç–Ω–∞—à–∫–∏', icon: 'fa-th', active: true, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'time', title: '–ù–∞ –≤—Ä–µ–º—è', description: '–°–æ–±–µ—Ä–∏—Ç–µ –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É –∫–∞–∫ –º–æ–∂–Ω–æ –±—ã—Å—Ç—Ä–µ–µ', icon: 'fa-stopwatch', active: false, getLimits: (size) => ({ moves: Infinity, time: size * size * 5 }) },
            { id: 'moves', title: '–° –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Ö–æ–¥–æ–≤', description: '–°–æ–±–µ—Ä–∏—Ç–µ –∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ö–æ–¥–æ–≤', icon: 'fa-shoe-prints', active: false, getLimits: (size) => ({ moves: size * size * 15, time: Infinity }) },
            { id: 'reverse', title: '–û–±—Ä–∞—Ç–Ω—ã–π', description: '–ù–∞—á–Ω–∏—Ç–µ —Å —Å–æ–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ —Å–æ–±–µ—Ä–∏—Ç–µ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ', icon: 'fa-exchange-alt', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'image', title: '–° –∫–∞—Ä—Ç–∏–Ω–∫–æ–π', description: '–í–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä - —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è', icon: 'fa-image', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'obstacle', title: '–° –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏', description: '–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–ª–∏—Ç–∫–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ —Å–≤–æ–∏—Ö –º–µ—Å—Ç–∞—Ö', icon: 'fa-ban', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }), getObstacleCount: (size) => Math.max(1, Math.floor(size * size * 0.05)) },
            { id: 'teleport', title: '–¢–µ–ª–µ–ø–æ—Ä—Ç', description: '–ü—É—Å—Ç–∞—è —è—á–µ–π–∫–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ö–æ–¥–æ–≤', icon: 'fa-bolt', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }), teleportFrequency: (size) => Math.max(3, Math.floor(size * 1.5)) },
            { id: 'vortex', title: '–í–∏—Ö—Ä—å', description: '–ü—É—Å—Ç–∞—è –ø–ª–∏—Ç–∫–∞ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ö–æ–¥–∞', icon: 'fa-wind', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'hidden_path', title: '–°–∫—Ä—ã—Ç—ã–π –ø—É—Ç—å', description: '–í–∏–¥–Ω—ã —Ç–æ–ª—å–∫–æ –ø–ª–∏—Ç–∫–∏ –≤–æ–∫—Ä—É–≥ –ø—É—Å—Ç–æ–π —è—á–µ–π–∫–∏', icon: 'fa-eye-slash', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'darkness', title: '–¢–µ–º–Ω–æ—Ç–∞', description: '–ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –ø–ª–∏—Ç–æ–∫ —Å–∫—Ä—ã—Ç—ã, –∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–π –∏ —Å–æ—Å–µ–¥–Ω–∏—Ö', icon: 'fa-moon', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) }
        ];

        // Game Statistics
        let gameStats = {};
        
        function initializeStats() {
             gameStats = {
                currentMoves: 0, totalMoves: 0, totalScore: 0, achievementScore: 0, totalGamesWon: 0, shuffles: 0, numbersFound: 0, winsWithAutohighlight: 0,
                playedSizes: new Set(), colorsChanged: new Set(), styleChanges: new Set(), modesTried: new Set(['classic']), gamesWonBySize: {}, gameRecords: {} 
            };
            const maxSliderSize = parseInt(sizeSlider.max);
            gameModes.forEach(mode => {
                gameStats.gameRecords[mode.id] = {};
                for (let s = 2; s <= maxSliderSize; s++) {
                    gameStats.gameRecords[mode.id][s] = { gamesPlayed: 0, bestTime: Infinity, worstTime: 0, bestMoves: Infinity, worstMoves: 0 };
                }
            });
        }

        function initSliders() {
            sizeValue.textContent = sizeSlider.value;
            tileSizeValue.textContent = tileSizeSlider.value + 'px';
            tileRadiusValue.textContent = tileRadiusSlider.value + 'px';
            fontSizeValue.textContent = fontSizeSlider.value + 'px';
            sizeSlider.addEventListener('input', () => { sizeValue.textContent = sizeSlider.value; });
            tileSizeSlider.addEventListener('input', () => { tileSize = parseInt(tileSizeSlider.value); tileSizeValue.textContent = tileSize + 'px'; applyVisualUpdates(); gameStats.styleChanges.add('tileSize'); saveStats(); checkAchievements(); });
            tileRadiusSlider.addEventListener('input', () => { tileRadius = parseInt(tileRadiusSlider.value); tileRadiusValue.textContent = tileRadius + 'px'; applyVisualUpdates(); gameStats.styleChanges.add('tileRadius'); saveStats(); checkAchievements(); });
            fontSizeSlider.addEventListener('input', () => { fontSize = parseInt(fontSizeSlider.value); fontSizeValue.textContent = fontSize + 'px'; applyVisualUpdates(); gameStats.styleChanges.add('fontSize'); saveStats(); checkAchievements(); });
        }
        
        function applyVisualUpdates() {
            gameField.style.width = `${currentSize * (tileSize + tileGap)}px`;
            gameField.style.height = `${currentSize * (tileSize + tileGap)}px`;
            tiles.forEach(tile => {
                tile.style.width = tileSize + 'px';
                tile.style.height = tileSize + 'px';
                tile.style.borderRadius = tileRadius + 'px';
                tile.style.fontSize = fontSize + 'px';
            });
            renderTiles(currentSize, 'move');
        }

        function startTimer() {
            const currentMode = gameModes.find(mode => mode.id === gameMode);
            const limits = currentMode.getLimits(currentSize);
            timeLeft = limits.time; 
            updateScore(); 
            timerInterval = setInterval(() => {
                timeLeft--; 
                updateScore();
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endGame(false, '–í—Ä–µ–º—è –≤—ã—à–ª–æ!'); 
                }
            }, 1000);
        }

        function stopGameMechanisms() {
            clearInterval(timerInterval);
            timerInterval = null;
            stopAutoHighlight(); 
            clearTimeout(memoryRevealTimeout); 
            document.querySelectorAll('.tile.hidden-number.revealed').forEach(tile => { tile.classList.remove('revealed'); });
            document.querySelectorAll('.tile.darkness-hidden, .tile.hidden-path-hidden').forEach(tile => {
                tile.classList.remove('darkness-hidden', 'hidden-path-hidden');
                tile.style.backgroundColor = tileColorPicker.value;
                tile.style.color = textColorPicker.value;
            });
            darknessRevealedTiles.clear();
        }

        function createGame(size) {
            stopGameMechanisms(); 
            gameField.innerHTML = '';
            tiles = [];
            emptyTileIndex = size * size - 1;
            currentSize = size;
            currentScore = 0;
            gameStats.currentMoves = 0;
            isTimeModeGameStarted = false;
            timeLeft = 0;
            movesLeft = 0;
            obstacleTiles.clear();
            teleportMoveCounter = 0;
            const currentMode = gameModes.find(mode => mode.id === gameMode);
            const limits = currentMode.getLimits(currentSize);
            if (gameMode === 'moves') { movesLeft = limits.moves; }
            else if (gameMode === 'time') { timeLeft = limits.time; hintMessage.classList.add('active'); }
            else { hintMessage.classList.remove('active'); }
            if (gameMode === 'reverse') { targetOrder = Array.from({length: size * size - 1}, (_, i) => size * size - 1 - i); }
            else { targetOrder = Array.from({length: size * size - 1}, (_, i) => i + 1); }
            gameStats.playedSizes.add(size);
            saveStats();
            checkAchievements();
            gameField.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            gameField.style.gridTemplateRows = `repeat(${size}, 1fr)`;
            gameField.style.width = `${size * (tileSize + tileGap)}px`;
            gameField.style.height = `${size * (tileSize + tileGap)}px`;
            gameField.style.gap = tileGap + 'px';
            for (let i = 1; i <= size * size - 1; i++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.id = `tile-${i}`;
                const tileInner = document.createElement('div');
                tileInner.className = 'tile-inner';
                tileInner.textContent = i;
                tile.appendChild(tileInner);
                tile.style.width = tileSize + 'px';
                tile.style.height = tileSize + 'px';
                tile.style.borderRadius = tileRadius + 'px';
                tile.style.fontSize = fontSize + 'px';
                tile.style.color = textColorPicker.value;
                tile.style.opacity = 0;
                tiles.push(tile);
                gameField.appendChild(tile);
            }
            const emptyTile = document.createElement('div');
            emptyTile.className = 'empty-tile';
            emptyTile.id = 'empty-tile';
            tiles.push(emptyTile);
            gameField.appendChild(emptyTile);
            updateScore();
        }

        function updateScore() {
            scoreDisplay.innerHTML = `<i class="fas fa-star"></i> <span>–û—á–∫–∏: ${currentScore}</span>`;
            let statusText = '';
            if (gameMode === 'time') {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                statusText = `<i class="fas fa-clock"></i> <span>–í—Ä–µ–º—è: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}</span>`;
            } else if (gameMode === 'moves') {
                statusText = `<i class="fas fa-shoe-prints"></i> <span>–•–æ–¥—ã: ${movesLeft}</span>`;
            } else { 
                statusText = `<i class="fas fa-shoe-prints"></i> <span>–•–æ–¥—ã: ${gameStats.currentMoves}</span>`;
            }
            gameStatusDisplay.innerHTML = statusText;
        }

        function addScore(points) {
            currentScore += points;
            updateScore();
        }

        function highlightNumber(number) {
            if (highlightedTile) {
                highlightedTile.classList.remove('highlight');
                highlightedTile.style.backgroundColor = tileColorPicker.value;
                highlightedTile.style.color = textColorPicker.value;
            }
            if (!number || number < 1 || number > currentSize * currentSize - 1) return;
            highlightedTile = Array.from(document.querySelectorAll('.tile')).find(tile => !tile.classList.contains('empty-tile') && tile.querySelector('.tile-inner')?.textContent == number);
            if (highlightedTile) {
                highlightedTile.classList.add('highlight');
                highlightedTile.style.backgroundColor = highlightColorPicker.value;
                highlightedTile.style.color = getContrastColor(highlightColorPicker.value);
                gameStats.numbersFound++;
                saveStats();
                checkAchievements();
            }
        }

        function getContrastColor(hexColor) {
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128 ? '#000000' : '#FFFFFF';
        }

        function checkTilePositions() {
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            for (let num = 0; num < checkTargetOrder.length; num++) {
                const expectedValue = checkTargetOrder[num]; 
                const currentTileAtPosition = tiles.find(t => t.querySelector('.tile-inner')?.textContent == expectedValue);
                if (currentTileAtPosition) {
                    const currentTileIndex = tiles.indexOf(currentTileAtPosition);
                    if (currentTileIndex !== num) { 
                        currentTargetNumber = expectedValue; 
                        return currentTargetNumber;
                    }
                } else {
                    const tileAtCurrentIndexValue = tiles[num].querySelector('.tile-inner')?.textContent;
                    if (parseInt(tileAtCurrentIndexValue) !== expectedValue) {
                         currentTargetNumber = expectedValue;
                         return currentTargetNumber;
                    }
                }
            }
            stopAutoHighlight();
            if (checkWin(currentSize)) { endGame(true, '–ü–æ–±–µ–¥–∞ —á–µ—Ä–µ–∑ –∞–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫—É!'); }
            return null;
        }

        function autoHighlightNext() {
            if (isAutoHighlighting) return;
            isAutoHighlighting = true;
            autoHighlightBtn.classList.add('active');
            autoHighlightBtn.innerHTML = '<i class="fas fa-stop"></i> –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å';
            currentTargetNumber = 1;
            const firstNumber = checkTilePositions();
            if (firstNumber) { highlightNumber(firstNumber); }
            autoHighlightInterval = setInterval(() => {
                const nextNumber = checkTilePositions();
                if (nextNumber) { highlightNumber(nextNumber); }
            }, 1000);
        }

        function stopAutoHighlight() {
            isAutoHighlighting = false;
            clearInterval(autoHighlightInterval);
            autoHighlightBtn.classList.remove('active');
            autoHighlightBtn.innerHTML = '<i class="fas fa-magic"></i> –ê–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫–∞';
            if (highlightedTile) {
                highlightedTile.classList.remove('highlight');
                highlightedTile.style.backgroundColor = tileColorPicker.value;
                highlightedTile.style.color = textColorPicker.value;
                highlightedTile = null;
            }
        }

        function toggleAutoHighlight() {
            if (isAutoHighlighting) { stopAutoHighlight(); } else { autoHighlightNext(); }
        }

        function shuffleTiles(isInitialShuffle = false) {
            stopGameMechanisms();
            gameStats.shuffles++;
            saveStats();
            checkAchievements();
            const numbers = Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            let tempTiles = [...tiles.filter(t => !t.classList.contains('empty-tile'))];
            let solvable = false;
            while (!solvable) {
                for (let i = tempTiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tempTiles[i], tempTiles[j]] = [tempTiles[j], tempTiles[i]];
                }
                let valuesForSolvabilityCheck = tempTiles.map(t => parseInt(t.querySelector('.tile-inner')?.textContent));
                valuesForSolvabilityCheck.push(currentSize * currentSize); 
                solvable = isSolvable(valuesForSolvabilityCheck, currentSize, currentSize * currentSize - 1); 
            }
            const emptyTileElement = tiles.find(t => t.classList.contains('empty-tile'));
            tiles = [...tempTiles, emptyTileElement];
            emptyTileIndex = tiles.length - 1; 
            applyModeSpecificStylesAndLogic();

            if (isInitialShuffle) {
                renderTiles(currentSize, 'initial');
            } else {
                renderTiles(currentSize, 'shuffle');
            }
        }

        function applyModeSpecificStylesAndLogic() {
            tiles.forEach(tile => {
                tile.classList.remove('obstacle-tile', 'hidden-number', 'revealed', 'darkness-hidden', 'hidden-path-hidden');
                tile.style.backgroundImage = '';
                tile.style.backgroundSize = '';
                tile.style.backgroundPosition = '';
                const tileInner = tile.querySelector('.tile-inner');
                if (tileInner) {
                    tileInner.style.display = 'flex';
                    tile.style.backgroundColor = tileColorPicker.value;
                    tile.style.color = textColorPicker.value;
                }
                tile.style.pointerEvents = 'auto';
            });
            obstacleTiles.clear();
            darknessRevealedTiles.clear();
            teleportMoveCounter = 0;
            if (gameMode === 'obstacle') {
                const currentMode = gameModes.find(mode => mode.id === gameMode);
                const count = currentMode.getObstacleCount(currentSize);
                let obstaclesAdded = 0;
                const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
                for (let i = 0; i < tiles.length - 1 && obstaclesAdded < count; i++) {
                    const tile = tiles[i];
                    const tileValue = parseInt(tile.querySelector('.tile-inner')?.textContent);
                    if (tileValue === checkTargetOrder[i]) {
                        tile.classList.add('obstacle-tile');
                        obstacleTiles.add(tile.id);
                        tile.style.pointerEvents = 'none';
                        obstaclesAdded++;
                    }
                }
            }
            if (gameMode === 'memory') {
                tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.add('hidden-number'); } });
                const currentMode = gameModes.find(mode => mode.id === gameMode);
                setTimeout(() => {
                    tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.add('revealed'); } });
                    memoryRevealTimeout = setTimeout(() => {
                        tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.remove('revealed'); } });
                    }, currentMode.revealTime);
                }, 500); 
            }
            if (gameMode === 'image' && imageModeData.image) { applyImageToTiles(); }
            if (gameMode === 'darkness') {
                tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.add('darkness-hidden'); } });
                revealDarknessTiles(emptyTileIndex);
            }
            if (gameMode === 'hidden_path') {
                tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.add('hidden-path-hidden'); } });
                updateHiddenPathTiles(emptyTileIndex);
            }
        }

        function isSolvable(arr, size, emptyTileVal) {
            let inversions = 0;
            const puzzleArray = arr.filter(n => !isNaN(n) && n !== emptyTileVal);
            for (let i = 0; i < puzzleArray.length - 1; i++) {
                for (let j = i + 1; j < puzzleArray.length; j++) {
                    if (puzzleArray[i] > puzzleArray[j]) { inversions++; }
                }
            }
            const emptyTileCurrentPos = tiles.findIndex(t => t.classList.contains('empty-tile'));
            const emptyRowFromBottom = size - Math.floor(emptyTileCurrentPos / size); 
            if (size % 2 === 1) { return inversions % 2 === 0; }
            else { 
                if (emptyRowFromBottom % 2 === 1) { return inversions % 2 === 0; }
                else { return inversions % 2 === 1; }
            }
        }

        function isValidMove(fromIndex, toIndex, size) {
            const rowDiff = Math.abs(Math.floor(fromIndex / size) - Math.floor(toIndex / size));
            const colDiff = Math.abs((fromIndex % size) - (toIndex % size));
            return rowDiff + colDiff === 1;
        }

        function checkCompletedLines(size) {
            let completedLines = 0;
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            for (let row = 0; row < size; row++) {
                let isRowComplete = true;
                for (let col = 0; col < size; col++) {
                    const index = row * size + col;
                    if (index === emptyTileIndex) { isRowComplete = false; break; }
                    const expectedNumber = checkTargetOrder[index];
                    const tileContent = tiles[index].querySelector('.tile-inner')?.textContent;
                    const tileValue = gameMode === 'image' ? parseInt(tiles[index].id.replace('tile-', '')) : parseInt(tileContent);
                    if (tileValue !== expectedNumber) { isRowComplete = false; break; }
                }
                if (isRowComplete) completedLines++;
            }
            for (let col = 0; col < size; col++) {
                let isColComplete = true;
                for (let row = 0; row < size; row++) {
                    const index = row * size + col;
                    if (index === emptyTileIndex) { isColComplete = false; break; }
                    const expectedNumber = checkTargetOrder[index];
                    const tileContent = tiles[index].querySelector('.tile-inner')?.textContent;
                    const tileValue = gameMode === 'image' ? parseInt(tiles[index].id.replace('tile-', '')) : parseInt(tileContent);
                    if (tileValue !== expectedNumber) { isColComplete = false; break; }
                }
                if (isColComplete) completedLines++;
            }
            return completedLines;
        }

        async function moveTile(tileIndex, size) {
            if (tileIndex === emptyTileIndex) return;
            if (gameMode === 'obstacle' && obstacleTiles.has(tiles[tileIndex].id)) { return; }
            if (isValidMove(tileIndex, emptyTileIndex, size)) {
                if (gameMode === 'time' && !isTimeModeGameStarted) {
                    isTimeModeGameStarted = true;
                    hintMessage.classList.remove('active');
                    startTimer();
                }
                [tiles[emptyTileIndex], tiles[tileIndex]] = [tiles[tileIndex], tiles[emptyTileIndex]];
                emptyTileIndex = tileIndex;
                if (gameMode === 'teleport') { await applyTeleport(); }
                else if (gameMode === 'vortex') { await applyVortex(); }
                renderTiles(size, 'move');
                gameStats.currentMoves++;
                gameStats.totalMoves++;
                addScore(1);
                if (gameMode === 'moves') {
                    movesLeft--;
                    if (movesLeft <= 0 && !checkWin(size)) { endGame(false, '–•–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å!'); return; }
                }
                if (gameMode === 'memory') {
                    const currentMode = gameModes.find(mode => mode.id === gameMode);
                    const movedTile = tiles[tileIndex];
                    movedTile.classList.add('revealed');
                    clearTimeout(memoryRevealTimeout); 
                    memoryRevealTimeout = setTimeout(() => { movedTile.classList.remove('revealed'); }, currentMode.revealTime);
                }
                if (gameMode === 'darkness') { revealDarknessTiles(emptyTileIndex); }
                if (gameMode === 'hidden_path') { updateHiddenPathTiles(emptyTileIndex); }
                saveStats();
                checkAchievements();
                const completedLines = checkCompletedLines(size);
                if (completedLines > 0) { addScore(completedLines * 10); }
                const movedTile = tiles[tileIndex];
                const tileContent = movedTile.querySelector('.tile-inner')?.textContent;
                const expectedForHighlight = (gameMode === 'reverse') ? targetOrder[tileIndex] : (tileIndex + 1);
                if (tileContent && parseInt(tileContent) === expectedForHighlight) {
                    movedTile.classList.add('correct-position');
                    setTimeout(() => { movedTile.classList.remove('correct-position'); }, 1000);
                }
                highlightCorrectTiles(size); 
                updateScore(); 
                if (isAutoHighlighting) {
                    const nextNumber = checkTilePositions();
                    if (nextNumber) { highlightNumber(nextNumber); }
                }
                if (checkWin(size)) { endGame(true, `–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –í—ã —Å–æ–±—Ä–∞–ª–∏ –≤—Å–µ –ø–ª–∏—Ç–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ!\n–í–∞—à —Å—á–µ—Ç: ${currentScore}\n–•–æ–¥–æ–≤ —Å–¥–µ–ª–∞–Ω–æ: ${gameStats.currentMoves}`); }
            }
        }

        async function applyTeleport() {
            teleportMoveCounter++;
            const currentMode = gameModes.find(mode => mode.id === 'teleport');
            const frequency = currentMode.teleportFrequency(currentSize);
            if (teleportMoveCounter >= frequency) {
                teleportMoveCounter = 0;
                const oldEmptyIndex = emptyTileIndex;
                const availableSpots = tiles.map((tile, index) => index).filter(index => index !== oldEmptyIndex && !tiles[index].classList.contains('obstacle-tile'));
                if (availableSpots.length > 0) {
                    const newEmptyIndex = availableSpots[Math.floor(Math.random() * availableSpots.length)];
                    [tiles[oldEmptyIndex], tiles[newEmptyIndex]] = [tiles[newEmptyIndex], tiles[oldEmptyIndex]];
                    emptyTileIndex = newEmptyIndex;
                    renderTiles(currentSize);
                    await new Promise(resolve => setTimeout(resolve, 150));
                }
            }
        }

        async function applyVortex() {
            const emptyRow = Math.floor(emptyTileIndex / currentSize);
            const emptyCol = emptyTileIndex % currentSize;
            const possibleMoves = [];
            if (emptyRow > 0) possibleMoves.push(emptyTileIndex - currentSize);
            if (emptyRow < currentSize - 1) possibleMoves.push(emptyTileIndex + currentSize);
            if (emptyCol > 0) possibleMoves.push(emptyTileIndex - 1);
            if (emptyCol < currentSize - 1) possibleMoves.push(emptyTileIndex + 1);
            if (possibleMoves.length > 0) {
                const validMoves = possibleMoves.filter(index => !tiles[index].classList.contains('obstacle-tile'));
                if (validMoves.length > 0) {
                    const randomIndex = validMoves[Math.floor(Math.random() * validMoves.length)];
                    [tiles[emptyTileIndex], tiles[randomIndex]] = [tiles[randomIndex], tiles[emptyTileIndex]];
                    emptyTileIndex = randomIndex;
                    renderTiles(currentSize);
                    await new Promise(resolve => setTimeout(resolve, 150));
                }
            }
        }

        function revealDarknessTiles(centerIndex) {
            const centerRow = Math.floor(centerIndex / currentSize);
            const centerCol = centerIndex % currentSize;
            const offsets = [ [-1, -1], [-1, 0], [-1, 1], [0, -1],  [0, 0], [0, 1], [1, -1],  [1, 0], [1, 1] ];
            const newlyRevealedIndexes = new Set();
            for (const [dr, dc] of offsets) {
                const checkRow = centerRow + dr;
                const checkCol = centerCol + dc;
                if (checkRow >= 0 && checkRow < currentSize && checkCol >= 0 && checkCol < currentSize) {
                    newlyRevealedIndexes.add(checkRow * currentSize + checkCol);
                }
            }
            tiles.forEach((tile, index) => {
                 if (!tile.classList.contains('empty-tile')) {
                    if(newlyRevealedIndexes.has(index)) { tile.classList.remove('darkness-hidden'); }
                    else { tile.classList.add('darkness-hidden'); }
                 }
            });
        }

        function updateHiddenPathTiles(emptyIndex) {
            const emptyRow = Math.floor(emptyIndex / currentSize);
            const emptyCol = emptyIndex % currentSize;
            const adjacentOffsets = [ [-1, 0], [1, 0], [0, -1], [0, 1] ];
            const visibleIndexes = new Set();
            for (const [dr, dc] of adjacentOffsets) {
                const checkRow = emptyRow + dr;
                const checkCol = emptyCol + dc;
                if (checkRow >= 0 && checkRow < currentSize && checkCol >= 0 && checkCol < currentSize) {
                    visibleIndexes.add(checkRow * currentSize + checkCol);
                }
            }
            tiles.forEach((tile, index) => {
                if(!tile.classList.contains('empty-tile')) {
                    if (visibleIndexes.has(index)) { tile.classList.remove('hidden-path-hidden'); }
                    else { tile.classList.add('hidden-path-hidden'); }
                }
            });
        }

        function checkWin(size) {
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            for (let i = 0; i < size * size - 1; i++) {
                const tileContent = tiles[i].querySelector('.tile-inner')?.textContent;
                const tileValue = gameMode === 'image' ? parseInt(tiles[i].id.replace('tile-', '')) : parseInt(tileContent);
                if (tileValue !== checkTargetOrder[i]) { return false; }
            }
            return true;
        }

        function endGame(win, message) {
            stopGameMechanisms(); 
            if (win) {
                vibrationManager.win();
                showWinAnimation(); 
            } else {
                vibrationManager.error();
                showMessageModal('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!', message + '\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑!', () => { shuffleTiles(); });
            }
        }

        function showWinAnimation() {
            gameStats.totalGamesWon++;
            gameStats.totalScore += currentScore;
            if (!gameStats.gamesWonBySize[currentSize]) { gameStats.gamesWonBySize[currentSize] = 0; }
            gameStats.gamesWonBySize[currentSize]++;
            const currentRecord = gameStats.gameRecords[gameMode][currentSize];
            currentRecord.gamesPlayed++;
            if (gameMode === 'time') {
                const timeTaken = gameModes.find(mode => mode.id === gameMode).getLimits(currentSize).time - timeLeft;
                if (timeTaken < currentRecord.bestTime) currentRecord.bestTime = timeTaken;
                if (currentRecord.worstTime === 0 || timeTaken > currentRecord.worstTime) currentRecord.worstTime = timeTaken;
            } else { 
                const movesTaken = gameStats.currentMoves;
                if (movesTaken < currentRecord.bestMoves) currentRecord.bestMoves = movesTaken;
                if (currentRecord.worstMoves === 0 || movesTaken > currentRecord.worstMoves) currentRecord.worstMoves = movesTaken;
            }
            if (isAutoHighlighting) { gameStats.winsWithAutohighlight++; }
            saveStats();
            checkAchievements();
            renderStatistics();
            createConfetti();
            setTimeout(() => {
                showMessageModal('üéâ –ü–æ–±–µ–¥–∞!', `–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –í—ã —Å–æ–±—Ä–∞–ª–∏ –≤—Å–µ –ø–ª–∏—Ç–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ!\n–í–∞—à —Å—á–µ—Ç: ${currentScore}\n–•–æ–¥–æ–≤ —Å–¥–µ–ª–∞–Ω–æ: ${gameStats.currentMoves}`, () => { shuffleTiles(true); });
            }, 1000);
        }

        function createConfetti() {
            const colors = ['#fd79a8', '#74b9ff', '#55efc4', '#ffeaa7', '#a29bfe'];
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = Math.random() * 10 + 5 + 'px';
                confetti.style.height = Math.random() * 10 + 5 + 'px';
                confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
                confetti.style.animationDelay = Math.random() * 2 + 's';
                document.body.appendChild(confetti);
                setTimeout(() => { confetti.remove(); }, 5000);
            }
        }

        // ‚ú® –ò–°–ü–†–ê–í–õ–ï–ù–û: –§—É–Ω–∫—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ —Ç–µ–ø–µ—Ä—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–∞–∑–¥–µ–ª—è–µ—Ç –∞–Ω–∏–º–∞—Ü–∏–∏
        function renderTiles(size, animationType = 'move') {
            if (animationType === 'initial') {
                // –í–æ–∑–≤—Ä–∞—â–µ–Ω–∞ —Å—Ç–∞—Ä–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—è
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / size);
                    const col = index % size;
                    const targetX = col * (tileSize + tileGap);
                    const targetY = row * (tileSize + tileGap);

                    tile.style.transition = 'none';
                    tile.style.transform = `translate(${targetX}px, ${targetY - 20}px)`; 
                    tile.style.opacity = 0;

                    const delay = index * 25; // –¢–∞ —Å–∞–º–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ "–∑–º–µ–π–∫–∏"
                    setTimeout(() => {
                        tile.style.transition = 'transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease';
                        tile.style.transform = `translate(${targetX}px, ${targetY}px)`;
                        tile.style.opacity = 1;
                        vibrationManager.tileAppear();
                    }, delay);
                });
            } else if (animationType === 'shuffle') {
                // "–õ–µ—Ç–∞—é—â–∞—è" –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è
                vibrationManager.shuffle();
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / size);
                    const col = index % size;
                    const targetX = col * (tileSize + tileGap);
                    const targetY = row * (tileSize + tileGap);
                    tile.style.opacity = 1; 
                    const randomDelay = Math.random() * 200;
                    tile.style.transition = `transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) ${randomDelay}ms`;
                    tile.style.transform = `translate(${targetX}px, ${targetY}px)`;
                });
            } else { // 'move'
                // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è —Ö–æ–¥–æ–≤ –∏–≥—Ä–æ–∫–∞
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / size);
                    const col = index % size;
                    const targetX = col * (tileSize + tileGap);
                    const targetY = row * (tileSize + tileGap);
                    tile.style.transition = `transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease`;
                    tile.style.transform = `translate(${targetX}px, ${targetY}px)`;
                    tile.style.opacity = 1;
                });
            }
            highlightCorrectTiles(currentSize);
        }

        function highlightCorrectTiles(size) {
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            tiles.forEach((tile, index) => {
                const tileInner = tile.querySelector('.tile-inner');
                if (tileInner || gameMode === 'image') { 
                    const tileValue = gameMode === 'image' ? parseInt(tile.id.replace('tile-', '')) : parseInt(tileInner.textContent);
                    let isCorrect = (tileValue === checkTargetOrder[index]);
                    if (isCorrect) {
                        tile.classList.add('correct');
                        tile.style.borderColor = correctColorPicker.value;
                    } else {
                        tile.classList.remove('correct');
                        tile.style.borderColor = 'transparent';
                    }
                }
            });
        }
        
        function updateColors(colorType) {
            document.body.style.backgroundColor = bgColorPicker.value;
            document.body.style.color = getContrastColor(bgColorPicker.value);
            gameField.style.borderColor = borderColorPicker.value;
            tiles.forEach(tile => {
                if (!tile.classList.contains('empty-tile') && !tile.classList.contains('obstacle-tile') && !tile.classList.contains('darkness-hidden') && !tile.classList.contains('hidden-path-hidden')) {
                    tile.style.backgroundColor = tileColorPicker.value;
                    tile.style.color = textColorPicker.value;
                }
            });
            highlightCorrectTiles(currentSize);
            gameStats.colorsChanged.add(colorType);
            saveStats();
            checkAchievements();
        }

        function saveStats() {
            const statsToSave = { ...gameStats, playedSizes: Array.from(gameStats.playedSizes), colorsChanged: Array.from(gameStats.colorsChanged), styleChanges: Array.from(gameStats.styleChanges), modesTried: Array.from(gameStats.modesTried) };
            localStorage.setItem('gameStats_v9', JSON.stringify(statsToSave)); 
            localStorage.setItem('completedAchievements_v9', JSON.stringify(completedAchievements)); 
        }

        function loadStats() {
            const savedStats = localStorage.getItem('gameStats_v9');
            const savedAchievements = localStorage.getItem('completedAchievements_v9');
            initializeStats(); 
            if (savedStats) {
                const parsedStats = JSON.parse(savedStats);
                Object.assign(gameStats, parsedStats);
                gameStats.playedSizes = new Set(parsedStats.playedSizes || []);
                gameStats.colorsChanged = new Set(parsedStats.colorsChanged || []);
                gameStats.styleChanges = new Set(parsedStats.styleChanges || []);
                gameStats.modesTried = new Set(parsedStats.modesTried || ['classic']);
                if (parsedStats.gameRecords) {
                    for (const modeId in gameStats.gameRecords) {
                        if (parsedStats.gameRecords[modeId]) {
                            for (const size in gameStats.gameRecords[modeId]) {
                                if (parsedStats.gameRecords[modeId][size]) {
                                    Object.assign(gameStats.gameRecords[modeId][size], parsedStats.gameRecords[modeId][size]);
                                }
                            }
                        }
                    }
                }
            }
            if (savedAchievements) { completedAchievements = JSON.parse(savedAchievements); }
            calculateAchievementScore();
            renderAchievements();
            renderStatistics();
        }

        function calculateAchievementScore() {
            let total = 0;
            completedAchievements.forEach(achId => {
                const achievement = achievementsData.find(a => a.id === achId);
                if (achievement) { total += achievement.points; }
            });
            gameStats.achievementScore = total;
            saveStats();
        }

        function checkAchievements() {
            let changed = false;
            achievementsData.forEach(achievement => {
                if (!completedAchievements.includes(achievement.id) && achievement.condition(gameStats)) {
                    completedAchievements.push(achievement.id);
                    showAchievementUnlocked(achievement);
                    gameStats.achievementScore += achievement.points;
                    changed = true;
                }
            });
            if(changed) { saveStats(); renderAchievements(); renderStatistics(); }
        }

        function showAchievementUnlocked(achievement) {
            const notification = document.createElement('div');
            notification.className = 'achievement-notification';
            notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: white; padding: 15px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); display: flex; align-items: center; gap: 15px; z-index: 1000; transform: translateX(200%); transition: transform 0.5s ease;';
            notification.innerHTML = `<div class="achievement-icon" style="background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.5rem;"><i class="fas ${achievement.icon}"></i></div><div><div style="font-weight: bold; color: var(--primary-color);">–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ!</div><div style="font-weight: 600; margin: 5px 0;">${achievement.title}</div><div style="font-size: 0.9rem; color: #636e72;">+${achievement.points} –æ—á–∫–æ–≤</div></div>`;
            document.body.appendChild(notification);
            setTimeout(() => { notification.style.transform = 'translateX(0)'; }, 100);
            setTimeout(() => { notification.style.transform = 'translateX(200%)'; setTimeout(() => { notification.remove(); }, 500); }, 5000);
        }

        function renderAchievements() {
            achievementsGrid.innerHTML = '';
            achievementsData.forEach(achievement => {
                const isCompleted = completedAchievements.includes(achievement.id);
                const progress = achievement.progress(gameStats);
                const card = document.createElement('div');
                card.className = `achievement-card ${isCompleted ? '' : 'locked'}`;
                card.innerHTML = `<div class="achievement-icon"><i class="fas ${achievement.icon}"></i></div><div class="achievement-title">${achievement.title}</div><div class="achievement-desc">${achievement.description}</div><div class="achievement-progress"><div class="progress-bar" style="width: ${progress * 100}%"></div></div><div class="achievement-points">+${achievement.points} –æ—á–∫–æ–≤</div>${isCompleted ? '<div class="ribbon">–ü–æ–ª—É—á–µ–Ω–æ!</div>' : ''}`;
                achievementsGrid.appendChild(card);
            });
        }
        
        function renderStatistics() {
            statsGrid.innerHTML = `<div class="stats-card"><i class="fas fa-gamepad stats-icon"></i><div class="stats-value">${gameStats.totalGamesWon}</div><div class="stats-label">–°–æ–±—Ä–∞–Ω–æ –∏–≥—Ä</div></div><div class="stats-card"><i class="fas fa-arrows-alt-h stats-icon"></i><div class="stats-value">${gameStats.totalMoves}</div><div class="stats-label">–ü–µ—Ä–µ–¥–≤–∏–Ω—É—Ç–æ –ø–ª–∏—Ç–æ–∫</div></div><div class="stats-card"><i class="fas fa-coins stats-icon"></i><div class="stats-value">${gameStats.totalScore}</div><div class="stats-label">–û—á–∫–æ–≤ –ø–æ–ª—É—á–µ–Ω–æ</div></div><div class="stats-card"><i class="fas fa-trophy stats-icon"></i><div class="stats-value">${gameStats.achievementScore}</div><div class="stats-label">–û—á–∫–∏ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è</div></div><div class="stats-list-card"><h3>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ä–µ–∂–∏–º–∞–º –∏ —Ä–∞–∑–º–µ—Ä–∞–º:</h3><ul class="stats-list" id="statsModeSizeList"></ul></div>`;
            const modeSizeList = document.getElementById('statsModeSizeList');
            gameModes.forEach(mode => {
                const modeLi = document.createElement('li');
                modeLi.innerHTML = `<span class="stats-list-label">${mode.title}</span><span class="stats-list-value"></span>`;
                modeSizeList.appendChild(modeLi);
                const subList = document.createElement('ul');
                subList.className = 'stats-sub-list';
                modeLi.appendChild(subList);
                const sortedSizes = Object.keys(gameStats.gameRecords[mode.id]).sort((a,b) => parseInt(a) - parseInt(b));
                let modeHasData = false;
                sortedSizes.forEach(size => {
                    const record = gameStats.gameRecords[mode.id][size];
                    if (record.gamesPlayed > 0) {
                        modeHasData = true;
                        const sizeLi = document.createElement('li');
                        let statsHtml = `<span>–ü–æ–ª–µ ${size}x${size}:</span><span>–ò–≥—Ä: ${record.gamesPlayed}`;
                        if (record.bestMoves !== Infinity) { statsHtml += `, –•–æ–¥—ã: ${record.bestMoves}`; if (record.worstMoves !== 0 && record.worstMoves !== Infinity && record.worstMoves !== record.bestMoves) { statsHtml += ` (—Ö—É–¥—à: ${record.worstMoves})`; } }
                        if (record.bestTime !== Infinity) {
                            const bestMin = Math.floor(record.bestTime / 60); const bestSec = record.bestTime % 60; const worstMin = Math.floor(record.worstTime / 60); const worstSec = record.worstTime % 60;
                            statsHtml += `, –í—Ä–µ–º—è: ${bestMin.toString().padStart(2, '0')}:${bestSec.toString().padStart(2, '0')}`;
                            if (record.worstTime !== 0 && record.worstTime !== Infinity && record.worstTime !== record.bestTime) { statsHtml += ` (—Ö—É–¥—à: ${worstMin.toString().padStart(2, '0')}:${worstSec.toString().padStart(2, '0')})`; }
                        }
                        statsHtml += `</span>`;
                        sizeLi.innerHTML = statsHtml;
                        subList.appendChild(sizeLi);
                    }
                });
                if (!modeHasData) {
                    const noDataLi = document.createElement('li');
                    noDataLi.textContent = '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç—Ç–æ–≥–æ —Ä–µ–∂–∏–º–∞.';
                    subList.appendChild(noDataLi);
                }
            });
        }

        function renderModes() {
            modesGrid.innerHTML = '';
            gameModes.forEach(mode => {
                const card = document.createElement('div');
                card.className = `mode-card ${mode.active ? 'active' : ''}`;
                card.dataset.mode = mode.id;
                card.innerHTML = `<div class="mode-icon"><i class="fas ${mode.icon}"></i></div><div class="mode-title">${mode.title}</div><div class="mode-desc">${mode.description}</div>`;
                if (mode.id === 'image') {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'input-group';
                    inputGroup.style.marginTop = '10px';
                    const imageInput = document.createElement('input');
                    imageInput.type = 'file';
                    imageInput.accept = 'image/*';
                    imageInput.id = 'image-upload-input';
                    imageInput.addEventListener('change', (e) => { loadImageForMode(e.target.files[0]); });
                    const imageLabel = document.createElement('label');
                    imageLabel.htmlFor = 'image-upload-input';
                    imageLabel.className = 'btn btn-block';
                    imageLabel.innerHTML = '<i class="fas fa-upload"></i> –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª';
                    inputGroup.appendChild(imageInput);
                    inputGroup.appendChild(imageLabel);
                    card.appendChild(inputGroup);
                }
                card.addEventListener('click', (e) => {
                    if (e.target.closest('label[for="image-upload-input"]')) { return; }
                    setActiveMode(mode.id);
                });
                modesGrid.appendChild(card);
            });
        }

        function setActiveMode(modeId) {
            gameMode = modeId;
            gameStats.modesTried.add(modeId);
            saveStats();
            checkAchievements();
            gameModes.forEach(mode => { mode.active = (mode.id === modeId); });
            document.querySelectorAll('.mode-card').forEach(card => { card.classList.toggle('active', card.dataset.mode === modeId); });
            createGame(currentSize); 
            shuffleTiles(true); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é –ø—Ä–∏ —Å–º–µ–Ω–µ —Ä–µ–∂–∏–º–∞
            if (gameMode === 'time') { hintMessage.classList.add('active'); }
            else { hintMessage.classList.remove('active'); stopGameMechanisms(); }
        }

        function loadImageForMode(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    imageModeData.image = img;
                    imageModeData.imageUrl = e.target.result;
                    if (!imageModeData.canvas) {
                        imageModeData.canvas = document.createElement('canvas');
                        imageModeData.ctx = imageModeData.canvas.getContext('2d');
                        imageModeData.canvas.style.display = 'none';
                        document.body.appendChild(imageModeData.canvas);
                    }
                    imageModeData.canvas.width = img.width;
                    imageModeData.canvas.height = img.height;
                    imageModeData.ctx.drawImage(img, 0, 0);
                    if (gameMode === 'image') { applyImageToTiles(); }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function applyImageToTiles() {
            if (!imageModeData.image || !imageModeData.ctx) return;
            const img = imageModeData.image;
            const tileWidth = img.width / currentSize;
            const tileHeight = img.height / currentSize;
            tiles.forEach((tile, index) => {
                if (tile.classList.contains('empty-tile')) {
                    tile.style.backgroundImage = ''; tile.style.backgroundSize = ''; tile.style.backgroundPosition = ''; return;
                }
                const originalNumber = parseInt(tile.id.replace('tile-', ''));
                const originalIndex = originalNumber - 1;
                const col = originalIndex % currentSize;
                const row = Math.floor(originalIndex / currentSize);
                const sx = col * tileWidth;
                const sy = row * tileHeight;
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = tileWidth;
                tempCanvas.height = tileHeight;
                tempCtx.drawImage(img, sx, sy, tileWidth, tileHeight, 0, 0, tileWidth, tileHeight);
                tile.style.backgroundImage = `url(${tempCanvas.toDataURL()})`;
                tile.style.backgroundSize = 'cover'; 
                tile.style.backgroundPosition = 'center';
                const tileInner = tile.querySelector('.tile-inner');
                if (tileInner) tileInner.style.display = 'none'; 
            });
        }

        function showMessageModal(title, message, onCloseCallback = null) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.classList.add('active');
            const closeHandler = () => {
                messageModal.classList.remove('active');
                modalCloseBtn.removeEventListener('click', closeHandler);
                if (onCloseCallback) { onCloseCallback(); }
            };
            modalCloseBtn.addEventListener('click', closeHandler);
        }
        
        // Event Handlers
        gameField.addEventListener('click', (e) => {
            const tile = e.target.closest('.tile');
            if (tile) {
                vibrationManager.click();
                const tileIndex = tiles.indexOf(tile);
                if (tileIndex !== -1) { moveTile(tileIndex, currentSize); }
            }
        });

        // ‚ú® –ò–°–ü–†–ê–í–õ–ï–ù–û: –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–≤–∞–π–ø–æ–≤
        let swipeStartX, swipeStartY;
        gameField.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                swipeStartX = e.touches[0].clientX;
                swipeStartY = e.touches[0].clientY;
            }
        }, { passive: true });

        gameField.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        gameField.addEventListener('touchend', (e) => {
            if (e.changedTouches.length === 1) {
                const swipeEndX = e.changedTouches[0].clientX;
                const swipeEndY = e.changedTouches[0].clientY;

                const deltaX = swipeEndX - swipeStartX;
                const deltaY = swipeEndY - swipeStartY;

                if (Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20) return; // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–æ—Ä–æ—Ç–∫–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è (—Ç–∞–ø—ã)

                let tileToMoveIndex = -1;
                const emptyTileRow = Math.floor(emptyTileIndex / currentSize);
                const emptyTileCol = emptyTileIndex % currentSize;

                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–∞–π–ø–∞
                if (Math.abs(deltaX) > Math.abs(deltaY)) { // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø
                    if (deltaX > 0) { // –í–ø—Ä–∞–≤–æ
                        if (emptyTileCol > 0) tileToMoveIndex = emptyTileIndex - 1;
                    } else { // –í–ª–µ–≤–æ
                        if (emptyTileCol < currentSize - 1) tileToMoveIndex = emptyTileIndex + 1;
                    }
                } else { // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø
                    if (deltaY > 0) { // –í–Ω–∏–∑
                        if (emptyTileRow > 0) tileToMoveIndex = emptyTileIndex - currentSize;
                    } else { // –í–≤–µ—Ä—Ö
                        if (emptyTileRow < currentSize - 1) tileToMoveIndex = emptyTileIndex + currentSize;
                    }
                }

                if (tileToMoveIndex !== -1) {
                    vibrationManager.click();
                    moveTile(tileToMoveIndex, currentSize);
                }
            }
        });

        tileColorPicker.addEventListener('change', () => updateColors('tile'));
        bgColorPicker.addEventListener('change', () => updateColors('bg'));
        borderColorPicker.addEventListener('change', () => updateColors('border'));
        textColorPicker.addEventListener('change', () => updateColors('text'));
        highlightColorPicker.addEventListener('change', (e) => {
            if (highlightedTile) {
                highlightedTile.style.backgroundColor = highlightColorPicker.value;
                highlightedTile.style.color = getContrastColor(highlightColorPicker.value);
            }
             updateColors('highlight');
        });
        correctColorPicker.addEventListener('change', () => { highlightCorrectTiles(currentSize); updateColors('correct'); });

        findNumberBtn.addEventListener('click', () => {
            const number = parseInt(numberInput.value);
            if (!isNaN(number)) { highlightNumber(number); }
        });

        numberInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const number = parseInt(numberInput.value);
                if (!isNaN(number)) { highlightNumber(number); }
            }
        });

        applySizeBtn.addEventListener('click', () => {
            const size = parseInt(sizeSlider.value);
            if (size >= 2 && size <= 20) {
                currentSize = size;
                createGame(size);
                shuffleTiles(true); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é
            }
        });

        shuffleBtn.addEventListener('click', () => shuffleTiles(false)); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è
        autoHighlightBtn.addEventListener('click', toggleAutoHighlight);
        vibrationToggleBtn.addEventListener('click', () => { vibrationManager.toggle(); });
        
        document.body.addEventListener('click', (e) => {
            if (e.target.closest('.btn, .tab-button, .mode-card') && !e.target.closest('#vibrationToggleBtn')) {
                vibrationManager.click();
            }
        });

        function init() {
            vibrationManager.load();
            initSliders();
            loadStats();
            renderModes();
            createGame(4); 
            shuffleTiles(true); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
            checkAchievements(); 
            document.querySelector('.tab-content.active').querySelectorAll('.settings-card').forEach((card, index) => {
                card.style.animation = `fadeInUp 0.5s ease-out ${index * 0.07}s forwards`;
            });
        }
        
        init();
        
        window.addEventListener('beforeunload', (e) => { saveStats(); });

        let isModalActive = false;
        messageModal.addEventListener('transitionend', () => { isModalActive = messageModal.classList.contains('active'); });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && timerInterval && !isModalActive) {
                if (!checkWin(currentSize) && timeLeft > 0) { 
                    clearInterval(timerInterval);
                    timerInterval = null;
                    showMessageModal('–ò–≥—Ä–∞ –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞', '–í—Ä–µ–º—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ, –ø–æ–∫–∞ –≤—ã –Ω–µ –≤–µ—Ä–Ω–µ—Ç–µ—Å—å. –ù–∞–∂–º–∏—Ç–µ –û–ö, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.', () => {
                        if (gameMode === 'time') { startTimer(); }
                    });
                }
            } else if (!document.hidden && !isModalActive && gameMode === 'time' && !timerInterval && timeLeft > 0 && isTimeModeGameStarted) {
                startTimer();
            }
        });

    </script>
</body>
</html>
