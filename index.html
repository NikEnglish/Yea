<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—è—Ç–Ω–∞—à–∫–∏–Ω—ÅüéÄ</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Pacifico&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* CSS Variables for Light and Dark Themes */
        :root {
            /* -- –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞ (–í–∞—à–∞ —Ç–µ–∫—É—â–∞—è —Ç–µ–º–∞) -- */
            --primary-color: #6c5ce7; /* –§–∏–æ–ª–µ—Ç–æ–≤—ã–π */
            --secondary-color: #a29bfe; /* –°–≤–µ—Ç–ª–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π */
            --accent-color: #fd79a8; /* –†–æ–∑–æ–≤—ã–π */
            --success-color: #00b894; /* –ó–µ–ª–µ–Ω—ã–π */
            --warning-color: #fdcb6e; /* –ñ–µ–ª—Ç—ã–π */
            --danger-color: #e17055; /* –ö—Ä–∞—Å–Ω—ã–π */
            --info-color: #0984e3; /* –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Å–∏–Ω–∏–π */

            /* –î–µ—Ñ–æ–ª—Ç–Ω—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —Å–≤–µ—Ç–ª–æ–π —Ç–µ–º—ã (—ç—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è, –µ—Å–ª–∏ –Ω–µ—Ç user-override) */
            --tile-color: #ffeaa7; /* –§–æ–Ω –ø–ª–∏—Ç–∫–∏ (–∫—Ä–µ–º–æ–≤—ã–π) */
            --tile-text-color: #2d3436; /* –¶–≤–µ—Ç —á–∏—Å–µ–ª –Ω–∞ –ø–ª–∏—Ç–∫–∞—Ö (—Ç–µ–º–Ω–æ-—Å–µ—Ä—ã–π) */
            --highlight-color: #74b9ff; /* –¶–≤–µ—Ç –ø–æ–¥—Å–≤–µ—Ç–∫–∏ (–≥–æ–ª—É–±–æ–π) */
            --correct-color: #55efc4; /* –¶–≤–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –ø–ª–∏—Ç–æ–∫ (–º—è—Ç–Ω—ã–π) */
            --background-body: #f5f6fa; /* –û—Å–Ω–æ–≤–Ω–æ–π —Å–≤–µ—Ç–ª—ã–π —Ñ–æ–Ω */
            --background-card: #ffffff; /* –§–æ–Ω –±–ª–æ–∫–æ–≤, –∫–∞—Ä—Ç–æ—á–µ–∫ */
            --background-game-field: #ffffff; /* –§–æ–Ω –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è */
            --border-game-field: #cccccc; /* –°–≤–µ—Ç–ª–æ-—Å–µ—Ä—ã–π —Ü–≤–µ—Ç —Ä–∞–º–∫–∏ */
            --border-card: #dfe6e9; /* –ì—Ä–∞–Ω–∏—Ü–∞ —Å–ø–∏—Å–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ */
            --text-main: #2d3436; /* –û—Å–Ω–æ–≤–Ω–æ–π —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ */
            --text-secondary: #636e72; /* –°–µ—Ä—ã–π –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏–π */
            --tile-obstacle-bg: #b2bec3; /* –°–µ—Ä—ã–π –¥–ª—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π */
            --tile-hidden-bg: #444; /* –¢–µ–º–Ω—ã–π —Ñ–æ–Ω –¥–ª—è —Å–∫—Ä—ã—Ç—ã—Ö –ø–ª–∏—Ç–æ–∫ */
            --tab-button-bg: #ffffff;
            --tab-button-text: #2d3436;
            --stats-list-odd-bg: rgba(108, 92, 231, 0.05);
            --stats-list-hover-bg: rgba(108, 92, 231, 0.1);

            /* –¢–µ–Ω–∏ –∏ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã - –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ç–µ–º—ã */
            --header-bg-gradient-start: var(--primary-color);
            --header-bg-gradient-end: var(--secondary-color);
            --header-shadow: rgba(0, 0, 0, 0.1);
            --box-shadow-card: rgba(0, 0, 0, 0.05);
            --box-shadow-tile: rgba(0, 0, 0, 0.1);
            --box-shadow-button: rgba(108, 92, 231, 0.3);
            --box-shadow-button-hover: rgba(108, 92, 231, 0.4);
            --box-shadow-tile-correct: rgba(85, 239, 196, 0.5);
            --box-shadow-tile-highlight: rgba(116, 185, 255, 0.7);
            --modal-bg: #ffffff;
            --modal-shadow: rgba(0, 0, 0, 0.2);
            
            /* –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è (—É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç—Å—è JS —á–µ—Ä–µ–∑ setProperty) */
            --user-override-tile-color: initial;
            --user-override-tile-text-color: initial;
            --user-override-highlight-color: initial;
            --user-override-correct-color: initial;
            --user-override-background-body: initial;
            --user-override-border-game-field: initial;
        }

        /* Dark Theme overrides */
        body.dark-theme {
            --primary-color: #58a6ff; /* –ì–æ–ª—É–±–æ–π –∏–∑ –ü—è—Ç–Ω–∞—à–µ–∫ –ø–æ–¥—Ä—É–≥–∏ */
            --secondary-color: #58a6ff; /* –¢–æ—Ç –∂–µ –≥–æ–ª—É–±–æ–π */
            --accent-color: #fd79a8; /* –†–æ–∑–æ–≤—ã–π (–º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞ –¥—Ä—É–≥–æ–π –∞–∫—Ü–µ–Ω—Ç) */
            --success-color: #238636; /* –ó–µ–ª–µ–Ω—ã–π –∏–∑ –ü—è—Ç–Ω–∞—à–µ–∫ –ø–æ–¥—Ä—É–≥–∏ */
            --warning-color: #fdcb6e; /* –ñ–µ–ª—Ç—ã–π (–º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å) */
            --danger-color: #e17055; /* –ö—Ä–∞—Å–Ω—ã–π (–º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å) */
            --info-color: #30363d; /* –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π (—Ç–µ–º–Ω—ã–π —Å–µ—Ä—ã–π) */

            /* –î–µ—Ñ–æ–ª—Ç–Ω—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —Ç–µ–º–Ω–æ–π —Ç–µ–º—ã (—ç—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è, –µ—Å–ª–∏ –Ω–µ—Ç user-override) */
            --tile-color: #21262d; /* –§–æ–Ω –ø–ª–∏—Ç–∫–∏ –∏–∑ –ü—è—Ç–Ω–∞—à–µ–∫ –ø–æ–¥—Ä—É–≥–∏ (—Ç–µ–º–Ω–æ-—Å–µ—Ä—ã–π) */
            --tile-text-color: #58a6ff; /* –¶–≤–µ—Ç —á–∏—Å–µ–ª –Ω–∞ –ø–ª–∏—Ç–∫–∞—Ö –∏–∑ –ü—è—Ç–Ω–∞—à–µ–∫ –ø–æ–¥—Ä—É–≥–∏ (–≥–æ–ª—É–±–æ–π) */
            --highlight-color: #58a6ff; /* –¶–≤–µ—Ç –ø–æ–¥—Å–≤–µ—Ç–∫–∏ (–æ—Å–Ω–æ–≤–Ω–æ–π —Ü–≤–µ—Ç –ø–ª–∏—Ç–æ–∫ –≤ –∏–≥—Ä–µ –ø–æ–¥—Ä—É–≥–∏) */
            --correct-color: #2ea043; /* –¶–≤–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –ø–ª–∏—Ç–æ–∫ (–±–æ–ª–µ–µ —è—Ä–∫–∏–π –∑–µ–ª–µ–Ω—ã–π) */
            --background-body: #0d1117; /* –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω */
            --background-card: #161b22; /* –§–æ–Ω –±–ª–æ–∫–æ–≤, –∫–∞—Ä—Ç–æ—á–µ–∫ */
            --background-game-field: #161b22; /* –§–æ–Ω –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è */
            --border-game-field: #cccccc; /* –°–≤–µ—Ç–ª–æ-—Å–µ—Ä—ã–π —Ü–≤–µ—Ç —Ä–∞–º–∫–∏ */
            --border-card: #30363d; /* –ë–æ–ª–µ–µ —Ç–µ–º–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ */
            --text-main: #c9d1d9; /* –°–≤–µ—Ç–ª—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –æ–±—â–µ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ */
            --text-secondary: #8b949e; /* –ü—Ä–∏–≥–ª—É—à–µ–Ω–Ω—ã–π —Å–µ—Ä—ã–π */
            --tile-obstacle-bg: #30363d; /* –¢–µ–º–Ω—ã–π —Å–µ—Ä—ã–π –¥–ª—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π */
            --tile-hidden-bg: #2d3436; /* –¢–µ–º–Ω–µ–µ –¥–ª—è —Å–∫—Ä—ã—Ç—ã—Ö */
            --tab-button-bg: #21262d;
            --tab-button-text: #c9d1d9;
            --stats-list-odd-bg: rgba(88, 166, 255, 0.05);
            --stats-list-hover-bg: rgba(88, 166, 255, 0.1);
            
            /* –¢–µ–Ω–∏ –∏ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã - –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ç–µ–º—ã */
            --header-bg-gradient-start: #161b22;
            --header-bg-gradient-end: #161b22;
            --header-shadow: rgba(0, 0, 0, 0.2);
            --box-shadow-card: rgba(0, 0, 0, 0.2);
            --box-shadow-tile: inset 0 2px 4px rgba(0, 0, 0, 0.25); /* –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ç–µ–Ω—å –∫–∞–∫ —É –ø–æ–¥—Ä—É–≥–∏ */
            --box-shadow-button: rgba(0, 0, 0, 0.2);
            --box-shadow-button-hover: rgba(0, 0, 0, 0.3);
            --box-shadow-tile-correct: rgba(46, 160, 67, 0.5); /* –ó–µ–ª–µ–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ */
            --box-shadow-tile-highlight: rgba(88, 166, 255, 0.7);
            --modal-bg: #161b22;
            --modal-shadow: rgba(0, 0, 0, 0.4);
        }

        /* This @font-face rule will be dynamically updated by JavaScript */
        @font-face {
            font-family: 'CustomFont';
            src: url(''); 
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--background-body); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            color: var(--text-main); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            transition: background-color 0.3s ease, color 0.3s ease; /* –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –¥–ª—è –≤—Å–µ–π —Ç–µ–º—ã */
        }

        body.custom-font-all {
            font-family: 'CustomFont', 'Montserrat', sans-serif !important;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--header-bg-gradient-start), var(--header-bg-gradient-end)); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ */
            color: white;
            padding: 20px 0;
            box-shadow: 0 4px 12px var(--header-shadow); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            position: relative;
            z-index: 10;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .logo {
            font-family: 'Pacifico', cursive;
            font-size: 2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo i {
            color: var(--accent-color);
        }

        .score-display {
            background-color: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 30px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
            margin-left: 10px; /* –û—Ç—Å—Ç—É–ø –º–µ–∂–¥—É –ø–æ–∫–∞–∑–∞—Ç–µ–ª—è–º–∏ */
            color: white; /* –í—Å–µ–≥–¥–∞ –±–µ–ª—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è Score Display */
        }

        .score-display i {
            color: var(--warning-color);
        }

        /* Main content */
        .main-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 30px 0;
        }

        /* Game area */
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
            width: 100%;
            overflow: auto;
            position: relative; /* –î–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–¥—Å–∫–∞–∑–∫–∏ */
        }

        .game-field {
            display: grid;
            gap: 8px;
            margin: 20px auto;
            border: 3px solid var(--border-game-field); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            touch-action: none;
            border-radius: 15px;
            background-color: var(--background-game-field); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 10px 30px var(--box-shadow-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .tile {
            background-color: var(--user-override-tile-color, var(--tile-color)); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            border-radius: 10px;
            transition: transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease;
            position: absolute;
            width: 60px;
            height: 60px;
            box-shadow: 0 5px 15px var(--box-shadow-tile); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            cursor: pointer;
            color: var(--user-override-tile-text-color, var(--tile-text-color)); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–æ–≤—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–ª—è —Ü–≤–µ—Ç–∞ —á–∏—Å–µ–ª –Ω–∞ –ø–ª–∏—Ç–∫–∞—Ö */
            border: 2px solid transparent;
            user-select: none;
            overflow: hidden; /* –î–ª—è —Ä–µ–∂–∏–º–∞ —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π */
            opacity: 0; /* –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã—Ç—ã –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ */
        }

        .tile.custom-font-tile {
            font-family: 'CustomFont', 'Montserrat', sans-serif !important;
        }

        .tile.show {
            opacity: 1;
        }

        .tile.correct {
            border-color: var(--user-override-correct-color, var(--correct-color));
            box-shadow: 0 0 15px var(--box-shadow-tile-correct); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .tile.highlight {
            z-index: 10;
            background-color: var(--user-override-highlight-color, var(--highlight-color)); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            color: white; /* –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –ø–æ–¥—Å–≤–µ—á–µ–Ω–Ω–æ–π –ø–ª–∏—Ç–∫–µ –≤—Å–µ–≥–¥–∞ –±–µ–ª—ã–π */
            box-shadow: 0 0 20px var(--box-shadow-tile-highlight); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .tile-inner {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            transition: opacity 0.3s ease; /* –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –¥–ª—è —Ü–∏—Ñ—Ä –≤ —Ä–µ–∂–∏–º–µ "–ü–∞–º—è—Ç—å" */
        }

        .tile.highlight .tile-inner {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .tile.correct-position {
            animation: correctGlow 1s ease;
        }

        @keyframes correctGlow {
            0% { box-shadow: 0 0 10px var(--box-shadow-tile-correct); }
            50% { box-shadow: 0 0 20px var(--box-shadow-tile-correct); }
            100% { box-shadow: 0 0 10px var(--box-shadow-tile-correct); }
        }

        .empty-tile {
            background-color: transparent;
            color: transparent;
            border: none;
            box-shadow: none;
            opacity: 1 !important; /* –ü—É—Å—Ç–∞—è –ø–ª–∏—Ç–∫–∞ –≤—Å–µ–≥–¥–∞ –≤–∏–¥–∏–º–∞ */
        }

        .tile.obstacle-tile {
            background-color: var(--tile-obstacle-bg); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            cursor: not-allowed;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            pointer-events: none; /* –ó–∞–ø—Ä–µ—Ç –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è */
        }
        
        .tile.hidden-number .tile-inner {
            opacity: 0; /* –°–∫—Ä—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—É */
        }

        .tile.hidden-number.revealed .tile-inner {
            opacity: 1; /* –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–∏—Ñ—Ä—É */
        }
        
        .tile.darkness-hidden,
        .tile.hidden-path-hidden {
            background-color: var(--tile-hidden-bg); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            color: transparent; /* –°–∫—Ä—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç */
            box-shadow: none;
        }

        /* Hint for Time mode */
        .hint-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 1.1rem;
            text-align: center;
            z-index: 50;
            pointer-events: none; /* –ù–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏—è –º—ã—à–∏/–∫–∞—Å–∞–Ω–∏—è */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .hint-message.active {
            opacity: 1;
            visibility: visible;
        }

        /* Tabs */
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            position: relative;
            flex-wrap: wrap; /* –î–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
            gap: 10px; /* –û—Ç—Å—Ç—É–ø –º–µ–∂–¥—É –∫–Ω–æ–ø–∫–∞–º–∏ */
        }

        .tab-button {
            padding: 12px 25px;
            background: var(--tab-button-bg); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            border: none;
            border-radius: 30px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px var(--tab-button-shadow); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--tab-button-text); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 6px 15px var(--box-shadow-button-hover); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .tab-button i {
            font-size: 1.1rem;
        }

        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Settings, Achievements, Modes, Stats Grids */
        .settings-grid, .achievements-grid, .modes-grid, .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .settings-card, .achievement-card, .mode-card, .stats-card {
            background: var(--background-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px var(--box-shadow-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease, color 0.3s ease; /* –î–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–µ—Ö–æ–¥—ã */
            opacity: 0; /* –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã—Ç—ã –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ */
            animation: fadeInUp 0.5s ease-out forwards;
        }
        
        .settings-card:hover, .achievement-card:hover, .mode-card:hover, .stats-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px var(--box-shadow-tile); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .settings-card h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.2rem;
        }

        .settings-card h3 i {
            color: var(--accent-color);
        }
        
        /* Statistics Tab */
        .stats-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .stats-icon {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .stats-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-main); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            line-height: 1;
        }

        .stats-label {
            font-size: 1rem;
            color: var(--text-secondary); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            margin-top: 5px;
        }
        
        .stats-list-card {
            grid-column: 1 / -1; /* Span full width */
        }
        
        .stats-list-card h3 {
             color: var(--primary-color);
             margin-bottom: 15px;
        }

        .stats-list {
            list-style: none;
            padding: 0;
            max-height: 300px; /* –£–≤–µ–ª–∏—á–∏–ª –≤—ã—Å–æ—Ç—É –¥–ª—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ */
            overflow-y: auto;
            border: 1px solid var(--border-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            border-radius: 10px;
            padding: 10px;
        }
        
        .stats-list li {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-radius: 8px;
            transition: background-color 0.2s;
            flex-wrap: wrap; /* –î–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
        }

        .stats-list li:nth-child(odd) {
            background-color: var(--stats-list-odd-bg); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }
        
        .stats-list li:hover {
            background-color: var(--stats-list-hover-bg); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .stats-list-label {
            font-weight: 600;
            flex-basis: 60%; /* –î–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
        }

        .stats-list-value {
            font-weight: 700;
            color: var(--primary-color);
            flex-basis: 35%; /* –î–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
            text-align: right;
        }
        
        .stats-sub-list {
            list-style: none;
            padding-left: 20px;
            margin-top: 5px;
            font-size: 0.9em;
            color: var(--text-secondary); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .stats-sub-list li {
            padding: 3px 0;
            display: flex;
            justify-content: space-between;
        }


        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .control-label {
            font-size: 16px;
            margin-right: 10px;
            color: var(--text-main); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            padding: 0;
            border: 3px solid var(--background-card); /* –°–ª–µ–≥–∫–∞ –≤–∏–¥–µ–Ω —Ñ–æ–Ω –∫–∞—Ä—Ç–æ—á–∫–∏ */
            box-shadow: 0 3px 10px var(--box-shadow-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        input[type="range"] {
            flex-grow: 1;
            height: 8px;
            border-radius: 4px;
            background: var(--secondary-color);
            -webkit-appearance: none;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 2px 5px var(--box-shadow-button); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .range-value {
            min-width: 40px;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            color: var(--primary-color);
            margin-left: 10px;
        }

        .btn {
            padding: 12px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 10px var(--box-shadow-button); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            margin-right: 10px; /* –û—Ç—Å—Ç—É–ø –º–µ–∂–¥—É –∫–Ω–æ–ø–∫–∞–º–∏ */
            margin-bottom: 10px; /* –û—Ç—Å—Ç—É–ø –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏ */
        }

        .btn:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px var(--box-shadow-button-hover); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }
        
        .btn:disabled {
            background-color: #b2bec3;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn i {
            font-size: 1rem;
        }

        .btn-block {
            display: block;
            width: 100%;
        }

        .btn-success {
            background: var(--success-color);
            box-shadow: 0 4px 10px rgba(0, 184, 148, 0.3);
        }

        .btn-success:hover {
            background: #00a884;
            box-shadow: 0 6px 15px rgba(0, 184, 148, 0.4);
        }

        .btn-warning {
            background: var(--warning-color);
            box-shadow: 0 4px 10px rgba(253, 203, 110, 0.3);
        }

        .btn-warning:hover {
            background: #f5b74f;
            box-shadow: 0 6px 15px rgba(253, 203, 110, 0.4);
        }
        
        .btn-info {
            background: var(--info-color);
            box-shadow: 0 4px 10px rgba(9, 132, 227, 0.3);
        }

        .btn-info:hover {
            background: #0984e3;
            box-shadow: 0 6px 15px rgba(9, 132, 227, 0.4);
        }


        .btn-danger {
            background: var(--danger-color);
            box-shadow: 0 4px 10px rgba(225, 112, 85, 0.3);
        }

        .btn-danger:hover {
            background: #d15f44;
            box-shadow: 0 6px 15px rgba(225, 112, 85, 0.4);
        }

        /* Active state for a button that acts as a toggle, using primary color for 'on' state */
        .btn.active-toggle {
            background: var(--primary-color);
            box-shadow: 0 6px 15px var(--box-shadow-button-hover);
        }
        
        /* Inactive state for a button that acts as a toggle, using a neutral color */
        .btn.inactive-toggle {
            background: #b2bec3; /* –ù–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —Å–µ—Ä—ã–π */
            color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        .btn.inactive-toggle:hover {
             background: #99a2a8; /* –ß—É—Ç—å —Ç–µ–º–Ω–µ–µ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
             transform: translateY(-2px);
             box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }


        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label.btn {
            margin-bottom: 0;
        }

        .input-group input[type="number"],
        .input-group input[type="file"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            border-radius: 30px;
            font-size: 16px;
            transition: all 0.3s ease;
            background-color: var(--background-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            color: var(--text-main); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .input-group input[type="number"]:focus,
        .input-group input[type="file"]:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.2);
        }
        
        .input-group input[type="file"] {
            display: none; /* –°–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∏–Ω–ø—É—Ç */
        }

        /* Achievements tab */
        .achievements-intro {
            text-align: center;
            font-size: 1rem;
            color: var(--text-secondary); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            margin: 0 auto 20px;
            max-width: 600px;
            background: var(--background-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 5px 15px var(--box-shadow-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }
        
        .achievement-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .achievement-card.locked {
            opacity: 0.7;
            filter: grayscale(70%);
        }

        .achievement-icon {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            color: white;
            font-size: 1.8rem;
            box-shadow: 0 5px 15px var(--box-shadow-button); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .achievement-card.locked .achievement-icon {
            background: linear-gradient(135deg, #b2bec3, #dfe6e9);
        }

        .achievement-title {
            font-weight: 700;
            margin-bottom: 5px;
            color: var(--text-main); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .achievement-desc {
            font-size: 0.9rem;
            color: var(--text-secondary); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            margin-bottom: 10px;
        }

        .achievement-progress {
            width: 100%;
            height: 6px;
            background: var(--border-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            border-radius: 3px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--danger-color));
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .achievement-points {
            font-weight: 700;
            color: var(--primary-color);
            font-size: 0.9rem;
        }

        .achievement-date {
            font-size: 0.8rem;
            color: #b2bec3;
            margin-top: 5px;
        }

        .ribbon {
            position: absolute;
            top: 10px;
            right: -30px;
            background: var(--accent-color);
            color: white;
            padding: 3px 30px;
            font-size: 0.7rem;
            font-weight: 600;
            transform: rotate(45deg);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Modes tab */
        .mode-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .mode-card.active {
            border-color: var(--primary-color);
            background: var(--stats-list-odd-bg); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .mode-icon {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
            color: white;
            font-size: 1.8rem;
            box-shadow: 0 5px 15px var(--box-shadow-button); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .mode-title {
            font-weight: 700;
            margin-bottom: 5px;
            color: var(--text-main); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .mode-desc {
            font-size: 0.9rem;
            color: var(--text-secondary); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--modal-bg); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px var(--modal-shadow); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-50px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease, color 0.3s ease; /* –î–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–µ—Ö–æ–¥—ã */
            color: var(--text-main); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-content h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .modal-content p {
            color: var(--text-main); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .modal-content .btn {
            margin: 0 5px;
        }

        /* Animations */
        @keyframes confetti {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: var(--accent-color);
            opacity: 0;
            z-index: 1000;
            animation: confetti 3s ease-out forwards;
        }
        
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        .fa-spinner {
            animation: spin 1s linear infinite;
        }

        /* Demo Game Field for Solver Speed Modal */
        .demo-game-field {
            display: grid;
            grid-template-columns: repeat(2, 50px); /* Small fixed size */
            grid-template-rows: repeat(2, 50px);
            gap: 5px;
            border: 2px solid var(--primary-color); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            border-radius: 8px;
            margin: 20px auto;
            width: fit-content;
            position: relative; /* For absolute positioning of demo-tile */
            overflow: hidden; /* Ensure tiles don't go outside */
        }

        .demo-tile, .demo-empty {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 5px;
            position: absolute;
            transition: transform linear; /* Transition property, duration set by JS */
        }

        .demo-tile {
            background-color: var(--user-override-tile-color, var(--tile-color)); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            color: var(--user-override-tile-text-color, var(--tile-text-color)); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            box-shadow: 0 2px 5px var(--box-shadow-tile); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            /* Initial position: bottom-right (index 3) */
            transform: translate(55px, 55px); /* 1 * (50+5), 1 * (50+5) */
        }

        .demo-empty {
            background-color: transparent;
            border: 1px dashed var(--border-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            /* Initial position: top-left (index 0) */
            transform: translate(0px, 0px);
        }

        /* Font upload specific styles */
        .font-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .font-option-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .font-option-row input[type="radio"] {
            margin-right: 5px;
        }

        .font-list-container {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid var(--border-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }

        .font-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px dashed var(--border-card); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        .font-list-item:last-child {
            border-bottom: none;
        }

        .font-list-item button {
            background: none;
            border: none;
            color: var(--danger-color);
            cursor: pointer;
            font-size: 0.9rem;
        }

        .font-list-item span {
            font-size: 0.9rem;
            color: var(--text-main); /* –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é */
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 15px;
            }
            
            .tabs {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .tab-button {
                margin: 5px;
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .settings-grid, .achievements-grid, .modes-grid, .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .tile {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        @media (max-width: 480px) {
            .logo {
                font-size: 1.5rem;
            }
            
            .score-display {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .tile {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            .control-row {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .control-label {
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container header-content">
            <div class="logo">
                <i class="fas fa-gamepad"></i>
                <span>–ü—è—Ç–Ω–∞—à–∫–∏–Ω—ÅüéÄ</span>
            </div>
            <div class="score-display" id="scoreDisplay">
                <i class="fas fa-star"></i>
                <span>–û—á–∫–∏: 0</span>
            </div>
            <div class="score-display" id="gameStatusDisplay"></div>
            <div class="score-display" id="solverMessageDisplay" style="display: none;"></div> <!-- NEW: For header messages -->
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <div class="game-area">
                <div class="game-field" id="gameField"></div>
                <div class="hint-message" id="hintMessage">
                    –°–º–∞—Ö–Ω–∏—Ç–µ –ø–ª–∏—Ç–∫—É, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!
                </div>
            </div>

            <div class="tabs">
                <button class="tab-button active" data-tab="game">
                    <i class="fas fa-puzzle-piece"></i> –ò–≥—Ä–∞
                </button>
                <button class="tab-button" data-tab="modes">
                    <i class="fas fa-chess-board"></i> –†–µ–∂–∏–º—ã
                </button>
                <button class="tab-button" data-tab="settings">
                    <i class="fas fa-cog"></i> –ù–∞—Å—Ç—Ä–æ–π–∫–∏
                </button>
                <button class="tab-button" data-tab="achievements">
                    <i class="fas fa-trophy"></i> –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è
                </button>
                <button class="tab-button" data-tab="stats">
                    <i class="fas fa-chart-bar"></i> –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
                </button>
            </div>

            <div class="tab-content active" id="game-tab">
                <div class="settings-grid">
                    <div class="settings-card">
                        <h3><i class="fas fa-sliders-h"></i> –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
                        <div class="control-row">
                            <span class="control-label">–†–∞–∑–º–µ—Ä –ø–æ–ª—è:</span>
                            <input type="range" id="sizeSlider" min="2" max="20" value="4" step="1">
                            <span class="range-value" id="sizeValue">4</span>
                        </div>
                        <button class="btn btn-success" id="applySize">
                            <i class="fas fa-check"></i> –ü—Ä–∏–º–µ–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä
                        </button>
                        <button class="btn btn-warning" id="shuffleBtn">
                            <i class="fas fa-random"></i> –ü–µ—Ä–µ–º–µ—à–∞—Ç—å
                        </button>
                         <button class="btn btn-info" id="hintBtn">
                            <i class="fas fa-lightbulb"></i> –ü–æ–¥—Å–∫–∞–∑–∫–∞
                        </button>
                        <button class="btn btn-danger" id="solveBtn">
                            <i class="fas fa-magic"></i> –†–µ—à–∏—Ç—å –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É
                        </button>
                    </div>

                    <div class="settings-card">
                        <h3><i class="fas fa-palette"></i> –í–Ω–µ—à–Ω–∏–π –≤–∏–¥</h3>
                        <div class="control-row">
                            <span class="control-label">–†–∞–∑–º–µ—Ä –ø–ª–∏—Ç–æ–∫:</span>
                            <input type="range" id="tileSizeSlider" min="30" max="100" value="60" step="1">
                            <span class="range-value" id="tileSizeValue">60px</span>
                        </div>
                        <div class="control-row">
                            <span class="control-label">–ó–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ:</span>
                            <input type="range" id="tileRadiusSlider" min="0" max="50" value="10" step="1">
                            <span class="range-value" id="tileRadiusValue">10px</span>
                        </div>
                        <div class="control-row">
                            <span class="control-label">–†–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞:</span>
                            <input type="range" id="fontSizeSlider" min="12" max="48" value="24" step="1">
                            <span class="range-value" id="fontSizeValue">24px</span>
                        </div>
                        <!-- NEW: Font Upload -->
                        <div class="input-group">
                            <label for="font-upload-input" class="btn btn-block">
                                <i class="fas fa-font"></i> –ó–∞–≥—Ä—É–∑–∏—Ç—å —à—Ä–∏—Ñ—Ç (.ttf)
                            </label>
                            <input type="file" id="font-upload-input" accept=".ttf">
                        </div>
                        <div class="font-options" id="fontOptions" style="display: none;">
                            <div class="font-option-row">
                                <input type="radio" id="fontApplyTiles" name="fontApplyScope" value="tiles">
                                <label for="fontApplyTiles">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫ –ø–ª–∏—Ç–∫–∞–º</label>
                            </div>
                            <div class="font-option-row">
                                <input type="radio" id="fontApplyAll" name="fontApplyScope" value="all">
                                <label for="fontApplyAll">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–æ –≤—Å–µ–º—É –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É</label>
                            </div>
                            <button class="btn btn-info" id="applyFontBtn">
                                <i class="fas fa-check"></i> –ü—Ä–∏–º–µ–Ω–∏—Ç—å —à—Ä–∏—Ñ—Ç
                            </button>
                            <button class="btn btn-danger" id="resetFontBtn">
                                <i class="fas fa-times"></i> –°–±—Ä–æ—Å–∏—Ç—å —à—Ä–∏—Ñ—Ç
                            </button>
                        </div>
                    </div>

                    <div class="settings-card">
                        <h3><i class="fas fa-fill-drip"></i> –¶–≤–µ—Ç–∞</h3>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç –ø–ª–∏—Ç–æ–∫:</span>
                            <input type="color" id="tileColor" value="#ffeaa7">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç —Ñ–æ–Ω–∞:</span>
                            <input type="color" id="bgColor" value="#f5f6fa">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç —Ä–∞–º–∫–∏:</span>
                            <input type="color" id="borderColor" value="#6c5ce7">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞:</span>
                            <input type="color" id="textColor" value="#2d3436">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç –ø–æ–¥—Å–≤–µ—Ç–∫–∏:</span>
                            <input type="color" id="highlightColor" value="#74b9ff">
                        </div>
                        <div class="control-row">
                            <span class="control-label">–¶–≤–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö:</span>
                            <input type="color" id="correctColor" value="#55efc4">
                        </div>
                    </div>

                    <div class="settings-card">
                        <h3><i class="fas fa-search"></i> –ü–æ–∏—Å–∫ –∏ –ø–æ–¥—Å–≤–µ—Ç–∫–∞</h3>
                        <div class="input-group">
                            <input type="number" id="numberInput" min="1" placeholder="–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ" class="form-input">
                        </div>
                        <button class="btn" id="findNumberBtn">
                            <i class="fas fa-search"></i> –ù–∞–π—Ç–∏ —á–∏—Å–ª–æ
                        </button>
                        <button class="btn" id="autoHighlightBtn">
                            <i class="fas fa-magic"></i> –ê–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫–∞
                        </button>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="modes-tab">
                <div class="modes-grid" id="modesGrid">
                    </div>
            </div>
            
            <div class="tab-content" id="settings-tab">
                <div class="settings-grid">
                     <!-- NEW: Theme Switcher Card -->
                     <div class="settings-card">
                        <h3><i class="fas fa-adjust"></i> –¢–µ–º–∞ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è</h3>
                        <div class="control-row" style="justify-content: center;">
                            <button class="btn" id="themeToggleButton">
                                <!-- Initial text/icon set by JS based on loaded theme -->
                                <i class="fas fa-sun"></i> –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞
                            </button>
                        </div>
                     </div>
                     <!-- End Theme Switcher Card -->
                     <div class="settings-card">
                        <h3><i class="fas fa-bullhorn"></i> –û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å</h3>
                        <div class="control-row">
                            <span class="control-label">–í–∏–±—Ä–∞—Ü–∏—è</span>
                            <button class="btn" id="vibrationToggleBtn">
                                <i class="fas fa-check"></i> –í–∫–ª—é—á–µ–Ω–∞
                            </button>
                        </div>
                        <!-- NEW: Show Solver Modal Toggle -->
                        <div class="control-row">
                            <span class="control-label">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ:</span>
                            <button class="btn" id="showSolverModalToggleBtn">
                                <i class="fas fa-check"></i> –í–∫–ª—é—á–µ–Ω–æ
                            </button>
                        </div>
                    </div>
                    <!-- Solver Mode Setting -->
                    <div class="settings-card">
                        <h3><i class="fas fa-calculator"></i> –†–µ–∂–∏–º –ø—Ä–æ—Å—á–µ—Ç–∞ —Ä–µ—à–µ–Ω–∏—è</h3>
                        <div class="control-row">
                            <span class="control-label">–†–∞—Å—á–µ—Ç:</span>
                            <button class="btn" id="solverModeToggleBtn">
                                <i class="fas fa-sync-alt"></i> –ü–æ—ç—Ç–∞–ø–Ω—ã–π
                            </button>
                        </div>
                    </div>
                    <!-- Solver Speed Setting -->
                    <div class="settings-card">
                        <h3><i class="fas fa-tachometer-alt"></i> –°–∫–æ—Ä–æ—Å—Ç—å —Å–±–æ—Ä–∫–∏ –≥–æ–ª–æ–≤–æ–ª–æ–º–∫–∏</h3>
                        <div class="control-row">
                            <span class="control-label">–°–∫–æ—Ä–æ—Å—Ç—å: <span id="solverSpeedDisplay">150 –º—Å</span></span>
                            <button class="btn" id="changeSolverSpeedBtn">
                                <i class="fas fa-edit"></i> –ò–∑–º–µ–Ω–∏—Ç—å
                            </button>
                        </div>
                    </div>
                    <!-- NEW: Music Settings -->
                    <div class="settings-card">
                        <h3><i class="fas fa-music"></i> –ú—É–∑—ã–∫–∞</h3>
                        <div class="control-row">
                            <span class="control-label">–ì—Ä–æ–º–∫–æ—Å—Ç—å:</span>
                            <input type="range" id="musicVolumeSlider" min="0" max="100" value="50" step="1">
                            <span class="range-value" id="musicVolumeValue">50%</span>
                        </div>
                        <div class="input-group">
                            <label for="music-upload-input" class="btn btn-block">
                                <i class="fas fa-upload"></i> –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–≤–æ—é –ø–µ—Å–Ω—é (.mp3)
                            </label>
                            <input type="file" id="music-upload-input" accept=".mp3">
                        </div>
                        <div class="font-list-container" id="musicPlaylistContainer">
                            <ul id="musicPlaylist">
                                <!-- Default music will be added here -->
                            </ul>
                        </div>
                        <div class="control-row" style="justify-content: center; margin-top: 15px;">
                            <button class="btn btn-info" id="playMusicBtn">
                                <i class="fas fa-play"></i>
                            </button>
                            <button class="btn btn-info" id="pauseMusicBtn">
                                <i class="fas fa-pause"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="achievements-tab">
                 <div class="achievements-intro">
                    ‚ú® –î–æ–∫–∞–∂–∏—Ç–µ —Å–≤–æ—ë –º–∞—Å—Ç–µ—Ä—Å—Ç–≤–æ, –æ—Ç–∫—Ä—ã–≤ –≤—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è! ‚ú®
                </div>
                <div class="achievements-grid" id="achievementsGrid">
                </div>
            </div>
            
            <div class="tab-content" id="stats-tab">
                <div class="stats-grid" id="statsGrid">
                     </div>
            </div>
        </div>
    </main>

    <div class="modal-overlay" id="messageModal">
        <div class="modal-content">
            <h3 id="modalTitle"></h3>
            <p id="modalMessage"></p>
            <button class="btn btn-primary" id="modalCloseBtn">–û–ö</button>
        </div>
    </div>

    <!-- Loading Modal -->
    <div class="modal-overlay" id="loadingModal">
        <div class="modal-content">
            <h3 id="loadingTitle">–†–µ—à–µ–Ω–∏–µ –≥–æ–ª–æ–≤–æ–ª–æ–º–∫–∏...</h3>
            <p id="loadingMessage">–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã. –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.</p>
            <i class="fas fa-spinner fa-spin" style="font-size: 3rem; color: var(--primary-color); margin-top: 20px;"></i>
        </div>
    </div>

    <!-- Solver Speed Modal -->
    <div class="modal-overlay" id="solverSpeedModal">
        <div class="modal-content">
            <h3><i class="fas fa-tachometer-alt"></i> –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å–±–æ—Ä–∫–∏</h3>
            <p>–ù–∞—Å—Ç—Ä–æ–π—Ç–µ —Å–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è.</p>
            <div class="demo-game-field" id="demoGameField">
                <div class="demo-tile" id="demoTile1">1</div>
                <div class="demo-empty" id="demoEmptyTile"></div>
            </div>
            <div class="control-row">
                <span class="control-label">–ó–∞–¥–µ—Ä–∂–∫–∞ –Ω–∞ —Ö–æ–¥:</span>
                <input type="range" id="demoSpeedSlider" min="50" max="1000" value="150" step="10">
                <span class="range-value" id="demoSpeedValue">150 –º—Å</span>
            </div>
            <button class="btn btn-success" id="applySolverSpeedBtn">
                <i class="fas fa-check"></i> –ü—Ä–∏–º–µ–Ω–∏—Ç—å
            </button>
            <button class="btn" id="closeSolverSpeedModalBtn">
                <i class="fas fa-times"></i> –ó–∞–∫—Ä—ã—Ç—å
            </button>
        </div>
    </div>

    <audio id="backgroundMusic" loop></audio> <!-- NEW: Audio element -->

    <script>
        // DOM elements
        const gameField = document.getElementById('gameField');
        const tileColorPicker = document.getElementById('tileColor');
        const numberInput = document.getElementById('numberInput');
        const findNumberBtn = document.getElementById('findNumberBtn');
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');
        const applySizeBtn = document.getElementById('applySize');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const autoHighlightBtn = document.getElementById('autoHighlightBtn');
        const hintBtn = document.getElementById('hintBtn'); 
        const solveBtn = document.getElementById('solveBtn'); 
        const bgColorPicker = document.getElementById('bgColor');
        const borderColorPicker = document.getElementById('borderColor');
        const textColorPicker = document.getElementById('textColor'); // –≠—Ç–æ—Ç –ø–∏–∫–µ—Ä —Ç–µ–ø–µ—Ä—å –¥–ª—è tile-text-color
        const highlightColorPicker = document.getElementById('highlightColor');
        const correctColorPicker = document.getElementById('correctColor');
        const tileSizeSlider = document.getElementById('tileSizeSlider');
        const tileSizeValue = document.getElementById('tileSizeValue');
        const tileRadiusSlider = document.getElementById('tileRadiusSlider');
        const tileRadiusValue = document.getElementById('tileRadiusValue');
        const fontSizeSlider = document.getElementById('fontSizeSlider');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const gameStatusDisplay = document.getElementById('gameStatusDisplay');
        const achievementsGrid = document.getElementById('achievementsGrid');
        const modesGrid = document.getElementById('modesGrid');
        const statsGrid = document.getElementById('statsGrid');
        const messageModal = document.getElementById('messageModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const hintMessage = document.getElementById('hintMessage');
        const vibrationToggleBtn = document.getElementById('vibrationToggleBtn');
        const loadingModal = document.getElementById('loadingModal'); 
        const solverModeToggleBtn = document.getElementById('solverModeToggleBtn'); 
        const solverSpeedModal = document.getElementById('solverSpeedModal'); 
        const demoGameField = document.getElementById('demoGameField'); 
        const demoTile1 = document.getElementById('demoTile1'); 
        const demoEmptyTile = document.getElementById('demoEmptyTile'); 
        const demoSpeedSlider = document.getElementById('demoSpeedSlider'); 
        const demoSpeedValue = document.getElementById('demoSpeedValue'); 
        const applySolverSpeedBtn = document.getElementById('applySolverSpeedBtn'); 
        const closeSolverSpeedModalBtn = document.getElementById('closeSolverSpeedModalBtn'); 
        const solverSpeedDisplay = document.getElementById('solverSpeedDisplay'); 
        const changeSolverSpeedBtn = document.getElementById('changeSolverSpeedBtn'); 
        const fontUploadInput = document.getElementById('font-upload-input'); // NEW
        const fontOptions = document.getElementById('fontOptions'); // NEW
        const fontApplyTilesRadio = document.getElementById('fontApplyTiles'); // NEW
        const fontApplyAllRadio = document.getElementById('fontApplyAll'); // NEW
        const applyFontBtn = document.getElementById('applyFontBtn'); // NEW
        const resetFontBtn = document.getElementById('resetFontBtn'); // NEW
        const backgroundMusic = document.getElementById('backgroundMusic'); // NEW
        const musicVolumeSlider = document.getElementById('musicVolumeSlider'); // NEW
        const musicVolumeValue = document.getElementById('musicVolumeValue'); // NEW
        const musicUploadInput = document.getElementById('music-upload-input'); // NEW
        const musicPlaylist = document.getElementById('musicPlaylist'); // NEW
        const playMusicBtn = document.getElementById('playMusicBtn'); // NEW
        const pauseMusicBtn = document.getElementById('pauseMusicBtn'); // NEW
        const showSolverModalToggleBtn = document.getElementById('showSolverModalToggleBtn'); // NEW
        const solverMessageDisplay = document.getElementById('solverMessageDisplay'); // NEW
        // NEW: Theme Toggle elements (updated for button)
        const themeToggleButton = document.getElementById('themeToggleButton'); 
        const body = document.body;

        // Tab functionality
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.getAttribute('data-tab');
                
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    content.querySelectorAll('.settings-card, .achievement-card, .mode-card, .stats-card').forEach(card => {
                         card.style.animation = 'none';
                         card.style.opacity = '0';
                    });
                });
                
                const newTabContent = document.getElementById(`${tabId}-tab`);
                newTabContent.classList.add('active');
                
                const cards = newTabContent.querySelectorAll('.settings-card, .achievement-card, .mode-card, .stats-card');
                cards.forEach((card, index) => {
                    card.style.animation = `fadeInUp 0.5s ease-out ${index * 0.07}s forwards`;
                });
            });
        });
        
        const vibrationManager = {
            enabled: true,
            load() {
                const saved = localStorage.getItem('vibrationEnabled_v1');
                this.enabled = saved !== 'false';
                this.updateButton();
            },
            save() {
                localStorage.setItem('vibrationEnabled_v1', this.enabled);
            },
            toggle() {
                this.enabled = !this.enabled;
                this.save();
                this.updateButton();
            },
            updateButton() {
                if (this.enabled) {
                    vibrationToggleBtn.innerHTML = `<i class="fas fa-check"></i> –í–∫–ª—é—á–µ–Ω–∞`;
                    vibrationToggleBtn.classList.remove('btn-danger');
                    vibrationToggleBtn.classList.add('btn-success');
                } else {
                    vibrationToggleBtn.innerHTML = `<i class="fas fa-times"></i> –í—ã–∫–ª—é—á–µ–Ω–∞`;
                    vibrationToggleBtn.classList.remove('btn-success');
                    vibrationToggleBtn.classList.add('btn-danger');
                }
            },
            vibrate(pattern) {
                if (this.enabled && 'vibrate' in navigator) {
                    try {
                         navigator.vibrate(pattern);
                    } catch (e) {
                        console.error("Vibration failed:", e);
                    }
                }
            },
            click: function() { this.vibrate(15); },
            shuffle: function() { this.vibrate([50, 30, 50]); },
            tileAppear: function() { this.vibrate(5); },
            win: function() { this.vibrate([100, 50, 100, 50, 100]); },
            error: function() { this.vibrate([70, 40, 70]); },
            hint: function() { this.vibrate(30); }, 
            solve: function() { this.vibrate([50, 10, 50, 10, 50]); } 
        };


        // Game variables
        let tiles = []; // DOM elements for tiles
        let currentBoardState = []; // Array representing the current board numbers
        let emptyTileIndex = 0; // Index of the empty tile in `tiles` array
        let currentSize = 4;
        let highlightedTile = null;
        let autoHighlightInterval = null;
        let isAutoHighlighting = false;
        let currentTargetNumber = 1;
        let tileSize = 60;
        let tileGap = 8;
        let tileRadius = 10;
        let fontSize = 24;
        let currentScore = 0;
        let completedAchievements = [];
        let gameMode = 'classic';
        let timerInterval = null;
        let timeLeft = 0;
        let movesLeft = 0;
        let targetOrder = []; // Used for reverse mode
        let obstacleTiles = new Set();
        let imageModeData = {
            imageUrl: '',
            image: null,
            canvas: null,
            ctx: null
        };
        let memoryRevealTimeout = null;
        let isTimeModeGameStarted = false;
        let darknessRevealedTiles = new Set();
        let teleportMoveCounter = 0;
        let isSolvingPuzzle = false; 
        let usedHintInCurrentGame = false; 
        let usedAutoSolveInCurrentGame = false; 
        let solverMode = 'step-by-step'; // 'step-by-step' or 'instant'
        let solverAnimationSpeed = 150; // Default 150ms delay per move for solver animation
        let customFontLoaded = false; // NEW
        let customFontUrl = ''; // NEW: Store the URL of the loaded font
        let customFontApplyScope = 'none'; // 'none', 'tiles', 'all' // NEW
        // START MODIFICATION: Add music1.mp3 to default playlist
        let musicPlaylistData = [{ name: 'Default Music', url: 'music.mp3' }, { name: 'Default Music 2', url: 'music1.mp3' }]; // NEW
        // END MODIFICATION
        let currentMusicIndex = 0; // NEW
        let showSolverModal = true; // NEW
        let currentSolverPath = null; // NEW: Stores the full path for solver/hint
        let currentSolverPathStep = 0; // NEW: Current step in the pre-calculated path
        let isCalculatingPath = false; // NEW: To prevent multiple calculations
        let customFontStyleElement = null; // NEW: Reference to the dynamically created style element for custom font
        let currentTheme = 'light-theme'; // NEW: Stores the current theme ('light-theme' or 'dark-theme')

        // Achievement Data
        const achievementsData = [
            { id: 'legend', title: '–õ–µ–≥–µ–Ω–¥–∞ –ü—è—Ç–Ω–∞—à–µ–∫', description: '–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –≤ –∏–≥—Ä–µ. –í—ã - –Ω–∞—Å—Ç–æ—è—â–∏–π –º–∞—Å—Ç–µ—Ä!', icon: 'fa-crown', points: 1000, condition: (stats) => completedAchievements.length >= (achievementsData.length - 1), progress: (stats) => Math.min(completedAchievements.length / (achievementsData.length - 1), 1) },
            { id: 'first_move', title: '–ü–µ—Ä–≤—ã–π —à–∞–≥', description: '–°–¥–µ–ª–∞–π—Ç–µ –ø–µ—Ä–≤—ã–π —Ö–æ–¥ –≤ –∏–≥—Ä–µ.', icon: 'fa-hand-point-right', points: 10, condition: (stats) => stats.totalMoves > 0, progress: (stats) => stats.totalMoves > 0 ? 1 : 0 },
            { id: 'first_win', title: '–ù–∞—á–∞–ª–æ –ø–æ–ª–æ–∂–µ–Ω–æ', description: '–ó–∞–≤–µ—Ä—à–∏—Ç–µ —Å–≤–æ—é –ø–µ—Ä–≤—É—é –∏–≥—Ä—É.', icon: 'fa-flag-checkered', points: 50, condition: (stats) => stats.totalGamesWon > 0, progress: (stats) => stats.totalGamesWon > 0 ? 1 : 0 },
            { id: 'shuffler_10', title: '–ü–µ—Ä–µ–º–µ—à–∏–≤–∞—Ç–µ–ª—å', description: '–ü–µ—Ä–µ–º–µ—à–∞–π—Ç–µ –ø–ª–∏—Ç–∫–∏ 10 —Ä–∞–∑.', icon: 'fa-random', points: 25, condition: (stats) => stats.shuffles >= 10, progress: (stats) => Math.min(stats.shuffles / 10, 1) },
            { id: 'explorer_10', title: '–õ—é–±–æ–ø—ã—Ç–Ω—ã–π', description: '–ù–∞–π–¥–∏—Ç–µ 10 —á–∏—Å–µ–ª —Å –ø–æ–º–æ—â—å—é –ø–æ–∏—Å–∫–∞.', icon: 'fa-search', points: 30, condition: (stats) => stats.numbersFound >= 10, progress: (stats) => Math.min(stats.numbersFound / 10, 1) },
            { id: 'color_changer', title: '–•—É–¥–æ–∂–Ω–∏–∫', description: '–ò–∑–º–µ–Ω–∏—Ç–µ –≤—Å–µ 5 —Ç–∏–ø–æ–≤ —Ü–≤–µ—Ç–æ–≤ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.', icon: 'fa-paint-brush', points: 20, condition: (stats) => stats.colorsChanged.size >= 5, progress: (stats) => Math.min(stats.colorsChanged.size / 5, 1) },
            { id: 'size_master_small', title: '–ú–∏–Ω–∏–∞—Ç—é—Ä–∏—Å—Ç', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –Ω–∞ –ø–æ–ª–µ 2x2.', icon: 'fa-compress-arrows-alt', points: 50, condition: (stats) => stats.gamesWonBySize[2] > 0, progress: (stats) => stats.gamesWonBySize[2] > 0 ? 1 : 0 },
            { id: 'size_master_big', title: '–ì—Ä–æ—Å—Å–º–µ–π—Å—Ç–µ—Ä', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –Ω–∞ –ø–æ–ª–µ 8x8.', icon: 'fa-expand-arrows-alt', points: 150, condition: (stats) => stats.gamesWonBySize[8] > 0, progress: (stats) => stats.gamesWonBySize[8] > 0 ? 1: 0 },
            { id: 'size_master_titanic', title: '–¢–∏—Ç–∞–Ω–∏—á–µ—Å–∫–∏–π –¢—Ä—É–¥', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –Ω–∞ –ø–æ–ª–µ 20x20.', icon: 'fa-globe-americas', points: 500, condition: (stats) => stats.gamesWonBySize[20] > 0, progress: (stats) => Math.min(stats.gamesWonBySize[20] / 1, 1) },
            { id: 'size_master_all', title: '–ú–∞—Å—Ç–µ—Ä –†–∞–∑–º–µ—Ä–æ–≤', description: '–°—ã–≥—Ä–∞–π—Ç–µ –Ω–∞ 5 —Ä–∞–∑–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–∞—Ö –ø–æ–ª—è.', icon: 'fa-ruler-combined', points: 100, condition: (stats) => stats.playedSizes.size >= 5, progress: (stats) => Math.min(stats.playedSizes.size / 5, 1) },
            { id: 'mode_explorer', title: '–†–µ–∂–∏–º–Ω—ã–π –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å', description: '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ 5 —Ä–∞–∑–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤ –∏–≥—Ä—ã.', icon: 'fa-route', points: 100, condition: (stats) => stats.modesTried.size >= 5, progress: (stats) => Math.min(stats.modesTried.size / 5, 1) },
            { id: 'mode_master', title: '–ü–æ–≤–µ–ª–∏—Ç–µ–ª—å –†–µ–∂–∏–º–æ–≤', description: '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–µ–∂–∏–º—ã –∏–≥—Ä—ã.', icon: 'fa-dungeon', points: 250, condition: (stats) => stats.modesTried.size >= gameModes.length, progress: (stats) => Math.min(stats.modesTried.size / gameModes.length, 1) },
            { id: 'win_classic', title: '–ö–ª–∞—Å—Å–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π".', icon: 'fa-th', points: 20, condition: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[currentSize] && stats.gameRecords.classic[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[currentSize] && stats.gameRecords.classic[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_time', title: '–°–ø—Ä–∏–Ω—Ç–µ—Ä', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–ù–∞ –≤—Ä–µ–º—è".', icon: 'fa-stopwatch', points: 30, condition: (stats) => stats.gameRecords.time && stats.gameRecords.time[currentSize] && stats.gameRecords.time[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.time && stats.gameRecords.time[currentSize] && stats.gameRecords.time[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_moves', title: '–¢–∞–∫—Ç–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Ö–æ–¥–æ–≤".', icon: 'fa-shoe-prints', points: 30, condition: (stats) => stats.gameRecords.moves && stats.gameRecords.moves[currentSize] && stats.gameRecords.moves[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.moves && stats.gameRecords.moves[currentSize] && stats.gameRecords.moves[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_reverse', title: '–†–µ–≤–µ—Ä—Å–µ—Ä', description: '–ù–∞—á–Ω–∏—Ç–µ —Å —Å–æ–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ —Å–æ–±–µ—Ä–∏—Ç–µ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ', icon: 'fa-exchange-alt', points: 40, condition: (stats) => stats.gameRecords.reverse && stats.gameRecords.reverse[currentSize] && stats.gameRecords.reverse[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.reverse && stats.gameRecords.reverse[currentSize] && stats.gameRecords.reverse[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'collector_10', title: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 10 –∏–≥—Ä.', icon: 'fa-medal', points: 100, condition: (stats) => stats.totalGamesWon >= 10, progress: (stats) => Math.min(stats.totalGamesWon / 10, 1) },
            { id: 'collector_50', title: '–≠–Ω—Ç—É–∑–∏–∞—Å—Ç', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 50 –∏–≥—Ä.', icon: 'fa-award', points: 250, condition: (stats) => stats.totalGamesWon >= 50, progress: (stats) => Math.min(stats.totalGamesWon / 50, 1) },
            { id: 'mover_1k', title: '–ù–µ–ø–æ—Å–µ–¥–∞', description: '–°–¥–µ–ª–∞–π—Ç–µ 1000 —Ö–æ–¥–æ–≤.', icon: 'fa-walking', points: 50, condition: (stats) => stats.totalMoves >= 1000, progress: (stats) => Math.min(stats.totalMoves / 1000, 1) },
            { id: 'mover_10k', title: '–ú–∞—Ä–∞—Ñ–æ–Ω–µ—Ü', description: '–°–¥–µ–ª–∞–π—Ç–µ 10 000 —Ö–æ–¥–æ–≤.', icon: 'fa-running', points: 150, condition: (stats) => stats.totalMoves >= 10000, progress: (stats) => Math.min(stats.totalMoves / 10000, 1) },
            { id: 'score_1k', title: '–ù–∞–∫–æ–ø–∏—Ç–µ–ª—å', description: '–ù–∞–±–µ—Ä–∏—Ç–µ 1000 –æ—á–∫–æ–≤ (–±–µ–∑ —É—á–µ—Ç–∞ –æ—á–∫–æ–≤ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è).', icon: 'fa-coins', points: 50, condition: (stats) => stats.totalScore >= 1000, progress: (stats) => Math.min(stats.totalScore / 1000, 1) },
            { id: 'score_10k', title: '–ë–æ–≥–∞—á', description: '–ù–∞–±–µ—Ä–∏—Ç–µ 10 000 –æ—á–∫–æ–≤ (–±–µ–∑ —É—á–µ—Ç–∞ –æ—á–∫–æ–≤ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è).', icon: 'fa-gem', points: 150, condition: (stats) => stats.totalScore >= 10000, progress: (stats) => Math.min(stats.totalScore / 10000, 1) },
            { id: 'fast_solver_100', title: '–ë—ã—Å—Ç—Ä—ã–π —Ä–µ—à–∞—Ç–µ–ª—å', description: '–†–µ—à–∏—Ç–µ –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É 4x4 –º–µ–Ω–µ–µ —á–µ–º –∑–∞ 100 —Ö–æ–¥–æ–≤.', icon: 'fa-bolt', points: 75, condition: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[4] && stats.gameRecords.classic[4].bestMoves < 100, progress: (stats) => stats.gameRecords.classic && stats.gameRecords.classic[4] ? Math.max(0, 1 - (stats.gameRecords.classic[4].bestMoves - 50) / 50) : 0 },
            { id: 'shuffler_50', title: '–•–∞–æ—Å-–º–µ–Ω–µ–¥–∂–µ—Ä', description: '–ü–µ—Ä–µ–º–µ—à–∞–π—Ç–µ –ø–ª–∏—Ç–∫–∏ 50 —Ä–∞–∑.', icon: 'fa-sync-alt', points: 50, condition: (stats) => stats.shuffles >= 50, progress: (stats) => Math.min(stats.shuffles / 50, 1) },
            { id: 'explorer_50', title: '–î–µ—Ç–µ–∫—Ç–∏–≤', description: '–ù–∞–π–¥–∏—Ç–µ 50 —á–∏—Å–µ–ª —Å –ø–æ–º–æ—â—å—é –ø–æ–∏—Å–∫–∞.', icon: 'fa-search-plus', points: 60, condition: (stats) => stats.numbersFound >= 50, progress: (stats) => Math.min(stats.numbersFound / 50, 1) },
            { id: 'autohighlight_user', title: '–ê–≤—Ç–æ–ø–∏–ª–æ—Ç', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É, –∏—Å–ø–æ–ª—å–∑—É—è –∞–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫—É.', icon: 'fa-robot', points: 30, condition: (stats) => stats.winsWithAutohighlight > 0, progress: (stats) => stats.winsWithAutohighlight > 0 ? 1 : 0 },
            { id: 'styler', title: '–°—Ç–∏–ª–∏—Å—Ç', description: '–ò–∑–º–µ–Ω–∏—Ç–µ —Ä–∞–∑–º–µ—Ä –ø–ª–∏—Ç–æ–∫, –∏—Ö –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∏ —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞.', icon: 'fa-magic', points: 25, condition: (stats) => stats.styleChanges.size >= 3, progress: (stats) => Math.min(stats.styleChanges.size / 3, 1) },
            { id: 'win_obstacle', title: '–ü—Ä–µ–æ–¥–æ–ª–µ–Ω–∏–µ', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏".', icon: 'fa-ban', points: 50, condition: (stats) => stats.gameRecords.obstacle && stats.gameRecords.obstacle[currentSize] && stats.gameRecords.obstacle[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.obstacle && stats.gameRecords.obstacle[currentSize] && stats.gameRecords.obstacle[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_memory', title: '–§–µ–Ω–æ–º–µ–Ω–∞–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –ø–∞–º—è—Ç—å—é".', icon: 'fa-brain', points: 60, condition: (stats) => stats.gameRecords.memory && stats.gameRecords.memory[currentSize] && stats.gameRecords.memory[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.memory && stats.gameRecords.memory[currentSize] && stats.gameRecords.memory[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_image', title: '–•—É–¥–æ–∂–Ω–∏–∫-–≥–æ–ª–æ–≤–æ–ª–æ–º—â–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–° –∫–∞—Ä—Ç–∏–Ω–∫–æ–π".', icon: 'fa-image', points: 80, condition: (stats) => stats.gameRecords.image && stats.gameRecords.image[currentSize] && stats.gameRecords.image[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.image && stats.gameRecords.image[currentSize] && stats.gameRecords.image[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_teleport', title: '–ú–∞—Å—Ç–µ—Ä —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–¢–µ–ª–µ–ø–æ—Ä—Ç".', icon: 'fa-random', points: 75, condition: (stats) => stats.gameRecords.teleport && stats.gameRecords.teleport[currentSize] && stats.gameRecords.teleport[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.teleport && stats.gameRecords.teleport[currentSize] && stats.gameRecords.teleport[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_vortex', title: '–ú–∞—Å—Ç–µ—Ä –≤–∏—Ö—Ä—è', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–í–∏—Ö—Ä—å".', icon: 'fa-wind', points: 80, condition: (stats) => stats.gameRecords.vortex && stats.gameRecords.vortex[currentSize] && stats.gameRecords.vortex[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.vortex && stats.gameRecords.vortex[currentSize] && stats.gameRecords.vortex[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_hidden_path', title: '–ü—Ä–æ–≤–æ–¥–Ω–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–°–∫—Ä—ã—Ç—ã–π –ø—É—Ç—å".', icon: 'fa-eye-slash', points: 85, condition: (stats) => stats.gameRecords.hidden_path && stats.gameRecords.hidden_path[currentSize] && stats.gameRecords.hidden_path[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.hidden_path && stats.gameRecords.hidden_path[currentSize] && stats.gameRecords.hidden_path[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'win_darkness', title: '–ù–æ—á–Ω–æ–π —Å—Ç—Ä–∞–Ω–Ω–∏–∫', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ –≤ —Ä–µ–∂–∏–º–µ "–¢–µ–º–Ω–æ—Ç–∞".', icon: 'fa-moon', points: 90, condition: (stats) => stats.gameRecords.darkness && stats.gameRecords.darkness[currentSize] && stats.gameRecords.darkness[currentSize].gamesPlayed > 0, progress: (stats) => stats.gameRecords.darkness && stats.gameRecords.darkness[currentSize] && stats.gameRecords.darkness[currentSize].gamesPlayed > 0 ? 1 : 0 },
            { id: 'hint_seeker_10', title: '–ò—Å–∫–∞—Ç–µ–ª—å –ø–æ–¥—Å–∫–∞–∑–æ–∫', description: '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏ 10 —Ä–∞–∑.', icon: 'fa-compass', points: 20, condition: (stats) => stats.hintsUsed >= 10, progress: (stats) => Math.min(stats.hintsUsed / 10, 1) }, 
            { id: 'hint_seeker_100', title: '–ü—É—Ç–µ–≤–æ–¥–∏—Ç–µ–ª—å', description: '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏ 100 —Ä–∞–∑.', icon: 'fa-map-signs', points: 50, condition: (stats) => stats.hintsUsed >= 100, progress: (stats) => Math.min(stats.hintsUsed / 100, 1) }, 
            { id: 'win_with_hint', title: '–£–¥–∞—á–Ω—ã–π —Å—Ç–∞—Ä—Ç', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 1 –∏–≥—Ä—É, –∏—Å–ø–æ–ª—å–∑—É—è –ø–æ–¥—Å–∫–∞–∑–∫–∏.', icon: 'fa-handshake', points: 25, condition: (stats) => stats.winsWithHints > 0, progress: (stats) => stats.winsWithHints > 0 ? 1 : 0 }, 
            { id: 'win_with_hint_5', title: '–ü—Ä–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–µ', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 5 –∏–≥—Ä, –∏—Å–ø–æ–ª—å–∑—É—è –ø–æ–¥—Å–∫–∞–∑–∫–∏.', icon: 'fa-people-carry', points: 75, condition: (stats) => stats.winsWithHints >= 5, progress: (stats) => Math.min(stats.winsWithHints / 5, 1) }, 
            { id: 'auto_solver_1', title: '–ú–∞–ª–∞—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 1 –∏–≥—Ä—É, –∏—Å–ø–æ–ª—å–∑—É—è –∫–Ω–æ–ø–∫—É "–†–µ—à–∏—Ç—å –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É".', icon: 'fa-robot', points: 50, condition: (stats) => stats.autoSolvedGames > 0, progress: (stats) => stats.autoSolvedGames > 0 ? 1 : 0 }, 
            { id: 'auto_solver_5', title: '–ü–æ–ª–Ω–∞—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è', description: '–í—ã–∏–≥—Ä–∞–π—Ç–µ 5 –∏–≥—Ä, –∏—Å–ø–æ–ª—å–∑—É—è –∫–Ω–æ–ø–∫—É "–†–µ—à–∏—Ç—å –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É".', icon: 'fa-cogs', points: 150, condition: (stats) => stats.autoSolvedGames >= 5, progress: (stats) => Math.min(stats.autoSolvedGames / 5, 1) } 
        ];

        // Game Modes Data
        const gameModes = [
            { id: 'classic', title: '–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π', description: '–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø—è—Ç–Ω–∞—à–∫–∏', icon: 'fa-th', active: true, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'time', title: '–ù–∞ –≤—Ä–µ–º—è', description: '–°–æ–±–µ—Ä–∏—Ç–µ –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É –∫–∞–∫ –º–æ–∂–Ω–æ –±—ã—Å—Ç—Ä–µ–µ', icon: 'fa-stopwatch', active: false, getLimits: (size) => ({ moves: Infinity, time: size * size * 5 }) },
            { id: 'moves', title: '–° –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Ö–æ–¥–æ–≤', description: '–°–æ–±–µ—Ä–∏—Ç–µ –∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ö–æ–¥–æ–≤', icon: 'fa-shoe-prints', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'reverse', title: '–û–±—Ä–∞—Ç–Ω—ã–π', description: '–ù–∞—á–Ω–∏—Ç–µ —Å —Å–æ–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ —Å–æ–±–µ—Ä–∏—Ç–µ –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ', icon: 'fa-exchange-alt', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'image', title: '–° –∫–∞—Ä—Ç–∏–Ω–∫–æ–π', description: '–í–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä - —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è', icon: 'fa-image', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'obstacle', title: '–° –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏', description: '–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–ª–∏—Ç–∫–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ —Å–≤–æ–∏—Ö –º–µ—Å—Ç–∞—Ö', icon: 'fa-ban', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }), getObstacleCount: (size) => Math.max(1, Math.floor(size * size * 0.05)) },
            { id: 'teleport', title: '–¢–µ–ª–µ–ø–æ—Ä—Ç', description: '–ü—É—Å—Ç–∞—è —è—á–µ–π–∫–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ö–æ–¥–æ–≤', icon: 'fa-bolt', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }), teleportFrequency: (size) => Math.max(3, Math.floor(size * 1.5)) },
            { id: 'vortex', title: '–í–∏—Ö—Ä—å', description: '–ü—É—Å—Ç–∞—è –ø–ª–∏—Ç–∫–∞ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ö–æ–¥–∞', icon: 'fa-wind', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'hidden_path', title: '–°–∫—Ä—ã—Ç—ã–π –ø—É—Ç—å', description: '–í–∏–¥–Ω—ã —Ç–æ–ª—å–∫–æ –ø–ª–∏—Ç–∫–∏ –≤–æ–∫—Ä—É–≥ –ø—É—Å—Ç–æ–π —è—á–µ–π–∫–∏', icon: 'fa-eye-slash', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) },
            { id: 'darkness', title: '–¢–µ–º–Ω–æ—Ç–∞', description: '–ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –ø–ª–∏—Ç–æ–∫ —Å–∫—Ä—ã—Ç—ã, –∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–π –∏ —Å–æ—Å–µ–¥–Ω–∏—Ö', icon: 'fa-moon', active: false, getLimits: (size) => ({ moves: Infinity, time: Infinity }) }
        ];

        // Game Statistics
        let gameStats = {};
        
        function initializeStats() {
             gameStats = {
                currentMoves: 0, totalMoves: 0, totalScore: 0, achievementScore: 0, totalGamesWon: 0, shuffles: 0, numbersFound: 0, winsWithAutohighlight: 0,
                hintsUsed: 0, winsWithHints: 0, autoSolvedGames: 0, 
                playedSizes: new Set(), colorsChanged: new Set(), styleChanges: new Set(), modesTried: new Set(['classic']), gamesWonBySize: {}, gameRecords: {} 
            };
            const maxSliderSize = parseInt(sizeSlider.max);
            gameModes.forEach(mode => {
                gameStats.gameRecords[mode.id] = {};
                for (let s = 2; s <= maxSliderSize; s++) {
                    gameStats.gameRecords[mode.id][s] = { gamesPlayed: 0, bestTime: Infinity, worstTime: 0, bestMoves: Infinity, worstMoves: 0 };
                }
            });
        }

        function initSliders() {
            sizeValue.textContent = sizeSlider.value;
            tileSizeValue.textContent = tileSizeSlider.value + 'px';
            tileRadiusValue.textContent = tileRadiusSlider.value + 'px';
            fontSizeValue.textContent = fontSizeSlider.value + 'px';
            musicVolumeValue.textContent = musicVolumeSlider.value + '%'; // NEW
            sizeSlider.addEventListener('input', () => { sizeValue.textContent = sizeSlider.value; });
            tileSizeSlider.addEventListener('input', () => { tileSize = parseInt(tileSizeSlider.value); tileSizeValue.textContent = tileSize + 'px'; applyVisualUpdates(); gameStats.styleChanges.add('tileSize'); saveStats(); checkAchievements(); });
            tileRadiusSlider.addEventListener('input', () => { tileRadius = parseInt(tileRadiusSlider.value); tileRadiusValue.textContent = tileRadius + 'px'; applyVisualUpdates(); gameStats.styleChanges.add('tileRadius'); saveStats(); checkAchievements(); });
            fontSizeSlider.addEventListener('input', () => { fontSize = parseInt(fontSizeSlider.value); fontSizeValue.textContent = fontSize + 'px'; applyVisualUpdates(); gameStats.styleChanges.add('fontSize'); saveStats(); checkAchievements(); });
            musicVolumeSlider.addEventListener('input', () => { // NEW
                backgroundMusic.volume = musicVolumeSlider.value / 100;
                musicVolumeValue.textContent = musicVolumeSlider.value + '%';
                saveStats();
            });
        }
        
        function applyVisualUpdates() {
            gameField.style.width = `${currentSize * (tileSize + tileGap)}px`;
            gameField.style.height = `${currentSize * (tileSize + tileGap)}px`;
            tiles.forEach(tile => {
                tile.style.width = tileSize + 'px';
                tile.style.height = tileSize + 'px';
                tile.style.borderRadius = tileRadius + 'px';
                tile.style.fontSize = fontSize + 'px';
            });
            renderTiles(currentSize, 'move');
        }

        function startTimer() {
            const currentMode = gameModes.find(mode => mode.id === gameMode);
            const limits = currentMode.getLimits(currentSize);
            timeLeft = limits.time; 
            updateScore(); 
            timerInterval = setInterval(() => {
                timeLeft--; 
                updateScore();
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endGame(false, '–í—Ä–µ–º—è –≤—ã—à–ª–æ!'); 
                }
            }, 1000);
        }

        function stopGameMechanisms() {
            clearInterval(timerInterval);
            timerInterval = null;
            stopAutoHighlight(); 
            clearTimeout(memoryRevealTimeout); 
            document.querySelectorAll('.tile.hidden-number.revealed').forEach(tile => { tile.classList.remove('revealed'); });
            document.querySelectorAll('.tile.darkness-hidden, .tile.hidden-path-hidden').forEach(tile => {
                tile.classList.remove('darkness-hidden', 'hidden-path-hidden');
                // Ensure colors revert to theme defaults, not fixed picker values
                const computedStyle = getComputedStyle(document.documentElement);
                tile.style.backgroundColor = computedStyle.getPropertyValue('--tile-color');
                tile.style.color = computedStyle.getPropertyValue('--tile-text-color'); // –ò—Å–ø–æ–ª—å–∑—É–µ–º tile-text-color
            });
            darknessRevealedTiles.clear();
        }

        function createGame(size) {
            stopGameMechanisms(); 
            gameField.innerHTML = '';
            tiles = [];
            currentBoardState = []; // Reset current board state
            emptyTileIndex = size * size - 1;
            currentSize = size;
            currentScore = 0;
            gameStats.currentMoves = 0;
            usedHintInCurrentGame = false; 
            usedAutoSolveInCurrentGame = false; 
            isTimeModeGameStarted = false;
            timeLeft = 0;
            movesLeft = 0;
            obstacleTiles.clear();
            teleportMoveCounter = 0;
            currentSolverPath = null; // NEW: Reset hint/solver path on new game
            currentSolverPathStep = 0; // NEW
            isCalculatingPath = false; // NEW

            const currentMode = gameModes.find(mode => mode.id === gameMode);
            const limits = currentMode.getLimits(currentSize);
            if (gameMode === 'moves') { movesLeft = limits.moves; }
            else if (gameMode === 'time') { timeLeft = limits.time; hintMessage.classList.add('active'); }
            else { hintMessage.classList.remove('active'); }
            if (gameMode === 'reverse') { targetOrder = Array.from({length: size * size - 1}, (_, i) => size * size - 1 - i); }
            else { targetOrder = Array.from({length: size * size - 1}, (_, i) => i + 1); }
            gameStats.playedSizes.add(size);
            saveStats();
            checkAchievements();
            gameField.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            gameField.style.gridTemplateRows = `repeat(${size}, 1fr)`;
            gameField.style.width = `${size * (tileSize + tileGap)}px`;
            gameField.style.height = `${size * (tileSize + tileGap)}px`;
            gameField.style.gap = tileGap + 'px';
            for (let i = 1; i <= size * size - 1; i++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.id = `tile-${i}`;
                const tileInner = document.createElement('div');
                tileInner.className = 'tile-inner';
                tileInner.textContent = i;
                tile.appendChild(tileInner);
                tile.style.width = tileSize + 'px';
                tile.style.height = tileSize + 'px';
                tile.style.borderRadius = tileRadius + 'px';
                tile.style.fontSize = fontSize + 'px';
                // Use CSS variables for initial colors
                const computedStyle = getComputedStyle(document.documentElement);
                tile.style.backgroundColor = computedStyle.getPropertyValue('--user-override-tile-color', computedStyle.getPropertyValue('--tile-color'));
                tile.style.color = computedStyle.getPropertyValue('--user-override-tile-text-color', computedStyle.getPropertyValue('--tile-text-color'));
                tile.style.opacity = 0;
                tiles.push(tile);
                gameField.appendChild(tile);
            }
            const emptyTile = document.createElement('div');
            emptyTile.className = 'empty-tile';
            emptyTile.id = 'empty-tile';
            tiles.push(emptyTile);
            gameField.appendChild(emptyTile);
            updateScore();
            applyCustomFont(); // NEW: Apply font on game creation
        }

        function updateScore() {
            scoreDisplay.innerHTML = `<i class="fas fa-star"></i> <span>–û—á–∫–∏: ${currentScore}</span>`;
            let statusText = '';
            if (gameMode === 'time') {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                statusText = `<i class="fas fa-clock"></i> <span>–í—Ä–µ–º—è: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}</span>`;
            } else if (gameMode === 'moves') {
                statusText = `<i class="fas fa-shoe-prints"></i> <span>–•–æ–¥—ã: ${movesLeft}</span>`;
            } else { 
                statusText = `<i class="fas fa-shoe-prints"></i> <span>–•–æ–¥—ã: ${gameStats.currentMoves}</span>`;
            }
            gameStatusDisplay.innerHTML = statusText;
        }

        function addScore(points) {
            currentScore += points;
            updateScore();
        }

        function highlightNumber(number) {
            if (highlightedTile) {
                highlightedTile.classList.remove('highlight');
                // Ensure colors revert to theme defaults, not fixed picker values
                const computedStyle = getComputedStyle(document.documentElement);
                highlightedTile.style.backgroundColor = computedStyle.getPropertyValue('--user-override-tile-color', computedStyle.getPropertyValue('--tile-color'));
                highlightedTile.style.color = computedStyle.getPropertyValue('--user-override-tile-text-color', computedStyle.getPropertyValue('--tile-text-color'));
            }
            if (!number || number < 1 || number > currentSize * currentSize - 1) return;
            highlightedTile = Array.from(document.querySelectorAll('.tile')).find(tile => !tile.classList.contains('empty-tile') && tile.querySelector('.tile-inner')?.textContent == number);
            if (highlightedTile) {
                highlightedTile.classList.add('highlight');
                // –ó–¥–µ—Å—å `highlightColorPicker.value` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤—ã–±–æ—Ä, –∞ –Ω–µ —Ü–≤–µ—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                highlightedTile.style.backgroundColor = highlightColorPicker.value;
                highlightedTile.style.color = getContrastColor(highlightColorPicker.value);
                gameStats.numbersFound++;
                saveStats();
                checkAchievements();
            }
        }

        function getContrastColor(hexColor) {
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128 ? '#000000' : '#FFFFFF';
        }

        function checkTilePositions() {
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            for (let num = 0; num < checkTargetOrder.length; num++) {
                const expectedValue = checkTargetOrder[num]; 
                const currentTileAtPosition = tiles.find(t => !t.classList.contains('empty-tile') && (gameMode === 'image' ? parseInt(t.id.replace('tile-', '')) : parseInt(t.querySelector('.tile-inner')?.textContent)) == expectedValue);
                if (currentTileAtPosition) {
                    const currentTileIndex = tiles.indexOf(currentTileAtPosition);
                    if (currentTileIndex !== num) { 
                        currentTargetNumber = expectedValue; 
                        return currentTargetNumber;
                    }
                } else {
                    const tileAtCurrentIndexValue = gameMode === 'image' ? parseInt(tiles[num].id.replace('tile-', '')) : parseInt(tiles[num].querySelector('.tile-inner')?.textContent);
                    if (parseInt(tileAtCurrentIndexValue) !== expectedValue) {
                         currentTargetNumber = expectedValue;
                         return currentTargetNumber;
                    }
                }
            }
            stopAutoHighlight();
            if (checkWin(currentSize)) { endGame(true, '–ü–æ–±–µ–¥–∞ —á–µ—Ä–µ–∑ –∞–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫—É!'); }
            return null;
        }

        function autoHighlightNext() {
            if (isAutoHighlighting) return;
            isAutoHighlighting = true;
            autoHighlightBtn.classList.add('active');
            autoHighlightBtn.innerHTML = '<i class="fas fa-stop"></i> –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å';
            currentTargetNumber = 1;
            const firstNumber = checkTilePositions();
            if (firstNumber) { highlightNumber(firstNumber); }
            autoHighlightInterval = setInterval(() => {
                const nextNumber = checkTilePositions();
                if (nextNumber) { highlightNumber(nextNumber); }
            }, 1000);
        }

        function stopAutoHighlight() {
            isAutoHighlighting = false;
            clearInterval(autoHighlightInterval);
            autoHighlightBtn.classList.remove('active');
            autoHighlightBtn.innerHTML = '<i class="fas fa-magic"></i> –ê–≤—Ç–æ–ø–æ–¥—Å–≤–µ—Ç–∫–∞';
            if (highlightedTile) {
                highlightedTile.classList.remove('highlight');
                // Ensure colors revert to theme defaults, not fixed picker values
                const computedStyle = getComputedStyle(document.documentElement);
                highlightedTile.style.backgroundColor = computedStyle.getPropertyValue('--user-override-tile-color', computedStyle.getPropertyValue('--tile-color'));
                highlightedTile.style.color = computedStyle.getPropertyValue('--user-override-tile-text-color', computedStyle.getPropertyValue('--tile-text-color'));
                highlightedTile = null;
            }
        }

        function toggleAutoHighlight() {
            if (isAutoHighlighting) { stopAutoHighlight(); } else { autoHighlightNext(); }
        }

        function shuffleTiles(isInitialShuffle = false) {
            stopGameMechanisms();
            gameStats.shuffles++;
            saveStats();
            checkAchievements();
            
            // NEW: Reset solver/hint path on shuffle
            currentSolverPath = null;
            currentSolverPathStep = 0;
            isCalculatingPath = false;
            updateSolverMessage('');

            // Corrected approach for `shuffleTiles`:
            // 1. Create a flat array of numbers (1 to N-1, plus 0 for empty).
            let boardValues = Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            boardValues.push(0); // Add empty tile value

            // 2. Shuffle this array until it's solvable.
            let shuffledValues = [];
            let emptyTileCurrentPosition = -1; // Index of 0 in the shuffled array
            let solvable = false; // Reset solvable flag for the loop
            while (!solvable) {
                shuffledValues = boardValues.slice().sort(() => Math.random() - 0.5);
                emptyTileCurrentPosition = shuffledValues.indexOf(0);
                solvable = isSolvable(shuffledValues, currentSize, emptyTileCurrentPosition);
            }
            
            // 3. Update DOM tiles based on the solvable shuffledValues
            let newTilesOrder = [];
            for (let i = 0; i < shuffledValues.length; i++) {
                if (shuffledValues[i] === 0) {
                    newTilesOrder.push(tiles.find(t => t.classList.contains('empty-tile')));
                    emptyTileIndex = i;
                } else {
                    // Find the tile DOM element that has this value
                    newTilesOrder.push(tiles.find(t => {
                        const tileValue = t.classList.contains('empty-tile') ? 0 : (gameMode === 'image' ? parseInt(t.id.replace('tile-', '')) : parseInt(t.querySelector('.tile-inner')?.textContent));
                        return tileValue === shuffledValues[i];
                    }));
                }
            }
            tiles = newTilesOrder;
            currentBoardState = shuffledValues; // Update `currentBoardState` with the new order
            
            applyModeSpecificStylesAndLogic();

            if (isInitialShuffle) {
                renderTiles(currentSize, 'initial');
            } else {
                renderTiles(currentSize, 'shuffle');
            }
        }

        function applyModeSpecificStylesAndLogic() {
            tiles.forEach(tile => {
                tile.classList.remove('obstacle-tile', 'hidden-number', 'revealed', 'darkness-hidden', 'hidden-path-hidden');
                tile.style.backgroundImage = '';
                tile.style.backgroundSize = '';
                tile.style.backgroundPosition = '';
                const tileInner = tile.querySelector('.tile-inner');
                if (tileInner) {
                    tileInner.style.display = 'flex';
                    // Use CSS variables for colors
                    const computedStyle = getComputedStyle(document.documentElement);
                    tile.style.backgroundColor = computedStyle.getPropertyValue('--user-override-tile-color', computedStyle.getPropertyValue('--tile-color'));
                    tile.style.color = computedStyle.getPropertyValue('--user-override-tile-text-color', computedStyle.getPropertyValue('--tile-text-color'));
                }
                tile.style.pointerEvents = 'auto';
            });
            obstacleTiles.clear();
            darknessRevealedTiles.clear();
            teleportMoveCounter = 0;
            if (gameMode === 'obstacle') {
                const currentMode = gameModes.find(mode => mode.id === gameMode);
                const count = currentMode.getObstacleCount(currentSize);
                let obstaclesAdded = 0;
                const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
                
                // Get current values from the actual DOM `tiles` array to check their current positions
                const actualTileValues = tiles.map(t => t.classList.contains('empty-tile') ? 0 : (gameMode === 'image' ? parseInt(t.id.replace('tile-', '')) : parseInt(t.querySelector('.tile-inner')?.textContent)));

                for (let i = 0; i < actualTileValues.length - 1 && obstaclesAdded < count; i++) {
                    const tileValue = actualTileValues[i];
                    // Obstacles are on tiles that are already in their correct *target* position, but not the empty tile
                    if (tileValue !== 0 && tileValue === checkTargetOrder[i]) { 
                        const tileElement = tiles[i]; // Get the actual DOM element at this position
                        tileElement.classList.add('obstacle-tile');
                        obstacleTiles.add(tileElement.id);
                        tileElement.style.pointerEvents = 'none';
                        obstaclesAdded++;
                    }
                }
            }
            if (gameMode === 'memory') {
                tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.add('hidden-number'); } });
                const currentMode = gameModes.find(mode => mode.id === gameMode);
                setTimeout(() => {
                    tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.add('revealed'); } });
                    memoryRevealTimeout = setTimeout(() => {
                        tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.remove('revealed'); } });
                    }, currentMode.revealTime);
                }, 500); 
            }
            if (gameMode === 'image' && imageModeData.image) { applyImageToTiles(); }
            if (gameMode === 'darkness') {
                tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.add('darkness-hidden'); } });
                revealDarknessTiles(emptyTileIndex);
            }
            if (gameMode === 'hidden_path') {
                tiles.forEach(tile => { if (!tile.classList.contains('empty-tile')) { tile.classList.add('hidden-path-hidden'); } });
                updateHiddenPathTiles(emptyTileIndex);
            }
        }

        // isSolvable: Checks if the current board state (array of numbers) is solvable
        function isSolvable(boardArray, size, emptyTileCurrentIndex) {
            let inversions = 0;
            const tempArr = boardArray.filter(n => n !== 0); // Exclude the empty tile for inversion count

            for (let i = 0; i < tempArr.length - 1; i++) {
                for (let j = i + 1; j < tempArr.length; j++) {
                    if (tempArr[i] > tempArr[j]) {
                        inversions++;
                    }
                }
            }

            const emptyRow = Math.floor(emptyTileCurrentIndex / size); // 0-indexed row
            const emptyRowFromBottom = size - emptyRow; // 1-indexed from bottom

            if (size % 2 === 1) { // Odd grid size
                return inversions % 2 === 0;
            } else { // Even grid size
                if (emptyRowFromBottom % 2 === 1) { // Empty tile on an odd row from bottom
                    return inversions % 2 === 0;
                } else { // Empty tile on an even row from bottom
                    return inversions % 2 === 1;
                }
            }
        }


        function isValidMove(fromIndex, toIndex, size) {
            const rowDiff = Math.abs(Math.floor(fromIndex / size) - Math.floor(toIndex / size));
            const colDiff = Math.abs((fromIndex % size) - (toIndex % size));
            return rowDiff + colDiff === 1;
        }

        function checkCompletedLines(size) {
            let completedLines = 0;
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            
            // Convert DOM tiles to a simple board array for logical checks
            const currentBoard = tiles.map(tile => {
                if (tile.classList.contains('empty-tile')) return 0;
                return gameMode === 'image' ? parseInt(tile.id.replace('tile-', '')) : parseInt(tile.querySelector('.tile-inner')?.textContent);
            });

            // Check rows
            for (let row = 0; row < size; row++) {
                let isRowComplete = true;
                for (let col = 0; col < size; col++) {
                    const index = row * size + col;
                    if (currentBoard[index] === 0) { isRowComplete = false; break; }
                    const expectedNumber = checkTargetOrder[index];
                    if (currentBoard[index] !== expectedNumber) { isRowComplete = false; break; }
                }
                if (isRowComplete) completedLines++;
            }
            // Check columns
            for (let col = 0; col < size; col++) {
                let isColComplete = true;
                for (let row = 0; row < size; row++) {
                    const index = row * size + col;
                    if (currentBoard[index] === 0) { isColComplete = false; break; }
                    const expectedNumber = checkTargetOrder[index];
                    if (currentBoard[index] !== expectedNumber) { isColComplete = false; break; }
                }
                if (isColComplete) completedLines++;
            }
            return completedLines;
        }

        async function moveTile(tileIndex, size, isAutoSolve = false, isHintMove = false) { 
            if (isSolvingPuzzle && !isAutoSolve && !isHintMove) return; 
            if (tileIndex === emptyTileIndex) return;
            if (gameMode === 'obstacle' && obstacleTiles.has(tiles[tileIndex].id)) { return; }
            
            // NEW: If it's a manual move, invalidate the current solver/hint path
            if (!isAutoSolve && !isHintMove && currentSolverPath) {
                currentSolverPath = null;
                currentSolverPathStep = 0;
                updateSolverMessage(''); // Clear any active solver/hint messages
            }

            if (isValidMove(tileIndex, emptyTileIndex, size)) {
                if (gameMode === 'time' && !isTimeModeGameStarted) {
                    isTimeModeGameStarted = true;
                    hintMessage.classList.remove('active');
                    startTimer();
                }

                // Update the DOM elements' positions
                [tiles[emptyTileIndex], tiles[tileIndex]] = [tiles[tileIndex], tiles[emptyTileIndex]];
                
                // Update the logical board state as well
                [currentBoardState[emptyTileIndex], currentBoardState[tileIndex]] = [currentBoardState[tileIndex], currentBoardState[emptyTileIndex]];

                emptyTileIndex = tileIndex;
                
                if (gameMode === 'teleport') { await applyTeleport(); }
                else if (gameMode === 'vortex') { await applyVortex(); }
                
                renderTiles(size, 'move');
                
                // Increment moves regardless of whether it's auto-solve or manual
                gameStats.currentMoves++;
                gameStats.totalMoves++;
                
                addScore(1);

                if (gameMode === 'moves') {
                    movesLeft--;
                    if (movesLeft <= 0 && !checkWin(size)) { endGame(false, '–•–æ–¥—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å!'); return; }
                }
                if (gameMode === 'memory') {
                    const currentMode = gameModes.find(mode => mode.id === gameMode);
                    const movedTile = tiles[tileIndex];
                    movedTile.classList.add('revealed');
                    clearTimeout(memoryRevealTimeout); 
                    memoryRevealTimeout = setTimeout(() => { movedTile.classList.remove('revealed'); }, currentMode.revealTime);
                }
                if (gameMode === 'darkness') { revealDarknessTiles(emptyTileIndex); }
                if (gameMode === 'hidden_path') { updateHiddenPathTiles(emptyTileIndex); }
                
                saveStats();
                checkAchievements();
                
                const completedLines = checkCompletedLines(size);
                if (completedLines > 0) { addScore(completedLines * 10); }
                
                const movedTile = tiles[tileIndex];
                const tileContent = gameMode === 'image' ? parseInt(movedTile.id.replace('tile-', '')) : parseInt(movedTile.querySelector('.tile-inner')?.textContent);
                const expectedForHighlight = (gameMode === 'reverse') ? targetOrder[tileIndex] : (tileIndex + 1);
                
                if (tileContent === expectedForHighlight) {
                    movedTile.classList.add('correct-position');
                    setTimeout(() => { movedTile.classList.remove('correct-position'); }, 1000);
                }
                highlightCorrectTiles(size); 
                updateScore(); 
                
                if (isAutoHighlighting) {
                    const nextNumber = checkTilePositions();
                    if (nextNumber) { highlightNumber(nextNumber); }
                }
                
                if (checkWin(size)) { 
                    endGame(true, `–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –í—ã —Å–æ–±—Ä–∞–ª–∏ –≤—Å–µ –ø–ª–∏—Ç–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ!\n–í–∞—à —Å—á–µ—Ç: ${currentScore}\n–•–æ–¥–æ–≤ —Å–¥–µ–ª–∞–Ω–æ: ${gameStats.currentMoves}`); 
                    return true; 
                }
                return false; 
            }
            return false; 
        }

        async function applyTeleport() {
            teleportMoveCounter++;
            const currentMode = gameModes.find(mode => mode.id === 'teleport');
            const frequency = currentMode.teleportFrequency(currentSize);
            if (teleportMoveCounter >= frequency) {
                teleportMoveCounter = 0;
                const oldEmptyIndex = emptyTileIndex;
                const availableSpots = tiles.map((tile, index) => index).filter(index => index !== oldEmptyIndex && !tiles[index].classList.contains('obstacle-tile'));
                if (availableSpots.length > 0) {
                    const newEmptyIndex = availableSpots[Math.floor(Math.random() * availableSpots.length)];
                    // Update DOM
                    [tiles[oldEmptyIndex], tiles[newEmptyIndex]] = [tiles[newEmptyIndex], tiles[oldEmptyIndex]];
                    // Update logical board state
                    [currentBoardState[oldEmptyIndex], currentBoardState[newEmptyIndex]] = [currentBoardState[newEmptyIndex], currentBoardState[oldEmptyIndex]];

                    emptyTileIndex = newEmptyIndex;
                    renderTiles(currentSize);
                    await new Promise(resolve => setTimeout(resolve, 150));
                }
            }
        }

        async function applyVortex() {
            const emptyRow = Math.floor(emptyTileIndex / currentSize);
            const emptyCol = emptyTileIndex % currentSize;
            const possibleMoves = [];
            if (emptyRow > 0) possibleMoves.push(emptyTileIndex - currentSize);
            if (emptyRow < currentSize - 1) possibleMoves.push(emptyTileIndex + currentSize);
            if (emptyCol > 0) possibleMoves.push(emptyTileIndex - 1);
            if (emptyCol < currentSize - 1) possibleMoves.push(emptyTileIndex + 1);
            if (possibleMoves.length > 0) {
                const validMoves = possibleMoves.filter(index => !tiles[index].classList.contains('obstacle-tile'));
                if (validMoves.length > 0) {
                    const randomIndex = validMoves[Math.floor(Math.random() * validMoves.length)];
                    // Update DOM
                    [tiles[emptyTileIndex], tiles[randomIndex]] = [tiles[randomIndex], tiles[emptyTileIndex]];
                     // Update logical board state
                    [currentBoardState[emptyTileIndex], currentBoardState[randomIndex]] = [currentBoardState[randomIndex], currentBoardState[emptyTileIndex]];

                    emptyTileIndex = randomIndex;
                    renderTiles(currentSize);
                    await new Promise(resolve => setTimeout(resolve, 150));
                }
            }
        }

        function revealDarknessTiles(centerIndex) {
            const centerRow = Math.floor(centerIndex / currentSize);
            const centerCol = centerIndex % currentSize;
            const offsets = [ [-1, -1], [-1, 0], [-1, 1], [0, -1],  [0, 0], [0, 1], [1, -1],  [1, 0], [1, 1] ];
            const newlyRevealedIndexes = new Set();
            for (const [dr, dc] of offsets) {
                const checkRow = centerRow + dr;
                const checkCol = centerCol + dc;
                if (checkRow >= 0 && checkRow < currentSize && checkCol >= 0 && checkCol < currentSize) {
                    newlyRevealedIndexes.add(checkRow * currentSize + checkCol);
                }
            }
            tiles.forEach((tile, index) => {
                 if (!tile.classList.contains('empty-tile')) {
                    if(newlyRevealedIndexes.has(index)) { tile.classList.remove('darkness-hidden'); }
                    else { tile.classList.add('darkness-hidden'); }
                 }
            });
        }

        function updateHiddenPathTiles(emptyIndex) {
            const emptyRow = Math.floor(emptyIndex / currentSize);
            const emptyCol = emptyIndex % currentSize;
            const adjacentOffsets = [ [-1, 0], [1, 0], [0, -1], [0, 1] ];
            const visibleIndexes = new Set();
            for (const [dr, dc] of adjacentOffsets) {
                const checkRow = emptyRow + dr;
                const checkCol = emptyCol + dc;
                if (checkRow >= 0 && checkRow < currentSize && checkCol >= 0 && checkCol < currentSize) {
                    visibleIndexes.add(checkRow * currentSize + checkCol);
                }
            }
            tiles.forEach((tile, index) => {
                if(!tile.classList.contains('empty-tile')) {
                    if (visibleIndexes.has(index)) { tile.classList.remove('hidden-path-hidden'); }
                    else { tile.classList.add('hidden-path-hidden'); }
                }
            });
        }

        function checkWin(size) {
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            for (let i = 0; i < size * size - 1; i++) {
                const tileContent = gameMode === 'image' ? parseInt(tiles[i].id.replace('tile-', '')) : parseInt(tiles[i].querySelector('.tile-inner')?.textContent);
                if (tileContent !== checkTargetOrder[i]) { return false; }
            }
            return true;
        }

        function endGame(win, message) {
            stopGameMechanisms(); 
            if (win) {
                vibrationManager.win();
                showWinAnimation(); 
            } else {
                vibrationManager.error();
                showMessageModal('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!', message + '\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑!', () => { shuffleTiles(true); });
            }
            isSolvingPuzzle = false; 
            isCalculatingPath = false; // NEW
            solveBtn.disabled = false;
            hintBtn.disabled = false; 
            shuffleBtn.disabled = false; 
            applySizeBtn.disabled = false; 
            updateSolverMessage(''); // NEW: Clear messages
            // REMOVED: backgroundMusic.play().catch(e => console.error("Error playing music:", e)); 
        }

        function showWinAnimation() {
            gameStats.totalGamesWon++;
            gameStats.totalScore += currentScore;
            if (!gameStats.gamesWonBySize[currentSize]) { gameStats.gamesWonBySize[currentSize] = 0; }
            gameStats.gamesWonBySize[currentSize]++;
            const currentRecord = gameStats.gameRecords[gameMode][currentSize];
            currentRecord.gamesPlayed++;
            if (gameMode === 'time') {
                const timeTaken = gameModes.find(mode => mode.id === gameMode).getLimits(currentSize).time - timeLeft;
                if (timeTaken < currentRecord.bestTime) currentRecord.bestTime = timeTaken;
                if (currentRecord.worstTime === 0 || timeTaken > currentRecord.worstTime) currentRecord.worstTime = timeTaken;
            } else { 
                const movesTaken = gameStats.currentMoves;
                if (movesTaken < currentRecord.bestMoves) currentRecord.bestMoves = movesTaken;
                if (currentRecord.worstMoves === 0 || movesTaken > currentRecord.worstMoves) currentRecord.worstMoves = movesTaken;
            }
            if (usedAutoSolveInCurrentGame) { 
                gameStats.autoSolvedGames++;
            } else if (usedHintInCurrentGame) { 
                gameStats.winsWithHints++;
            }

            saveStats();
            checkAchievements();
            renderStatistics();
            createConfetti();
            setTimeout(() => {
                showMessageModal('üéâ –ü–æ–±–µ–¥–∞!', `–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –í—ã —Å–æ–±—Ä–∞–ª–∏ –≤—Å–µ –ø–ª–∏—Ç–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ!\n–í–∞—à —Å—á–µ—Ç: ${currentScore}\n–•–æ–¥–æ–≤ —Å–¥–µ–ª–∞–Ω–æ: ${gameStats.currentMoves}`);
            }, 1000);
        }

        function createConfetti() {
            const colors = ['#fd79a8', '#74b9ff', '#55efc4', '#ffeaa7', '#a29bfe'];
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = Math.random() * 10 + 5 + 'px';
                confetti.style.height = Math.random() * 10 + 5 + 'px';
                confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
                confetti.style.animationDelay = Math.random() * 2 + 's';
                document.body.appendChild(confetti);
                setTimeout(() => { confetti.remove(); }, 5000);
            }
        }

        // ‚ú® –ò–°–ü–†–ê–í–õ–ï–ù–û: –§—É–Ω–∫—Ü–∏—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ —Ç–µ–ø–µ—Ä—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–∞–∑–¥–µ–ª—è–µ—Ç –∞–Ω–∏–º–∞—Ü–∏–∏
        function renderTiles(size, animationType = 'move') {
            if (animationType === 'initial') {
                // –í–æ–∑–≤—Ä–∞—â–µ–Ω–∞ —Å—Ç–∞—Ä–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª—è
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / size);
                    const col = index % size;
                    const targetX = col * (tileSize + tileGap);
                    const targetY = row * (tileSize + tileGap);

                    tile.style.transition = 'none';
                    tile.style.transform = `translate(${targetX}px, ${targetY - 20}px)`; 
                    tile.style.opacity = 0;

                    const delay = index * 25; // –¢–∞ —Å–∞–º–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ "–∑–º–µ–π–∫–∏"
                    setTimeout(() => {
                        tile.style.transition = 'transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease';
                        tile.style.transform = `translate(${targetX}px, ${targetY}px)`;
                        tile.style.opacity = 1;
                        vibrationManager.tileAppear();
                    }, delay);
                });
            } else if (animationType === 'shuffle') {
                // "–õ–µ—Ç–∞—é—â–∞—è" –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è
                vibrationManager.shuffle();
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / size);
                    const col = index % size;
                    const targetX = col * (tileSize + tileGap);
                    const targetY = row * (tileSize + tileGap);
                    tile.style.opacity = 1; 
                    const randomDelay = Math.random() * 200;
                    tile.style.transition = `transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) ${randomDelay}ms`;
                    tile.style.transform = `translate(${targetX}px, ${targetY}px)`;
                });
            } else { // 'move'
                // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è —Ö–æ–¥–æ–≤ –∏–≥—Ä–æ–∫–∞
                tiles.forEach((tile, index) => {
                    const row = Math.floor(index / size); 
                    const col = index % size;
                    const targetX = col * (tileSize + tileGap);
                    const targetY = row * (tileSize + tileGap);
                    tile.style.transition = `transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease`;
                    tile.style.transform = `translate(${targetX}px, ${targetY}px)`;
                    tile.style.opacity = 1;
                });
            }
            highlightCorrectTiles(size);
        }

        function highlightCorrectTiles(size) {
            const checkTargetOrder = (gameMode === 'reverse') ? targetOrder : Array.from({length: currentSize * currentSize - 1}, (_, i) => i + 1);
            tiles.forEach((tile, index) => {
                const tileInner = tile.querySelector('.tile-inner');
                if (tileInner || gameMode === 'image') { 
                    const tileValue = gameMode === 'image' ? parseInt(tile.id.replace('tile-', '')) : parseInt(tileInner.textContent);
                    let isCorrect = (tileValue === checkTargetOrder[index]);
                    if (isCorrect) {
                        tile.classList.add('correct');
                        // –ó–¥–µ—Å—å correctColorPicker.value –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –≤—ã–±–æ—Ä
                        tile.style.borderColor = correctColorPicker.value; 
                    } else {
                        tile.classList.remove('correct');
                        tile.style.borderColor = 'transparent';
                    }
                }
            });
        }
        
        // Corrected updateColors to only set user overrides
        function updateColors(colorType) {
            document.documentElement.style.setProperty('--user-override-tile-color', tileColorPicker.value);
            document.documentElement.style.setProperty('--user-override-background-body', bgColorPicker.value);
            document.documentElement.style.setProperty('--user-override-border-game-field', borderColorPicker.value);
            document.documentElement.style.setProperty('--user-override-tile-text-color', textColorPicker.value);
            document.documentElement.style.setProperty('--user-override-highlight-color', highlightColorPicker.value);
            document.documentElement.style.setProperty('--user-override-correct-color', correctColorPicker.value);

            // Re-apply visual updates based on current effective CSS variables
            applyVisualUpdates(); 
            renderMusicPlaylist(); // To update music playlist text color

            gameStats.colorsChanged.add(colorType);
            saveStats();
            checkAchievements();
        }

        function saveStats() {
            const statsToSave = { ...gameStats, playedSizes: Array.from(gameStats.playedSizes), colorsChanged: Array.from(gameStats.colorsChanged), styleChanges: Array.from(gameStats.styleChanges), modesTried: Array.from(gameStats.modesTried) };
            localStorage.setItem('gameStats_v9', JSON.stringify(statsToSave)); 
            localStorage.setItem('completedAchievements_v9', JSON.stringify(completedAchievements)); 
            localStorage.setItem('solverMode_v1', solverMode); 
            localStorage.setItem('solverAnimationSpeed_v1', solverAnimationSpeed); 
            localStorage.setItem('customFontLoaded_v1', customFontLoaded); // NEW
            localStorage.setItem('customFontUrl_v1', customFontUrl); // NEW
            localStorage.setItem('customFontApplyScope_v1', customFontApplyScope); // NEW
            localStorage.setItem('musicPlaylistData_v1', JSON.stringify(musicPlaylistData)); // NEW
            localStorage.setItem('currentMusicIndex_v1', currentMusicIndex); // NEW
            localStorage.setItem('musicVolume_v1', backgroundMusic.volume); // NEW
            localStorage.setItem('showSolverModal_v1', showSolverModal); // NEW
            localStorage.setItem('theme_v1', currentTheme); // NEW: Save current theme
        }

        function loadStats() {
            const savedStats = localStorage.getItem('gameStats_v9');
            const savedAchievements = localStorage.getItem('completedAchievements_v9');
            const savedSolverMode = localStorage.getItem('solverMode_v1'); 
            const savedSolverAnimationSpeed = localStorage.getItem('solverAnimationSpeed_v1'); 
            const savedCustomFontLoaded = localStorage.getItem('customFontLoaded_v1'); // NEW
            const savedCustomFontUrl = localStorage.getItem('customFontUrl_v1'); // NEW
            const savedCustomFontApplyScope = localStorage.getItem('customFontApplyScope_v1'); // NEW
            const savedMusicPlaylistData = localStorage.getItem('musicPlaylistData_v1'); // NEW
            const savedCurrentMusicIndex = localStorage.getItem('currentMusicIndex_v1'); // NEW
            const savedMusicVolume = localStorage.getItem('musicVolume_v1'); // NEW
            const savedShowSolverModal = localStorage.getItem('showSolverModal_v1'); // NEW
            const savedTheme = localStorage.getItem('theme_v1'); // NEW: Load saved theme

            initializeStats(); 
            if (savedStats) {
                const parsedStats = JSON.parse(savedStats);
                Object.assign(gameStats, parsedStats);
                gameStats.playedSizes = new Set(parsedStats.playedSizes || []);
                gameStats.colorsChanged = new Set(parsedStats.colorsChanged || []);
                gameStats.styleChanges = new Set(parsedStats.styleChanges || []);
                gameStats.modesTried = new Set(parsedStats.modesTried || ['classic']);
                if (parsedStats.gameRecords) {
                    for (const modeId in gameStats.gameRecords) {
                        if (parsedStats.gameRecords[modeId]) {
                            for (const size in gameStats.gameRecords[modeId]) {
                                if (parsedStats.gameRecords[modeId][size]) {
                                    Object.assign(gameStats.gameRecords[modeId][size], parsedStats.gameRecords[modeId][size]);
                                }
                            }
                        }
                    }
                }
            }
            if (savedAchievements) { completedAchievements = JSON.parse(savedAchievements); }
            if (savedSolverMode) { solverMode = savedSolverMode; } 
            if (savedSolverAnimationSpeed) { solverAnimationSpeed = parseInt(savedSolverAnimationSpeed); } 
            if (savedCustomFontLoaded) { customFontLoaded = savedCustomFontLoaded === 'true'; } // NEW
            if (savedCustomFontUrl) { customFontUrl = savedCustomFontUrl; } // NEW
            if (savedCustomFontApplyScope) { customFontApplyScope = savedCustomFontApplyScope; } // NEW
            if (savedMusicPlaylistData) { musicPlaylistData = JSON.parse(savedMusicPlaylistData); } // NEW
            if (savedCurrentMusicIndex) { currentMusicIndex = parseInt(savedCurrentMusicIndex); } // NEW
            if (savedMusicVolume) { backgroundMusic.volume = parseFloat(savedMusicVolume); } // NEW
            if (savedShowSolverModal) { showSolverModal = savedShowSolverModal === 'true'; } // NEW
            
            // Apply saved theme first
            if (savedTheme) { 
                currentTheme = savedTheme;
                body.classList.add(currentTheme);
            } else {
                currentTheme = 'light-theme'; // Default
                body.classList.remove('dark-theme');
            }
            // Update button text and class based on loaded theme
            updateThemeButton();

            calculateAchievementScore();
            renderAchievements();
            renderStatistics();
            // Restore color pickers to their current active theme colors
            updateColorPickersFromCSS();
        }

        // NEW function to update color pickers based on current computed CSS variables
        function updateColorPickersFromCSS() {
            const computedStyle = getComputedStyle(document.documentElement);
            // Read computed (effective) values from CSS and apply to picker inputs
            tileColorPicker.value = rgbToHex(computedStyle.getPropertyValue('--user-override-tile-color').trim() || computedStyle.getPropertyValue('--tile-color').trim());
            bgColorPicker.value = rgbToHex(computedStyle.getPropertyValue('--user-override-background-body').trim() || computedStyle.getPropertyValue('--background-body').trim());
            borderColorPicker.value = rgbToHex(computedStyle.getPropertyValue('--user-override-border-game-field').trim() || computedStyle.getPropertyValue('--border-game-field').trim());
            textColorPicker.value = rgbToHex(computedStyle.getPropertyValue('--user-override-tile-text-color').trim() || computedStyle.getPropertyValue('--tile-text-color').trim());
            highlightColorPicker.value = rgbToHex(computedStyle.getPropertyValue('--user-override-highlight-color').trim() || computedStyle.getPropertyValue('--highlight-color').trim());
            correctColorPicker.value = rgbToHex(computedStyle.getPropertyValue('--user-override-correct-color').trim() || computedStyle.getPropertyValue('--correct-color').trim());
        }

        // Helper function to convert RGB to Hex (for color pickers)
        function rgbToHex(rgb) {
            // Check if it's already a hex color
            if (rgb.startsWith('#')) return rgb;
            // Handle rgba colors by converting to rgb first (ignoring alpha for now)
            const rgbaMatch = /rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/.exec(rgb);
            if (rgbaMatch) {
                 rgb = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
            }
            const result = /rgb\((\d+),\s*(\d+),\s*(\d+)\)/.exec(rgb);
            return result ? '#' + 
                (1 << 24 | parseInt(result[1]).toString(16) << 16 | parseInt(result[2]).toString(16) << 8 | parseInt(result[3]).toString(16)).toString(16).slice(1) : '#000000'; // Default to black if conversion fails
        }


        function calculateAchievementScore() {
            let total = 0;
            completedAchievements.forEach(achId => {
                const achievement = achievementsData.find(a => a.id === achId);
                if (achievement) { total += achievement.points; }
            });
            gameStats.achievementScore = total;
            saveStats();
        }

        function checkAchievements() {
            let changed = false;
            achievementsData.forEach(achievement => {
                if (!completedAchievements.includes(achievement.id) && achievement.condition(gameStats)) {
                    completedAchievements.push(achievement.id);
                    showAchievementUnlocked(achievement);
                    gameStats.achievementScore += achievement.points;
                    changed = true;
                }
            });
            if(changed) { saveStats(); renderAchievements(); renderStatistics(); }
        }

        function showAchievementUnlocked(achievement) {
            const notification = document.createElement('div');
            notification.className = 'achievement-notification';
            notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: var(--background-card); padding: 15px; border-radius: 10px; box-shadow: 0 5px 15px var(--box-shadow-card); display: flex; align-items: center; gap: 15px; z-index: 1000; transform: translateX(200%); transition: transform 0.5s ease; color: var(--text-main);'; /* Added theme variables */
            notification.innerHTML = `<div class="achievement-icon" style="background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.5rem;"><i class="fas ${achievement.icon}"></i></div><div><div style="font-weight: bold; color: var(--primary-color);">–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ!</div><div style="font-weight: 600; margin: 5px 0;">${achievement.title}</div><div style="font-size: 0.9rem; color: var(--text-secondary);">+${achievement.points} –æ—á–∫–æ–≤</div></div>`; /* Added theme variables */
            document.body.appendChild(notification);
            setTimeout(() => { notification.style.transform = 'translateX(0)'; }, 100);
            setTimeout(() => { notification.style.transform = 'translateX(200%)'; setTimeout(() => { notification.remove(); }, 500); }, 5000);
        }

        function renderAchievements() {
            achievementsGrid.innerHTML = '';
            achievementsData.forEach(achievement => {
                const isCompleted = completedAchievements.includes(achievement.id);
                const progress = achievement.progress(gameStats);
                const card = document.createElement('div');
                card.className = `achievement-card ${isCompleted ? '' : 'locked'}`;
                card.innerHTML = `<div class="achievement-icon"><i class="fas ${achievement.icon}"></i></div><div class="achievement-title">${achievement.title}</div><div class="achievement-desc">${achievement.description}</div><div class="achievement-progress"><div class="progress-bar" style="width: ${progress * 100}%"></div></div><div class="achievement-points">+${achievement.points} –æ—á–∫–æ–≤</div>${isCompleted ? '<div class="ribbon">–ü–æ–ª—É—á–µ–Ω–æ!</div>' : ''}`;
                achievementsGrid.appendChild(card);
            });
        }
        
        function renderStatistics() {
            statsGrid.innerHTML = `<div class="stats-card"><i class="fas fa-gamepad stats-icon"></i><div class="stats-value">${gameStats.totalGamesWon}</div><div class="stats-label">–°–æ–±—Ä–∞–Ω–æ –∏–≥—Ä</div></div><div class="stats-card"><i class="fas fa-arrows-alt-h stats-icon"></i><div class="stats-value">${gameStats.totalMoves}</div><div class="stats-label">–ü–µ—Ä–µ–¥–≤–∏–Ω—É—Ç–æ –ø–ª–∏—Ç–æ–∫</div></div><div class="stats-card"><i class="fas fa-coins stats-icon"></i><div class="stats-value">${gameStats.totalScore}</div><div class="stats-label">–û—á–∫–æ–≤ –ø–æ–ª—É—á–µ–Ω–æ</div></div><div class="stats-card"><i class="fas fa-trophy stats-icon"></i><div class="stats-value">${gameStats.achievementScore}</div><div class="stats-label">–û—á–∫–∏ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è</div></div>
            <div class="stats-card"><i class="fas fa-lightbulb stats-icon"></i><div class="stats-value">${gameStats.hintsUsed}</div><div class="stats-label">–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –ø–æ–¥—Å–∫–∞–∑–æ–∫</div></div><div class="stats-card"><i class="fas fa-magic stats-icon"></i><div class="stats-value">${gameStats.autoSolvedGames}</div><div class="stats-label">–ê–≤—Ç–æ-—Ä–µ—à–µ–Ω–æ –∏–≥—Ä</div></div>
            <div class="stats-list-card"><h3>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ä–µ–∂–∏–º–∞–º –∏ —Ä–∞–∑–º–µ—Ä–∞–º:</h3><ul class="stats-list" id="statsModeSizeList"></ul></div>`;
            const modeSizeList = document.getElementById('statsModeSizeList');
            gameModes.forEach(mode => {
                const modeLi = document.createElement('li');
                modeLi.innerHTML = `<span class="stats-list-label">${mode.title}</span><span class="stats-list-value"></span>`;
                modeSizeList.appendChild(modeLi);
                const subList = document.createElement('ul');
                subList.className = 'stats-sub-list';
                modeLi.appendChild(subList);
                const sortedSizes = Object.keys(gameStats.gameRecords[mode.id]).sort((a,b) => parseInt(a) - parseInt(b));
                let modeHasData = false;
                sortedSizes.forEach(size => {
                    const record = gameStats.gameRecords[mode.id][size];
                    if (record.gamesPlayed > 0) {
                        modeHasData = true;
                        const sizeLi = document.createElement('li');
                        let statsHtml = `<span>–ü–æ–ª–µ ${size}x${size}:</span><span>–ò–≥—Ä: ${record.gamesPlayed}`;
                        if (record.bestMoves !== Infinity) { statsHtml += `, –•–æ–¥—ã: ${record.bestMoves}`; if (record.worstMoves !== 0 && record.worstMoves !== Infinity && record.worstMoves !== record.bestMoves) { statsHtml += ` (—Ö—É–¥—à: ${record.worstMoves})`; } }
                        if (record.bestTime !== Infinity) {
                            const bestMin = Math.floor(record.bestTime / 60); const bestSec = record.bestTime % 60; const worstMin = Math.floor(record.worstTime / 60); const worstSec = Math.floor(record.worstTime % 60);
                            statsHtml += `, –í—Ä–µ–º—è: ${bestMin.toString().padStart(2, '0')}:${bestSec.toString().padStart(2, '0')}`;
                            if (record.worstTime !== 0 && record.worstTime !== Infinity && record.worstTime !== record.bestTime) { statsHtml += ` (—Ö—É–¥—à: ${worstMin.toString().padStart(2, '0')}:${worstSec.toString().padStart(2, '0')})`; }
                        }
                        statsHtml += `</span>`;
                        sizeLi.innerHTML = statsHtml;
                        subList.appendChild(sizeLi);
                    }
                });
                if (!modeHasData) {
                    const noDataLi = document.createElement('li');
                    noDataLi.textContent = '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç—Ç–æ–≥–æ —Ä–µ–∂–∏–º–∞.';
                    subList.appendChild(noDataLi);
                }
            });
        }

        function renderModes() {
            modesGrid.innerHTML = '';
            gameModes.forEach(mode => {
                const card = document.createElement('div');
                card.className = `mode-card ${mode.active ? 'active' : ''}`;
                card.dataset.mode = mode.id;
                card.innerHTML = `<div class="mode-icon"><i class="fas ${mode.icon}"></i></div><div class="mode-title">${mode.title}</div><div class="mode-desc">${mode.description}</div>`;
                if (mode.id === 'image') {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'input-group';
                    inputGroup.style.marginTop = '10px';
                    const imageInput = document.createElement('input');
                    imageInput.type = 'file';
                    imageInput.accept = 'image/*';
                    imageInput.id = 'image-upload-input';
                    imageInput.addEventListener('change', (e) => { loadImageForMode(e.target.files[0]); });
                    const imageLabel = document.createElement('label');
                    imageLabel.htmlFor = 'image-upload-input';
                    imageLabel.className = 'btn btn-block';
                    imageLabel.innerHTML = '<i class="fas fa-upload"></i> –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª';
                    inputGroup.appendChild(imageInput);
                    inputGroup.appendChild(imageLabel);
                    card.appendChild(inputGroup);
                }
                card.addEventListener('click', (e) => {
                    if (e.target.closest('label[for="image-upload-input"]')) { return; }
                    setActiveMode(mode.id);
                });
                modesGrid.appendChild(card);
            });
        }

        function setActiveMode(modeId) {
            gameMode = modeId;
            gameStats.modesTried.add(modeId);
            saveStats();
            checkAchievements();
            gameModes.forEach(mode => { mode.active = (mode.id === modeId); });
            document.querySelectorAll('.mode-card').forEach(card => { card.classList.toggle('active', card.dataset.mode === modeId); });
            createGame(currentSize); 
            shuffleTiles(true); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –∞–Ω–∏–º–∞—Ü–∏—é –ø—Ä–∏ —Å–º–µ–Ω–µ —Ä–µ–∂–∏–º–∞
            if (gameMode === 'time') { hintMessage.classList.add('active'); }
            else { hintMessage.classList.remove('active'); stopGameMechanisms(); }
        }

        function loadImageForMode(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    imageModeData.image = img;
                    imageModeData.imageUrl = e.target.result;
                    if (!imageModeData.canvas) {
                        imageModeData.canvas = document.createElement('canvas');
                        imageModeData.ctx = imageModeData.canvas.getContext('2d');
                        imageModeData.canvas.style.display = 'none';
                        document.body.appendChild(imageModeData.canvas);
                    }
                    imageModeData.canvas.width = img.width;
                    imageModeData.canvas.height = img.height;
                    imageModeData.ctx.drawImage(img, 0, 0);
                    if (gameMode === 'image') { applyImageToTiles(); }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function applyImageToTiles() {
            if (!imageModeData.image || !imageModeData.ctx) return;
            const img = imageModeData.image;
            const tileWidth = img.width / currentSize;
            const tileHeight = img.height / currentSize;
            tiles.forEach((tile, index) => {
                if (tile.classList.contains('empty-tile')) {
                    tile.style.backgroundImage = ''; tile.style.backgroundSize = ''; tile.style.backgroundPosition = ''; return;
                }
                const originalNumber = parseInt(tile.id.replace('tile-', ''));
                const originalIndex = originalNumber - 1; // Assuming original number corresponds to its sorted position
                const col = originalIndex % currentSize;
                const row = Math.floor(originalIndex / currentSize);
                const sx = col * tileWidth;
                const sy = row * tileHeight;
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = tileWidth;
                tempCanvas.height = tileHeight;
                tempCtx.drawImage(img, sx, sy, tileWidth, tileHeight, 0, 0, tileWidth, tileHeight);
                tile.style.backgroundImage = `url(${tempCanvas.toDataURL()})`;
                tile.style.backgroundSize = 'cover'; 
                tile.style.backgroundPosition = 'center';
                const tileInner = tile.querySelector('.tile-inner');
                if (tileInner) tileInner.style.display = 'none'; 
            });
        }

        function showMessageModal(title, message, onCloseCallback = null) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.classList.add('active');
            const closeHandler = () => {
                messageModal.classList.remove('active');
                modalCloseBtn.removeEventListener('click', closeHandler);
                if (onCloseCallback) { onCloseCallback(); }
            };
            modalCloseBtn.addEventListener('click', closeHandler);
        }

        // NEW: Function to update solver messages (modal or header)
        function updateSolverMessage(message, title = '–†–µ—à–µ–Ω–∏–µ –≥–æ–ª–æ–≤–æ–ª–æ–º–∫–∏...') {
            if (showSolverModal) {
                document.getElementById('loadingTitle').textContent = title;
                document.getElementById('loadingMessage').textContent = message;
                loadingModal.classList.add('active');
                solverMessageDisplay.style.display = 'none';
            } else {
                loadingModal.classList.remove('active');
                solverMessageDisplay.style.display = 'block';
                solverMessageDisplay.innerHTML = `<i class="fas fa-info-circle"></i> <span>${message}</span>`;
            }
        }

        // NEW: Function to hide loading overlay
        function hideLoadingOverlay() {
            loadingModal.classList.remove('active');
            solverMessageDisplay.style.display = 'none';
        }
        
        // Helper to convert 1D index to 2D coordinates
        function getCoords(index, size) {
            return { row: Math.floor(index / size), col: index % size };
        }

        // Helper to convert 2D coordinates to 1D index
        function getIndex(row, col, size) {
            return row * size + col;
        }

        // Manhattan Distance for A* heuristic
        function manhattanDistance(board, size, goalBoard) {
            let distance = 0;
            for (let i = 0; i < board.length; i++) {
                const value = board[i];
                if (value === 0) continue; // Empty tile doesn't contribute to distance

                const currentRow = Math.floor(i / size);
                const currentCol = i % size;

                const goalIndex = goalBoard.indexOf(value);
                if (goalIndex === -1) continue; 

                const goalRow = Math.floor(goalIndex / size);
                const goalCol = goalIndex % size;

                distance += Math.abs(currentRow - goalRow) + Math.abs(currentCol - goalCol);
            }
            return distance;
        }

        // A* search to find path for specific goals, respecting locked tiles
        async function findPathToGoal(startBoard, size, targetGoals, lockedTileValues) {
            const openList = []; // Priority Queue: [fScore, gScore, boardState, emptyIndex, pathOfMoves (indices of tiles moved)]
            const closedList = new Set(); // Stores stringified board states

            const startEmptyIndex = startBoard.indexOf(0);

            // Heuristic function for the current phase's goals
            const heuristic = (boardState) => {
                let h = 0;
                for (const tileValStr in targetGoals) {
                    const tileVal = parseInt(tileValStr);
                    const goalPos = targetGoals[tileValStr]; // {row, col}
                    
                    const currentPosIndex = boardState.indexOf(tileVal);
                    if (currentPosIndex === -1) { 
                        continue;
                    }

                    const currentRow = Math.floor(currentPosIndex / size);
                    const currentCol = currentPosIndex % size;

                    h += Math.abs(currentRow - goalPos.row) + Math.abs(currentCol - goalPos.col);
                }
                return h;
            };

            const initialH = heuristic(startBoard);
            openList.push({ f: initialH, g: 0, board: startBoard, empty: startEmptyIndex, path: [] });

            let iterationCount = 0;
            const MAX_ITERATIONS = 500000; // Increased iterations for more complex paths

            while (openList.length > 0 && iterationCount < MAX_ITERATIONS) {
                // Manual min-heap extraction
                let minF = Infinity;
                let minIndex = -1;
                for (let i = 0; i < openList.length; i++) {
                    if (openList[i].f < minF) {
                        minF = openList[i].f;
                        minIndex = i;
                    }
                }
                const { f, g, board, empty, path } = openList.splice(minIndex, 1)[0];
                iterationCount++;

                const boardString = JSON.stringify(board);
                if (closedList.has(boardString)) continue;
                closedList.add(boardString);

                // Check if current board state satisfies all targets for THIS phase
                let allGoalsMet = true;
                for (const tileValStr in targetGoals) {
                    const tileVal = parseInt(tileValStr);
                    const goalPos = targetGoals[tileValStr];
                    const currentTilePosIndex = board.indexOf(tileVal);
                    
                    if (currentTilePosIndex === -1 || Math.floor(currentTilePosIndex / size) !== goalPos.row || (currentTilePosIndex % size) !== goalPos.col) {
                        allGoalsMet = false;
                        break;
                    }
                }
                if (allGoalsMet) {
                    return path; // Path found for this phase's goals
                }

                const emptyRow = Math.floor(empty / size);
                const emptyCol = empty % size;

                const moves = [
                    { dr: 0, dc: 1 }, { dr: 0, dc: -1 }, // Right, Left
                    { dr: 1, dc: 0 }, { dr: -1, dc: 0 }  // Down, Up
                ];

                for (const move of moves) {
                    const newRow = emptyRow + move.dr;
                    const newCol = emptyCol + move.dc;

                    if (newRow >= 0 && newRow < size && newCol >= 0 && newCol < size) {
                        const neighborIdx = newRow * size + newCol;
                        const neighborValue = board[neighborIdx];

                        // IMPORTANT: Do not move locked tiles
                        if (lockedTileValues.includes(neighborValue)) {
                            continue;
                        }

                        const nextBoard = [...board];
                        [nextBoard[empty], nextBoard[neighborIdx]] = [nextBoard[neighborIdx], nextBoard[empty]]; // Swap
                        const nextEmpty = neighborIdx;

                        const nextBoardStr = JSON.stringify(nextBoard);
                        if (closedList.has(nextBoardStr)) continue;

                        const nextG = g + 1;
                        const nextH = heuristic(nextBoard);
                        const nextF = nextG + nextH;

                        // Check if this new state is already in openList with a better gScore
                        let foundInOpen = false;
                        for (let i = 0; i < openList.length; i++) {
                            if (JSON.stringify(openList[i].board) === nextBoardStr && openList[i].g <= nextG) {
                                foundInOpen = true;
                                break;
                            }
                        }
                        if (foundInOpen) continue;

                        openList.push({ f: nextF, g: nextG, board: nextBoard, empty: nextEmpty, path: [...path, neighborIdx] });
                    }
                }
            }
            return null; // Path not found or max iterations reached
        }

        // Helper to animate a sequence of moves and update the game state
        async function animateMoves(path, isHint = false) {
            for (const targetTileIndexToMove of path) {
                // Find the actual tile value at `targetTileIndexToMove` in the current `currentBoardState`
                const tileValueToMove = currentBoardState[targetTileIndexToMove];
                
                // Find the DOM element corresponding to this value
                const tileDOMElement = tiles.find(t => {
                    if (t.classList.contains('empty-tile')) return false;
                    const val = (gameMode === 'image' ? parseInt(t.id.replace('tile-', '')) : parseInt(t.querySelector('.tile-inner')?.textContent));
                    return val === tileValueToMove;
                });

                if (!tileDOMElement) {
                    console.error("DOM element not found for tile value:", tileValueToMove);
                    continue;
                }
                const tileDOMIndex = tiles.indexOf(tileDOMElement);

                // Perform the move on the DOM and update internal state
                await moveTile(tileDOMIndex, currentSize, true, isHint); // Use the isAutoSolve, isHintMove flag
                
                await new Promise(resolve => setTimeout(resolve, solverAnimationSpeed)); // Use dynamic speed
            }
        }

        // Main function for solving the puzzle step-by-step or instantly
        async function solveEntirePuzzle(initialBoard, size, isHintCalculation = false) {
            if (isCalculatingPath) {
                updateSolverMessage('–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è...');
                return; // Prevent re-entry
            }
            isCalculatingPath = true;
            isSolvingPuzzle = true; // Block manual moves during calculation/animation
            solveBtn.disabled = true;
            hintBtn.disabled = true;
            shuffleBtn.disabled = true; 
            applySizeBtn.disabled = true; 
            
            let currentPuzzleState = [...initialBoard]; 
            let locked = [];

            try {
                if (currentSize !== 4) {
                     throw new Error('–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–µ—à–µ–Ω–∏–µ –ø–æ–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–æ–ª—è 4x4. –†–∞–±–æ—Ç–∞–µ—Ç –Ω–∞–¥ –¥—Ä—É–≥–∏–º–∏ —Ä–∞–∑–º–µ—Ä–∞–º–∏!');
                }

                const phases = [
                    { name: '–ø–ª–∏—Ç–∫—É 1', targetGoals: { 1: {row: 0, col: 0} }, lock: [1], message: '–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞—é –ø–ª–∏—Ç–∫—É 1...' },
                    { name: '–ø–ª–∏—Ç–∫—É 2', targetGoals: { 2: {row: 0, col: 1} }, lock: [2], message: '–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞—é –ø–ª–∏—Ç–∫—É 2...' },
                    { name: '—Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –ø–ª–∏—Ç–∫–∏ 3 –∏ 4 (–≤—Ä–µ–º–µ–Ω–Ω–æ)', targetGoals: { 4: {row: 0, col: 2}, 3: {row: 1, col: 2} }, lock: [], message: '–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞—é —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –ø–ª–∏—Ç–∫–∏ 3 –∏ 4...' },
                    { name: '–ø–ª–∏—Ç–∫–∏ 3 –∏ 4 (—Ñ–∏–Ω–∞–ª—å–Ω–æ)', targetGoals: { 3: {row: 0, col: 2}, 4: {row: 0, col: 3} }, lock: [3, 4], message: '–ó–∞–≤–µ—Ä—à–∞—é –ø–µ—Ä–≤—ã–π —Ä—è–¥...' },
                    { name: '–ø—É—Å—Ç—É—é —è—á–µ–π–∫—É –¥–ª—è –≤—Ç–æ—Ä–æ–≥–æ —Ä—è–¥–∞', targetGoals: { 0: {row: 1, col: 3} }, lock: [], message: '–ü–µ—Ä–µ–º–µ—â–∞—é –ø—É—Å—Ç—É—é —è—á–µ–π–∫—É –¥–ª—è –≤—Ç–æ—Ä–æ–≥–æ —Ä—è–¥–∞...' },
                    { name: '–ø–ª–∏—Ç–∫—É 5', targetGoals: { 5: {row: 1, col: 0} }, lock: [5], message: '–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞—é –ø–ª–∏—Ç–∫—É 5...' },
                    { name: '–ø–ª–∏—Ç–∫—É 6', targetGoals: { 6: {row: 1, col: 1} }, lock: [6], message: '–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞—é –ø–ª–∏—Ç–∫—É 6...' },
                    { name: '—Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –ø–ª–∏—Ç–∫–∏ 7 –∏ 8 (–≤—Ä–µ–º–µ–Ω–Ω–æ)', targetGoals: { 8: {row: 1, col: 2}, 7: {row: 2, col: 2} }, lock: [], message: '–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞—é —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –ø–ª–∏—Ç–∫–∏ 7 –∏ 8...' },
                    { name: '–ø–ª–∏—Ç–∫–∏ 7 –∏ 8 (—Ñ–∏–Ω–∞–ª—å–Ω–æ)', targetGoals: { 7: {row: 1, col: 2}, 8: {row: 1, col: 3} }, lock: [7, 8], message: '–ó–∞–≤–µ—Ä—à–∞—é –≤—Ç–æ—Ä–æ–π —Ä—è–¥...' },
                    { name: '–ø—É—Å—Ç—É—é —è—á–µ–π–∫—É –¥–ª—è —Ç—Ä–µ—Ç—å–µ–π —Å—Ç—Ä–æ–∫–∏', targetGoals: { 0: {row: 2, col: 0} }, lock: [], message: '–ü–µ—Ä–µ–º–µ—â–∞—é –ø—É—Å—Ç—É—é —è—á–µ–π–∫—É –¥–ª—è —Ç—Ä–µ—Ç—å–µ–π —Å—Ç—Ä–æ–∫–∏...' },
                    { name: '–ø–ª–∏—Ç–∫–∏ 9 –∏ 13', targetGoals: { 9: {row: 2, col: 0}, 13: {row: 3, col: 0}, 0: {row: 3, col: 1} }, lock: [9, 13], message: '–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞—é –ø–ª–∏—Ç–∫–∏ 9 –∏ 13...' },
                    { name: '–ø–ª–∏—Ç–∫–∏ 10 –∏ 14', targetGoals: { 10: {row: 2, col: 1}, 14: {row: 3, col: 1}, 0: {row: 3, col: 2} }, lock: [10, 14], message: '–ü—Ä–æ—Å—á–∏—Ç—ã–≤–∞—é –ø–ª–∏—Ç–∫–∏ 10 –∏ 14...' },
                    { name: '–ø–æ—Å–ª–µ–¥–Ω–∏–π –±–ª–æ–∫ 2x2', targetGoals: {11: {row: 2, col: 2}, 12: {row: 2, col: 3}, 15: {row: 3, col: 2}, 0: {row: 3, col: 3}}, lock: [], message: '–ó–∞–≤–µ—Ä—à–∞—é –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É...' }
                ];

                if (solverMode === 'instant' || isHintCalculation) { // Hint also calculates full path instantly
                    let fullSolutionPath = [];
                    for (const phase of phases) {
                        updateSolverMessage(phase.message);
                        const phasePath = await findPathToGoal(currentPuzzleState, currentSize, phase.targetGoals, locked);
                        if (!phasePath) throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø—É—Ç—å –¥–ª—è —Ñ–∞–∑—ã: ${phase.name}.`);
                        
                        // Simulate moves on the currentPuzzleState for the next phase's calculation
                        for (const targetTileIndexToMove of phasePath) {
                            const emptyPos = currentPuzzleState.indexOf(0);
                            const tileValue = currentPuzzleState[targetTileIndexToMove];
                            const tilePos = targetTileIndexToMove;
                            [currentPuzzleState[emptyPos], currentPuzzleState[tilePos]] = [currentPuzzleState[tilePos], currentPuzzleState[emptyPos]];
                        }
                        fullSolutionPath = fullSolutionPath.concat(phasePath);
                        locked = locked.concat(phase.lock);
                    }
                    currentSolverPath = fullSolutionPath; // Store the full path
                    currentSolverPathStep = 0; // Reset step counter
                    hideLoadingOverlay(); // Hide loading after all calculations are done

                    if (isHintCalculation) {
                        // For hint, only move the first tile and then return
                        if (currentSolverPath.length > 0) {
                            await animateMoves([currentSolverPath[currentSolverPathStep]], true); // Move first tile
                            currentSolverPathStep++;
                        } else {
                            showMessageModal('–ü–æ–¥—Å–∫–∞–∑–∫–∞', '–ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞ —É–∂–µ —Ä–µ—à–µ–Ω–∞ –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ö–æ–¥–æ–≤.');
                        }
                    } else {
                        // For full solve, animate all moves
                        for (const moveTileIndex of currentSolverPath) {
                            if (checkWin(currentSize)) break;
                            await animateMoves([moveTileIndex], false);
                        }
                    }

                } else { // 'step-by-step' mode
                    for (const phase of phases) {
                        updateSolverMessage(phase.message);
                        const phasePath = await findPathToGoal(currentPuzzleState, currentSize, phase.targetGoals, locked);
                        if (!phasePath) throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø—É—Ç—å –¥–ª—è —Ñ–∞–∑—ã: ${phase.name}.`);
                        
                        // NEW: Simulate moves on the currentPuzzleState for the next phase's calculation
                        // This is crucial for the "background calculation" effect.
                        for (const targetTileIndexToMove of phasePath) {
                            const emptyPos = currentPuzzleState.indexOf(0);
                            const tileValue = currentPuzzleState[targetTileIndexToMove];
                            const tilePos = targetTileIndexToMove;
                            [currentPuzzleState[emptyPos], currentPuzzleState[tilePos]] = [currentPuzzleState[tilePos], currentPuzzleState[emptyPos]];
                        }
                        locked = locked.concat(phase.lock);

                        // NEW: Start animation, and then immediately start calculating the next phase.
                        hideLoadingOverlay(); // Hide during animation
                        await animateMoves(phasePath);
                        
                        // After animation, the actual board state is updated by animateMoves.
                        // The `currentPuzzleState` for the *next* phase is already updated above.
                        // So, we just continue the loop.
                    }
                }

                if (checkWin(currentSize)) {
                     endGame(true, '–ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ—à–µ–Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º!');
                } else {
                     showMessageModal('–û—à–∏–±–∫–∞ —Ä–µ—à–µ–Ω–∏—è', '–ê–ª–≥–æ—Ä–∏—Ç–º –Ω–µ —Å–º–æ–≥ –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ä–µ—à–∏—Ç—å –≥–æ–ª–æ–≤–æ–ª–æ–º–∫—É. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–±–ª–µ–º–∞ –≤ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—è —Å—Ç–∞–ª–æ –Ω–µ—Ä–µ—à–∞–µ–º—ã–º.');
                }

            } catch (error) {
                showMessageModal('–û—à–∏–±–∫–∞ —Ä–µ—à–µ–Ω–∏—è', `–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ—à–µ–Ω–∏–∏: ${error.message}`);
                console.error("Solver error:", error);
            } finally {
                hideLoadingOverlay();
                isCalculatingPath = false;
                isSolvingPuzzle = false;
                solveBtn.disabled = false;
                hintBtn.disabled = false;
                shuffleBtn.disabled = false;
                applySizeBtn.disabled = false;
            }
        }
        
        // Event Handlers
        gameField.addEventListener('click', (e) => {
            if (isSolvingPuzzle) return; 
            const tile = e.target.closest('.tile');
            if (tile) {
                vibrationManager.click();
                const tileIndex = tiles.indexOf(tile);
                if (tileIndex !== -1) { moveTile(tileIndex, currentSize); }
            }
        });

        // ‚ú® –ò–°–ü–†–ê–í–õ–ï–ù–û: –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–≤–∞–π–ø–æ–≤
        let swipeStartX, swipeStartY;
        gameField.addEventListener('touchstart', (e) => {
            if (isSolvingPuzzle) return; 
            if (e.touches.length === 1) {
                swipeStartX = e.touches[0].clientX;
                swipeStartY = e.touches[0].clientY;
            }
        }, { passive: true });

        gameField.addEventListener('touchmove', (e) => {
            if (isSolvingPuzzle) return; 
            e.preventDefault();
        }, { passive: false });

        gameField.addEventListener('touchend', (e) => {
            if (isSolvingPuzzle) return; 
            if (e.changedTouches.length === 1) {
                const swipeEndX = e.changedTouches[0].clientX;
                const swipeEndY = e.changedTouches[0].clientY;

                const deltaX = swipeEndX - swipeStartX;
                const deltaY = swipeEndY - swipeStartY;

                if (Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20) return; 

                let tileToMoveIndex = -1;
                const emptyTileRow = Math.floor(emptyTileIndex / currentSize);
                const emptyTileCol = emptyTileIndex % currentSize;

                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–∞–π–ø–∞
                if (Math.abs(deltaX) > Math.abs(deltaY)) { // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø
                    if (deltaX > 0) { // –í–ø—Ä–∞–≤–æ
                        if (emptyTileCol > 0) tileToMoveIndex = emptyTileIndex - 1;
                    } else { // –í–ª–µ–≤–æ
                        if (emptyTileCol < currentSize - 1) tileToMoveIndex = emptyTileIndex + 1;
                    }
                } else { // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø
                    if (deltaY > 0) { // –í–Ω–∏–∑
                        if (emptyTileRow > 0) tileToMoveIndex = emptyTileIndex - currentSize;
                    } else { // –í–≤–µ—Ä—Ö
                        if (emptyTileRow < currentSize - 1) tileToMoveIndex = emptyTileIndex + currentSize;
                    }
                }

                if (tileToMoveIndex !== -1) {
                    vibrationManager.click();
                    moveTile(tileToMoveIndex, currentSize);
                }
            }
        });

        tileColorPicker.addEventListener('change', () => updateColors('tile'));
        bgColorPicker.addEventListener('change', () => updateColors('bg'));
        borderColorPicker.addEventListener('change', () => updateColors('border'));
        textColorPicker.addEventListener('change', () => updateColors('text')); // This now controls --tile-text-color
        highlightColorPicker.addEventListener('change', (e) => {
            document.documentElement.style.setProperty('--user-override-highlight-color', highlightColorPicker.value);
            // Read back the effectively applied color for immediate visual update on the highlighted tile
            const currentHighlightColor = getComputedStyle(document.documentElement).getPropertyValue('--user-override-highlight-color', getComputedStyle(document.documentElement).getPropertyValue('--highlight-color'));
            if (highlightedTile) {
                highlightedTile.style.backgroundColor = currentHighlightColor; 
                highlightedTile.style.color = getContrastColor(currentHighlightColor);
            }
            gameStats.colorsChanged.add('highlight');
            saveStats();
            checkAchievements();
        });
        correctColorPicker.addEventListener('change', () => { 
            document.documentElement.style.setProperty('--user-override-correct-color', correctColorPicker.value);
            highlightCorrectTiles(currentSize); 
            gameStats.colorsChanged.add('correct');
            saveStats();
            checkAchievements(); 
        });

        findNumberBtn.addEventListener('click', () => {
            const number = parseInt(numberInput.value);
            if (!isNaN(number)) { highlightNumber(number); }
        });

        numberInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const number = parseInt(numberInput.value);
                if (!isNaN(number)) { highlightNumber(number); }
            }
        });

        applySizeBtn.addEventListener('click', () => {
            const size = parseInt(sizeSlider.value);
            if (size >= 2 && size <= 20) {
                currentSize = size;
                createGame(size);
                shuffleTiles(true); 
            }
        });

        shuffleBtn.addEventListener('click', () => shuffleTiles(false)); 
        autoHighlightBtn.addEventListener('click', toggleAutoHighlight);
        vibrationToggleBtn.addEventListener('click', () => { vibrationManager.toggle(); });
        
        // NEW: Show Solver Modal Toggle
        function updateShowSolverModalButton() {
            if (showSolverModal) {
                showSolverModalToggleBtn.innerHTML = `<i class="fas fa-check"></i> –í–∫–ª—é—á–µ–Ω–æ`;
                showSolverModalToggleBtn.classList.remove('btn-danger');
                showSolverModalToggleBtn.classList.add('btn-success');
            } else {
                showSolverModalToggleBtn.innerHTML = `<i class="fas fa-times"></i> –í—ã–∫–ª—é—á–µ–Ω–æ`;
                showSolverModalToggleBtn.classList.remove('btn-success');
                showSolverModalToggleBtn.classList.add('btn-danger');
            }
        }
        showSolverModalToggleBtn.addEventListener('click', () => {
            showSolverModal = !showSolverModal;
            updateShowSolverModalButton();
            saveStats();
            vibrationManager.click();
            if (!showSolverModal && loadingModal.classList.contains('active')) {
                // If modal was active and now disabled, move message to header
                const title = document.getElementById('loadingTitle').textContent;
                const message = document.getElementById('loadingMessage').textContent;
                updateSolverMessage(message, title);
            } else if (showSolverModal && solverMessageDisplay.style.display !== 'none') {
                // If header message was active and now modal enabled, hide header message
                hideLoadingOverlay();
            }
        });

        // Hint button logic
        hintBtn.addEventListener('click', async () => {
            if (isCalculatingPath) {
                updateSolverMessage('–ü–æ–¥—Å–∫–∞–∑–∫–∞ —É–∂–µ –ø—Ä–æ—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è...');
                return;
            }
            if (checkWin(currentSize)) {
                showMessageModal('–ü–æ–¥—Å–∫–∞–∑–∫–∞', '–ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞ —É–∂–µ —Ä–µ—à–µ–Ω–∞!');
                return;
            }

            vibrationManager.hint();
            gameStats.hintsUsed++;
            usedHintInCurrentGame = true; 
            saveStats();
            checkAchievements();
            
            if (!currentSolverPath || currentSolverPathStep >= currentSolverPath.length) {
                // Calculate new path if none exists or path is exhausted
                const currentBoard = tiles.map(t => {
                    if (t.classList.contains('empty-tile')) return 0;
                    return gameMode === 'image' ? parseInt(t.id.replace('tile-', '')) : parseInt(t.querySelector('.tile-inner')?.textContent);
                });
                await solveEntirePuzzle(currentBoard, currentSize, true); // Calculate full path for hint
            } else {
                // Move next tile from existing path
                await animateMoves([currentSolverPath[currentSolverPathStep]], true);
                currentSolverPathStep++;
            }
        });

        // Solve button logic
        solveBtn.addEventListener('click', async () => {
            if (isCalculatingPath) {
                updateSolverMessage('–ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞ —É–∂–µ —Ä–µ—à–∞–µ—Ç—Å—è!');
                return;
            }
            if (checkWin(currentSize)) {
                showMessageModal('–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ', '–ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞ —É–∂–µ —Ä–µ—à–µ–Ω–∞!');
                return;
            }

            vibrationManager.solve();
            usedAutoSolveInCurrentGame = true; 

            const currentBoard = tiles.map(t => {
                if (t.classList.contains('empty-tile')) return 0;
                return gameMode === 'image' ? parseInt(t.id.replace('tile-', '')) : parseInt(t.querySelector('.tile-inner')?.textContent);
            });

            await solveEntirePuzzle(currentBoard, currentSize, false);
        });

        // Solver Mode Toggle Button Logic
        function updateSolverModeButton() {
            if (solverMode === 'step-by-step') {
                solverModeToggleBtn.innerHTML = `<i class="fas fa-sync-alt"></i> –ü–æ—ç—Ç–∞–ø–Ω—ã–π`;
                solverModeToggleBtn.classList.remove('btn-warning');
                solverModeToggleBtn.classList.add('btn-info');
            } else {
                solverModeToggleBtn.innerHTML = `<i class="fas fa-bolt"></i> –ú–æ–º–µ–Ω—Ç–∞–ª—å–Ω—ã–π`;
                solverModeToggleBtn.classList.remove('btn-info');
                solverModeToggleBtn.classList.add('btn-warning');
            }
        }

        solverModeToggleBtn.addEventListener('click', () => {
            solverMode = (solverMode === 'step-by-step') ? 'instant' : 'step-by-step';
            updateSolverModeButton();
            saveStats(); // Save the new setting
            vibrationManager.click();
        });

        // Solver Speed Modal Logic
        function updateSolverSpeedDisplay() {
            solverSpeedDisplay.textContent = `${solverAnimationSpeed} –º—Å`;
        }

        // Function to run the demo animation
        function runDemoAnimation() {
            const animationDuration = parseInt(demoSpeedSlider.value); // Get current demo speed

            // Reset to initial positions for a clean restart of animation
            demoTile1.style.transition = 'none'; // Disable transition for reset
            demoEmptyTile.style.transition = 'none'; // Disable transition for reset
            
            // Initial position: Tile 1 at bottom-right (index 3), Empty at top-left (index 0)
            const tileSizeInDemo = 50;
            const tileGapInDemo = 5;
            demoTile1.style.transform = `translate(${1 * (tileSizeInDemo + tileGapInDemo)}px, ${1 * (tileSizeInDemo + tileGapInDemo)}px)`;
            demoEmptyTile.style.transform = `translate(${0 * (tileSizeInDemo + tileGapInDemo)}px, ${0 * (tileSizeInDemo + tileGapInDemo)}px)`;

            // Force reflow to apply reset instantly
            void demoTile1.offsetWidth;
            void demoEmptyTile.offsetWidth;

            // Set transition duration for animation
            demoTile1.style.transition = `transform ${animationDuration}ms linear`;
            demoEmptyTile.style.transition = `transform ${animationDuration}ms linear`;

            // Animate to target positions: Tile 1 to top-left, Empty to bottom-right
            demoTile1.style.transform = `translate(${0 * (tileSizeInDemo + tileGapInDemo)}px, ${0 * (tileSizeInDemo + tileGapInDemo)}px)`;
            demoEmptyTile.style.transform = `translate(${1 * (tileSizeInDemo + tileGapInDemo)}px, ${1 * (tileSizeInDemo + tileGapInDemo)}px)`;

            // Reset positions after animation completes
            setTimeout(() => {
                demoTile1.style.transition = 'none';
                demoEmptyTile.style.transition = 'none';
                demoTile1.style.transform = `translate(${1 * (tileSizeInDemo + tileGapInDemo)}px, ${1 * (tileSizeInDemo + tileGapInDemo)}px)`;
                demoEmptyTile.style.transform = `translate(${0 * (tileSizeInDemo + tileGapInDemo)}px, ${0 * (tileSizeInDemo + tileGapInDemo)}px)`;
            }, animationDuration);
        }

        changeSolverSpeedBtn.addEventListener('click', () => {
            solverSpeedModal.classList.add('active');
            // Set demo slider to current solverAnimationSpeed
            demoSpeedSlider.value = solverAnimationSpeed;
            demoSpeedValue.textContent = `${solverAnimationSpeed} –º—Å`;
            runDemoAnimation(); // Start demo animation
        });

        demoSpeedSlider.addEventListener('input', () => {
            demoSpeedValue.textContent = `${demoSpeedSlider.value} –º—Å`;
            runDemoAnimation(); // Rerun demo animation with new speed
        });

        applySolverSpeedBtn.addEventListener('click', () => {
            solverAnimationSpeed = parseInt(demoSpeedSlider.value);
            updateSolverSpeedDisplay();
            saveStats(); // Save the new setting
            solverSpeedModal.classList.remove('active');
        });

        closeSolverSpeedModalBtn.addEventListener('click', () => {
            solverSpeedModal.classList.remove('active');
        });

        // NEW: Font Loading Logic
        fontUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type === 'font/ttf') {
                const reader = new FileReader();
                reader.onload = (event) => {
                    customFontUrl = event.target.result;
                    fontOptions.style.display = 'block'; // Show options after file is loaded
                    
                    // Update the @font-face rule's src in the dedicated style element
                    if (customFontStyleElement) {
                        customFontStyleElement.textContent = `@font-face { font-family: 'CustomFont'; src: url("${customFontUrl}"); }`;
                    } else {
                        // Fallback, though customFontStyleElement should be initialized in init()
                        console.warn("customFontStyleElement not found, creating a new style element for font.");
                        customFontStyleElement = document.createElement('style');
                        customFontStyleElement.id = 'custom-font-style';
                        customFontStyleElement.textContent = `@font-face { font-family: 'CustomFont'; src: url("${customFontUrl}"); }`;
                        document.head.appendChild(customFontStyleElement);
                    }

                    const font = new FontFace('CustomFont', `url("${customFontUrl}")`);
                    font.load().then(() => {
                        document.fonts.add(font);
                        customFontLoaded = true;
                        console.log('Font loaded:', file.name);
                        // Optionally apply to tiles for a quick preview
                        // Do not automatically apply, let user choose via radio buttons
                        // tiles.forEach(tile => tile.classList.add('custom-font-tile'));
                        // document.body.classList.remove('custom-font-all');
                    }).catch(error => {
                        console.error('Error loading font:', error);
                        showMessageModal('–û—à–∏–±–∫–∞', '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —à—Ä–∏—Ñ—Ç. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª .ttf.');
                        customFontLoaded = false;
                        fontOptions.style.display = 'none';
                    });
                };
                reader.readAsDataURL(file);
            } else {
                showMessageModal('–û—à–∏–±–∫–∞', '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª —à—Ä–∏—Ñ—Ç–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ .ttf.');
                fontOptions.style.display = 'none';
            }
        });

        applyFontBtn.addEventListener('click', () => {
            if (!customFontLoaded) {
                showMessageModal('–û—à–∏–±–∫–∞', '–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ —à—Ä–∏—Ñ—Ç.');
                return;
            }
            if (fontApplyTilesRadio.checked) {
                customFontApplyScope = 'tiles';
                applyCustomFont();
            } else if (fontApplyAllRadio.checked) {
                customFontApplyScope = 'all';
                applyCustomFont();
            } else {
                showMessageModal('–û—à–∏–±–∫–∞', '–í—ã–±–µ—Ä–∏—Ç–µ, –∫—É–¥–∞ –ø—Ä–∏–º–µ–Ω–∏—Ç—å —à—Ä–∏—Ñ—Ç.');
                return;
            }
            saveStats();
            showMessageModal('–£—Å–ø–µ—Ö', '–®—Ä–∏—Ñ—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω!');
        });

        resetFontBtn.addEventListener('click', () => {
            customFontLoaded = false;
            customFontApplyScope = 'none';
            customFontUrl = ''; // Clear the URL
            // Reset the @font-face rule's src in the dedicated style element
            if (customFontStyleElement) {
                customFontStyleElement.textContent = `@font-face { font-family: 'CustomFont'; src: url(''); }`; // Reset to empty
            }
            applyCustomFont(); // Remove custom font styles
            fontOptions.style.display = 'none';
            fontUploadInput.value = ''; // Clear file input
            saveStats();
            showMessageModal('–°–±—Ä–æ—Å', '–®—Ä–∏—Ñ—Ç —Å–±—Ä–æ—à–µ–Ω –¥–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ.');
        });

        function applyCustomFont() {
            // Remove all custom font classes first
            document.body.classList.remove('custom-font-all');
            tiles.forEach(tile => tile.classList.remove('custom-font-tile'));

            if (customFontLoaded) {
                if (customFontApplyScope === 'tiles') {
                    tiles.forEach(tile => tile.classList.add('custom-font-tile'));
                } else if (customFontApplyScope === 'all') {
                    document.body.classList.add('custom-font-all');
                }
            }
        }

        // NEW: Music Player Logic
        function renderMusicPlaylist() {
            musicPlaylist.innerHTML = '';
            musicPlaylistData.forEach((song, index) => {
                const li = document.createElement('li');
                li.className = 'font-list-item'; // Reusing style
                li.textContent = song.name;
                li.dataset.index = index;
                if (index === currentMusicIndex) {
                    // Use CSS variables for highlight color
                    li.style.fontWeight = 'bold';
                    li.style.color = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
                } else {
                    // Ensure normal state also uses CSS variables
                    li.style.fontWeight = 'normal';
                    li.style.color = getComputedStyle(document.documentElement).getPropertyValue('--text-main').trim();
                }
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '–£–¥–∞–ª–∏—Ç—å';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent li click
                    deleteSong(index);
                });
                li.appendChild(deleteBtn);
                li.addEventListener('click', () => {
                    playSong(index);
                });
                musicPlaylist.appendChild(li);
            });
        }

        function playSong(index) {
            if (index < 0 || index >= musicPlaylistData.length) return;
            currentMusicIndex = index;
            backgroundMusic.src = musicPlaylistData[index].url;
            backgroundMusic.play().catch(e => console.error("Error playing music:", e));
            renderMusicPlaylist(); // Update highlighted song
            saveStats();
        }

        function deleteSong(index) {
            // Check if all default music tracks are being deleted
            const defaultMusicCount = musicPlaylistData.filter(song => 
                (song.name === 'Default Music' && song.url === 'music.mp3') || 
                (song.name === 'Default Music 2' && song.url === 'music1.mp3')
            ).length;

            if (musicPlaylistData.length === defaultMusicCount && defaultMusicCount > 0) {
                showMessageModal('–û—à–∏–±–∫–∞', '–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –≤—Å–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø–µ—Å–Ω–∏. –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Å–≤–æ—é –ø–µ—Å–Ω—é, —á—Ç–æ–±—ã –∑–∞–º–µ–Ω–∏—Ç—å –∏—Ö.');
                return;
            }
            
            musicPlaylistData.splice(index, 1);
            
            if (index === currentMusicIndex) {
                // If current song deleted, try to play the next or previous one
                if (musicPlaylistData.length > 0) {
                    currentMusicIndex = Math.max(0, index - 1); // Play previous or first
                    playSong(currentMusicIndex);
                } else {
                    backgroundMusic.pause();
                    backgroundMusic.src = '';
                    currentMusicIndex = 0;
                }
            } else if (index < currentMusicIndex) {
                currentMusicIndex--; // Adjust index if a song before current was deleted
            }
            renderMusicPlaylist();
            saveStats();
        }

        musicUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type === 'audio/mpeg') { // Check for MP3
                const reader = new FileReader();
                reader.onload = (event) => {
                    const newSong = {
                        name: file.name,
                        url: event.target.result
                    };
                    // Check if *only* default music exists, and if so, replace it with the new song
                    const isOnlyDefaultMusicPresent = musicPlaylistData.every(song => 
                        (song.name === 'Default Music' && song.url === 'music.mp3') || 
                        (song.name === 'Default Music 2' && song.url === 'music1.mp3')
                    );
                    
                    if (isOnlyDefaultMusicPresent) {
                        musicPlaylistData = [newSong]; // Replace all defaults with the new song
                        currentMusicIndex = 0;
                    } else {
                        musicPlaylistData.push(newSong);
                        currentMusicIndex = musicPlaylistData.length - 1; // Select the newly added song
                    }
                    
                    playSong(currentMusicIndex);
                    renderMusicPlaylist();
                    saveStats();
                    showMessageModal('–£—Å–ø–µ—Ö', `–ü–µ—Å–Ω—è "${file.name}" –∑–∞–≥—Ä—É–∂–µ–Ω–∞!`);
                };
                reader.readAsDataURL(file);
            } else {
                showMessageModal('–û—à–∏–±–∫–∞', '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –ø–µ—Å–Ω–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ .mp3.');
            }
        });

        playMusicBtn.addEventListener('click', () => {
            if (backgroundMusic.src) {
                backgroundMusic.play().catch(e => console.error("Error playing music:", e));
            } else if (musicPlaylistData.length > 0) {
                playSong(currentMusicIndex);
            }
        });

        pauseMusicBtn.addEventListener('click', () => {
            backgroundMusic.pause();
        });

        document.body.addEventListener('click', (e) => {
            // Exclude Theme Toggle as it has its own vibration logic
            if (e.target.closest('.btn, .tab-button, .mode-card') && !e.target.closest('#vibrationToggleBtn') && !e.target.closest('#solverModeToggleBtn') && !e.target.closest('#changeSolverSpeedBtn') && !e.target.closest('#applySolverSpeedBtn') && !e.target.closest('#closeSolverSpeedModalBtn') && !e.target.closest('#font-upload-input') && !e.target.closest('#applyFontBtn') && !e.target.closest('#resetFontBtn') && !e.target.closest('#music-upload-input') && !e.target.closest('#playMusicBtn') && !e.target.closest('#pauseMusicBtn') && !e.target.closest('#showSolverModalToggleBtn') && e.target.id !== 'themeToggleButton') { 
                vibrationManager.click();
            }
        });

        // NEW: Theme Toggle button logic
        function updateThemeButton() {
            if (currentTheme === 'dark-theme') {
                themeToggleButton.innerHTML = `<i class="fas fa-moon"></i> –¢–µ–º–Ω–∞—è —Ç–µ–º–∞`;
                themeToggleButton.classList.remove('inactive-toggle');
                themeToggleButton.classList.add('active-toggle');
            } else {
                themeToggleButton.innerHTML = `<i class="fas fa-sun"></i> –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞`;
                themeToggleButton.classList.remove('active-toggle');
                themeToggleButton.classList.add('inactive-toggle'); // Using inactive-toggle for light
            }
        }

        themeToggleButton.addEventListener('click', () => {
            currentTheme = (currentTheme === 'light-theme') ? 'dark-theme' : 'light-theme';
            if (currentTheme === 'dark-theme') {
                body.classList.add('dark-theme');
            } else {
                body.classList.remove('dark-theme');
            }
            saveStats(); // Save the new theme preference
            updateThemeButton(); // Update button visual
            
            // Clear all user overrides so that theme defaults apply
            document.documentElement.style.setProperty('--user-override-tile-color', '');
            document.documentElement.style.setProperty('--user-override-background-body', '');
            document.documentElement.style.setProperty('--user-override-border-game-field', '');
            document.documentElement.style.setProperty('--user-override-tile-text-color', '');
            document.documentElement.style.setProperty('--user-override-highlight-color', '');
            document.documentElement.style.setProperty('--user-override-correct-color', '');

            // Re-sync pickers and visual elements to the new theme's defaults
            updateColorPickersFromCSS();
            applyVisualUpdates(); // Re-render tiles and other elements
            renderMusicPlaylist(); // Update music playlist text color
        });

        function init() {
            // Initialize the dedicated style element for custom font
            customFontStyleElement = document.createElement('style');
            customFontStyleElement.id = 'custom-font-style';
            document.head.appendChild(customFontStyleElement);

            vibrationManager.load();
            initSliders();
            loadStats(); // Load theme preference and apply it first
            updateSolverModeButton(); // Set initial state of the solver mode button
            updateSolverSpeedDisplay(); // Set initial state of the solver speed display
            updateShowSolverModalButton(); // NEW: Set initial state of the show solver modal button
            renderModes();
            createGame(4); 
            currentBoardState = tiles.map(t => {
                if (t.classList.contains('empty-tile')) return 0;
                return gameMode === 'image' ? parseInt(t.id.replace('tile-', '')) : parseInt(t.querySelector('.tile-inner')?.textContent);
            });
            shuffleTiles(true); 
            checkAchievements(); 
            document.querySelector('.tab-content.active').querySelectorAll('.settings-card').forEach((card, index) => {
                card.style.animation = `fadeInUp 0.5s ease-out ${index * 0.07}s forwards`;
            });

            // Apply loaded custom font
            if (customFontLoaded && customFontUrl) {
                // Set the src for the @font-face rule in the dynamically created style element
                customFontStyleElement.textContent = `@font-face { font-family: 'CustomFont'; src: url("${customFontUrl}"); }`;
                const font = new FontFace('CustomFont', `url("${customFontUrl}")`); 
                font.load().then(() => {
                    document.fonts.add(font);
                    applyCustomFont();
                    // Set radio buttons based on loaded scope
                    if (customFontApplyScope === 'tiles') fontApplyTilesRadio.checked = true;
                    else if (customFontApplyScope === 'all') fontApplyAllRadio.checked = true;
                    fontOptions.style.display = 'block';
                }).catch(error => {
                    console.error('Error reloading saved font:', error);
                    customFontLoaded = false;
                    customFontApplyScope = 'none';
                    saveStats(); // Clear corrupted font data
                });
            }

            // Init music player
            backgroundMusic.volume = musicVolumeSlider.value / 100; // Apply loaded volume
            
            // START MODIFICATION: Updated logic for default music initialization
            // Define the set of default music tracks
            const defaultTracks = [
                { name: 'Default Music', url: 'music.mp3' },
                { name: 'Default Music 2', url: 'music1.mp3' }
            ];

            // Check if the current playlist (potentially loaded from localStorage)
            // contains only a subset of the default tracks, or is empty.
            const hasOnlySomeDefaults = musicPlaylistData.every(song => 
                defaultTracks.some(defaultSong => defaultSong.name === song.name && defaultSong.url === song.url)
            ) && musicPlaylistData.length < defaultTracks.length;
            
            const isEmptyPlaylist = musicPlaylistData.length === 0;

            if (isEmptyPlaylist || hasOnlySomeDefaults) {
                // If playlist is empty or only contains a subset of defaults,
                // replace it with the full set of default tracks.
                musicPlaylistData = [...defaultTracks];
                currentMusicIndex = 0; // Reset index to the first default track
            }

            if (musicPlaylistData.length > 0) {
                backgroundMusic.src = musicPlaylistData[currentMusicIndex].url;
            } else {
                // Fallback in case something unexpected happens and playlist is still empty
                backgroundMusic.src = '';
            }
            // END MODIFICATION
            
            renderMusicPlaylist();

            // NEW: Ensure solver related displays are hidden on load
            hideLoadingOverlay(); 
            solverMessageDisplay.innerHTML = ''; 
        }
        
        init();
        
        window.addEventListener('beforeunload', (e) => { saveStats(); });

        let isModalActive = false;
        messageModal.addEventListener('transitionend', () => { isModalActive = messageModal.classList.contains('active'); });
        loadingModal.addEventListener('transitionend', () => { isModalActive = loadingModal.classList.contains('active'); }); 
        solverSpeedModal.addEventListener('transitionend', () => { isModalActive = solverSpeedModal.classList.contains('active'); }); 

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && timerInterval && !isModalActive) {
                if (!checkWin(currentSize) && timeLeft > 0) { 
                    clearInterval(timerInterval);
                    timerInterval = null;
                    showMessageModal('–ò–≥—Ä–∞ –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞', '–í—Ä–µ–º—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ, –ø–æ–∫–∞ –≤—ã –Ω–µ –≤–µ—Ä–Ω–µ—Ç–µ—Å—å. –ù–∞–∂–º–∏—Ç–µ –û–ö, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.', () => {
                        if (gameMode === 'time') { startTimer(); }
                    });
                }
            } else if (!document.hidden && !isModalActive && gameMode === 'time' && !timerInterval && timeLeft > 0 && isTimeModeGameStarted) {
                startTimer();
            }
        });
    </script>
</body>
    </html>
